<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Piccolo源码解读（二）——反射实现</title>
    <link href="/posts/2930143108/"/>
    <url>/posts/2930143108/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前我们对源码的项目结构有了简单的了解，这篇文章我们来看看Piccolo里是怎么实现反射的</p></blockquote><span id="more"></span><p>我们先看一下生成的反射文件和源码，这里拿engine/source/runtime/function/framework.component/animation/animation_component.h举例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;runtime/function/animation/skeleton.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;runtime/function/framework/component/component.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;runtime/resource/res_type/components/animation.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Piccolo<br>&#123;<br>    <span class="hljs-built_in">REFLECTION_TYPE</span>(AnimationComponent)<br>    <span class="hljs-built_in">CLASS</span>(AnimationComponent : <span class="hljs-keyword">public</span> Component, WhiteListFields)<br>    &#123;<br>        <span class="hljs-built_in">REFLECTION_BODY</span>(AnimationComponent)<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">AnimationComponent</span>() = <span class="hljs-keyword">default</span>;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postLoadResource</span><span class="hljs-params">(std::weak_ptr&lt;GObject&gt; parent_object)</span> <span class="hljs-keyword">override</span></span>;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tick</span><span class="hljs-params">(<span class="hljs-type">float</span> delta_time)</span> <span class="hljs-keyword">override</span></span>;<br><br>        <span class="hljs-function"><span class="hljs-type">const</span> AnimationResult&amp; <span class="hljs-title">getResult</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-built_in">META</span>(Enable)<br>        AnimationComponentRes m_animation_res;<br><br>        Skeleton m_skeleton;<br>    &#125;;<br>&#125; <span class="hljs-comment">// namespace Piccolo</span><br></code></pre></td></tr></table></figure><p>为了实现反射，类的声明用到了宏定义，其中WhiteListFields表示白名单，只有被<code>META(Enable)</code>的字段会被注册到反射中。</p><p>REFLECTION_TYPE的宏定义在engine/source/runtime/core/meta/reflection/reflection.h中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REFLECTION_TYPE(class_name) \</span><br><span class="hljs-meta">    namespace Reflection \</span><br><span class="hljs-meta">    &#123; \</span><br><span class="hljs-meta">        namespace TypeFieldReflectionOparator \</span><br><span class="hljs-meta">        &#123; \</span><br><span class="hljs-meta">            class Type##class_name##Operator; \</span><br><span class="hljs-meta">        &#125; \</span><br><span class="hljs-meta">    &#125;;</span><br></code></pre></td></tr></table></figure><p>就是简单声明了一个命名空间中的类名，注意这里类名和实际的class_name有了变化，##表示符号的拼接，也就是声明了一个<code>TypeAnimationComponentOperator</code>类。</p><p>REFLECTION_BODY则是声明了一系列友元类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REFLECTION_BODY(class_name) \</span><br><span class="hljs-meta">    friend class Reflection::TypeFieldReflectionOparator::Type##class_name##Operator; \</span><br><span class="hljs-meta">    friend class PSerializer;</span><br></code></pre></td></tr></table></figure><p>这里就有REFLECTION_TYPE里声明的类。</p><p>接下来CLASS和META的定义有个小的trick，容易走歪。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__REFLECTION_PARSER__)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> META(...) __attribute__((annotate(#__VA_ARGS__)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS(class_name, ...) class __attribute__((annotate(#__VA_ARGS__))) class_name</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRUCT(struct_name, ...) struct __attribute__((annotate(#__VA_ARGS__))) struct_name</span><br><span class="hljs-comment">//#define CLASS(class_name,...) class __attribute__((annotate(#__VA_ARGS__))) class_name:public Reflection::object</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> META(...)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS(class_name, ...) class class_name</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRUCT(struct_name, ...) struct struct_name</span><br><span class="hljs-comment">//#define CLASS(class_name,...) class class_name:public Reflection::object</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// __REFLECTION_PARSER__</span></span><br></code></pre></td></tr></table></figure><p>这里我们的IDE高亮的是#else这部分，但实际上我们编译的时候走的是上面的#if分支。上一篇我们提到，reflection的生成是把所有runtime和editor的include喂给llvmclang，生成AST，而在喂给clang时，我们的MetaParser通过成员变量arguments传递了一部分参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;                    arguments = &#123;&#123;<span class="hljs-string">&quot;-x&quot;</span>,<br>                                       <span class="hljs-string">&quot;c++&quot;</span>,<br>                                       <span class="hljs-string">&quot;-std=c++11&quot;</span>,<br>                                       <span class="hljs-string">&quot;-D__REFLECTION_PARSER__&quot;</span>,<br>                                       <span class="hljs-string">&quot;-DNDEBUG&quot;</span>,<br>                                       <span class="hljs-string">&quot;-D__clang__&quot;</span>,<br>                                       <span class="hljs-string">&quot;-w&quot;</span>,<br>                                       <span class="hljs-string">&quot;-MG&quot;</span>,<br>                                       <span class="hljs-string">&quot;-M&quot;</span>,<br>                                       <span class="hljs-string">&quot;-ferror-limit=0&quot;</span>,<br>                                       <span class="hljs-string">&quot;-o clangLog.txt&quot;</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，<code>-D__REFLECTION_PARSER__</code>就定义了这个宏。那么#else这个分支是用来干嘛的呢，以我的理解来看，这是为了使得我们的IDE不报错而采用的一种trick，因为annotate是一个clang-specific的语法，通过添加一个宏的前提，使得IDE在解析时直接走了#else分支，避开了非所有编译器支持的特性。这也是为什么在#else分支里CLASS和META的宏展开非常简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS(class_name, ...) class class_name</span><br><span class="hljs-built_in">CLASS</span>(AnimationComponent : <span class="hljs-keyword">public</span> Component, WhiteListFields)<br><span class="hljs-comment">// 展开后就是</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimationComponent</span> : <span class="hljs-keyword">public</span> Component<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> META(...)</span><br><span class="hljs-built_in">META</span>(Enable)<br><span class="hljs-comment">// 展开后就是</span><br><br></code></pre></td></tr></table></figure><p>现在让我们回到正经生成AST时会走的#if分支。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> META(...) __attribute__((annotate(#__VA_ARGS__)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS(class_name, ...) class __attribute__((annotate(#__VA_ARGS__))) class_name</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRUCT(struct_name, ...) struct __attribute__((annotate(#__VA_ARGS__))) struct_name</span><br></code></pre></td></tr></table></figure><p><code>__attribute__((annotate()))</code>会添加一个annotation，而annotations是可以在clang生成AST后进行访问的，于是我们的generator就可以根据这个annotation判断需要做什么，#表示转化成字符串，展开后如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//CLASS(AnimationComponent : public Component, WhiteListFields)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">__attribute__</span>((<span class="hljs-built_in">annotate</span>(<span class="hljs-string">&quot;WhiteListFields&quot;</span>))) AnimationComponent : <span class="hljs-keyword">public</span> Component<br><span class="hljs-comment">// META(Enable)</span><br>__attribute__((<span class="hljs-built_in">annotate</span>(<span class="hljs-string">&quot;Enable&quot;</span>)))<br></code></pre></td></tr></table></figure><p>接下来我们具体看看这个annotation是怎么被使用的，我们首先找到程序解析clang生成的AST的地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\meta_parser\parser\parser\parser.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MetaParser::buildClassAST</span><span class="hljs-params">(<span class="hljs-type">const</span> Cursor&amp; cursor, Namespace&amp; current_namespace)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : cursor.<span class="hljs-built_in">getChildren</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> kind = child.<span class="hljs-built_in">getKind</span>();<br><br>        <span class="hljs-comment">// actual definition and a class or struct</span><br>        <span class="hljs-keyword">if</span> (child.<span class="hljs-built_in">isDefinition</span>() &amp;&amp; (kind == CXCursor_ClassDecl || kind == CXCursor_StructDecl))<br>        &#123;<br>            <span class="hljs-keyword">auto</span> class_ptr = std::<span class="hljs-built_in">make_shared</span>&lt;Class&gt;(child, current_namespace);<br><br>            <span class="hljs-built_in">TRY_ADD_LANGUAGE_TYPE</span>(class_ptr, classes);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">RECURSE_NAMESPACES</span>(kind, child, buildClassAST, current_namespace);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里生成了一个Class类的对象。Class类的构造函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">Class::<span class="hljs-built_in">Class</span>(<span class="hljs-type">const</span> Cursor&amp; cursor, <span class="hljs-type">const</span> Namespace&amp; current_namespace) :<br>    <span class="hljs-built_in">TypeInfo</span>(cursor, current_namespace), <span class="hljs-built_in">m_name</span>(cursor.<span class="hljs-built_in">getDisplayName</span>()),<br>    <span class="hljs-built_in">m_qualified_name</span>(Utils::<span class="hljs-built_in">getTypeNameWithoutNamespace</span>(cursor.<span class="hljs-built_in">getType</span>())),<br>    <span class="hljs-built_in">m_display_name</span>(Utils::<span class="hljs-built_in">getNameWithoutFirstM</span>(m_qualified_name))<br>&#123;<br>    Utils::<span class="hljs-built_in">replaceAll</span>(m_name, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    Utils::<span class="hljs-built_in">replaceAll</span>(m_name, <span class="hljs-string">&quot;Piccolo::&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : cursor.<span class="hljs-built_in">getChildren</span>())<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (child.<span class="hljs-built_in">getKind</span>())<br>        &#123;<br>            <span class="hljs-keyword">case</span> CXCursor_CXXBaseSpecifier: &#123;<br>                <span class="hljs-keyword">auto</span> base_class = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BaseClass</span>(child);<br><br>                m_base_classes.<span class="hljs-built_in">emplace_back</span>(base_class);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// field</span><br>            <span class="hljs-keyword">case</span> CXCursor_FieldDecl:<br>                m_fields.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Field</span>(child, current_namespace, <span class="hljs-keyword">this</span>));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没直接看到annotation相关的内容，很可能是在成员变量或父类的初始化中，很自然地，我们就能锁定TypeInfo。看一下代码，里面确实是有我们关注的Enable这个annotation。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\meta_parser\parser\language_types\type_info.cpp</span><br>TypeInfo::<span class="hljs-built_in">TypeInfo</span>(<span class="hljs-type">const</span> Cursor&amp; cursor, <span class="hljs-type">const</span> Namespace&amp; current_namespace) :<br>    <span class="hljs-built_in">m_meta_data</span>(cursor), <span class="hljs-built_in">m_enabled</span>(m_meta_data.<span class="hljs-built_in">getFlag</span>(NativeProperty::Enable)), <span class="hljs-built_in">m_root_cursor</span>(cursor),<br>    <span class="hljs-built_in">m_namespace</span>(current_namespace)<br>&#123;&#125;<br></code></pre></td></tr></table></figure><p>那么现在的关键就是m_meta_data，也就是MetaInfo类。它在初始化时，读取了所有含annotate的child，将它们的属性保存起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\meta_parser\parser\meta\meta_info.cpp</span><br>MetaInfo::<span class="hljs-built_in">MetaInfo</span>(<span class="hljs-type">const</span> Cursor&amp; cursor)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : cursor.<span class="hljs-built_in">getChildren</span>())<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (child.<span class="hljs-built_in">getKind</span>() != CXCursor_AnnotateAttr)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; prop : <span class="hljs-built_in">extractProperties</span>(child))<br>            m_properties[prop.first] = prop.second;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">std::vector&lt;MetaInfo::Property&gt; <span class="hljs-title">MetaInfo::extractProperties</span><span class="hljs-params">(<span class="hljs-type">const</span> Cursor&amp; cursor)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;Property&gt; ret_list;<br><br>    <span class="hljs-keyword">auto</span> propertyList = cursor.<span class="hljs-built_in">getDisplayName</span>();<br><br>    <span class="hljs-keyword">auto</span>&amp;&amp; properties = Utils::<span class="hljs-built_in">split</span>(propertyList, <span class="hljs-string">&quot;,&quot;</span>);<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string white_space_string = <span class="hljs-string">&quot; \t\r\n&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; property_item : properties)<br>    &#123;<br>        <span class="hljs-keyword">auto</span>&amp;&amp; item_details = Utils::<span class="hljs-built_in">split</span>(property_item, <span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-keyword">auto</span>&amp;&amp; temp_string  = Utils::<span class="hljs-built_in">trim</span>(item_details[<span class="hljs-number">0</span>], white_space_string);<br>        <span class="hljs-keyword">if</span> (temp_string.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        ret_list.<span class="hljs-built_in">emplace_back</span>(temp_string,<br>                              item_details.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> ? Utils::<span class="hljs-built_in">trim</span>(item_details[<span class="hljs-number">1</span>], white_space_string) : <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret_list;<br>&#125;<br></code></pre></td></tr></table></figure><p>捋一下思路，现在我们会把所有annotation放入m_properties字典中（注意是annotation而不是annotation对应的field，<code>prop.first</code>是Enable之类的内容），但是这并没有将field和annotation关联起来。</p><p>那generator是怎么根据<code>Meta(Enable)</code>来生成的呢？</p><p>先看看<code>reflection_generator</code>的generate函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\meta_parser\parser\generator\reflection_generator.cpp</span><br>std::string render_string =<br>    TemplateManager::<span class="hljs-built_in">getInstance</span>()-&gt;<span class="hljs-built_in">renderByTemplate</span>(<span class="hljs-string">&quot;commonReflectionFile&quot;</span>, mustache_data);<br>Utils::<span class="hljs-built_in">saveFile</span>(render_string, file_path);<br></code></pre></td></tr></table></figure><p>可以看到它通过模板生成了一个反射文件。搜一下<code>commonReflectionFile</code>，可以找到<code>engine\template\commonReflectionFile.mustache</code>，这个文件就是最终生成的反射文件的模板，它里面使用到了<code>&#123;&#123;#class_field_defines&#125;&#125;</code>，我们可以在代码里找一下哪里设置了<code>class_field_defines</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\meta_parser\parser\generator\generator.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GeneratorInterface::genClassFieldRenderData</span><span class="hljs-params">(std::shared_ptr&lt;Class&gt; class_temp, Mustache::data&amp; feild_defs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string vector_prefix = <span class="hljs-string">&quot;std::vector&lt;&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; field : class_temp-&gt;m_fields)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!field-&gt;<span class="hljs-built_in">shouldCompile</span>())<br>            <span class="hljs-keyword">continue</span>;<br>        Mustache::data filed_define;<br><br>        filed_define.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;class_field_name&quot;</span>, field-&gt;m_name);<br>        filed_define.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;class_field_type&quot;</span>, field-&gt;m_type);<br>        filed_define.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;class_field_display_name&quot;</span>, field-&gt;m_display_name);<br>        <span class="hljs-type">bool</span> is_vector = field-&gt;m_type.<span class="hljs-built_in">find</span>(vector_prefix) == <span class="hljs-number">0</span>;<br>        filed_define.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;class_field_is_vector&quot;</span>, is_vector);<br>        feild_defs.<span class="hljs-built_in">push_back</span>(filed_define);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实很简单，就是直接读的Class的变量<code>m_fields</code>。<code>m_fields</code>是在Class初始化的时候赋值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\meta_parser\parser\language_types\class.cpp</span><br>Class::<span class="hljs-built_in">Class</span>(<span class="hljs-type">const</span> Cursor&amp; cursor, <span class="hljs-type">const</span> Namespace&amp; current_namespace) :<br>    <span class="hljs-built_in">TypeInfo</span>(cursor, current_namespace), <span class="hljs-built_in">m_name</span>(cursor.<span class="hljs-built_in">getDisplayName</span>()),<br>    <span class="hljs-built_in">m_qualified_name</span>(Utils::<span class="hljs-built_in">getTypeNameWithoutNamespace</span>(cursor.<span class="hljs-built_in">getType</span>())),<br>    <span class="hljs-built_in">m_display_name</span>(Utils::<span class="hljs-built_in">getNameWithoutFirstM</span>(m_qualified_name))<br>&#123;<br>    Utils::<span class="hljs-built_in">replaceAll</span>(m_name, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    Utils::<span class="hljs-built_in">replaceAll</span>(m_name, <span class="hljs-string">&quot;Piccolo::&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; child : cursor.<span class="hljs-built_in">getChildren</span>())<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (child.<span class="hljs-built_in">getKind</span>())<br>        &#123;<br>            <span class="hljs-keyword">case</span> CXCursor_CXXBaseSpecifier: &#123;<br>                <span class="hljs-keyword">auto</span> base_class = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BaseClass</span>(child);<br><br>                m_base_classes.<span class="hljs-built_in">emplace_back</span>(base_class);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// field</span><br>            <span class="hljs-keyword">case</span> CXCursor_FieldDecl:<br>                m_fields.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Field</span>(child, current_namespace, <span class="hljs-keyword">this</span>));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看一眼Field类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\meta_parser\parser\language_types\field.cpp</span><br>Field::<span class="hljs-built_in">Field</span>(<span class="hljs-type">const</span> Cursor&amp; cursor, <span class="hljs-type">const</span> Namespace&amp; current_namespace, Class* parent) :<br>    <span class="hljs-built_in">TypeInfo</span>(cursor, current_namespace), <span class="hljs-built_in">m_is_const</span>(cursor.<span class="hljs-built_in">getType</span>().<span class="hljs-built_in">IsConst</span>()), <span class="hljs-built_in">m_parent</span>(parent),<br>    <span class="hljs-built_in">m_name</span>(cursor.<span class="hljs-built_in">getSpelling</span>()), <span class="hljs-built_in">m_display_name</span>(Utils::<span class="hljs-built_in">getNameWithoutFirstM</span>(m_name)),<br>    <span class="hljs-built_in">m_type</span>(Utils::<span class="hljs-built_in">getTypeNameWithoutNamespace</span>(cursor.<span class="hljs-built_in">getType</span>()))<br>&#123;<br>    Utils::<span class="hljs-built_in">replaceAll</span>(m_type, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    Utils::<span class="hljs-built_in">replaceAll</span>(m_type, <span class="hljs-string">&quot;Piccolo::&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>    <span class="hljs-keyword">auto</span> ret_string = Utils::<span class="hljs-built_in">getStringWithoutQuot</span>(m_meta_data.<span class="hljs-built_in">getProperty</span>(<span class="hljs-string">&quot;default&quot;</span>));<br>    m_default       = ret_string;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Field::shouldCompile</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">isAccessible</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Field::isAccessible</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((m_parent-&gt;m_meta_data.<span class="hljs-built_in">getFlag</span>(NativeProperty::Fields) ||<br>             m_parent-&gt;m_meta_data.<span class="hljs-built_in">getFlag</span>(NativeProperty::All)) &amp;&amp;<br>            !m_meta_data.<span class="hljs-built_in">getFlag</span>(NativeProperty::Disable)) ||<br>           (m_parent-&gt;m_meta_data.<span class="hljs-built_in">getFlag</span>(NativeProperty::WhiteListFields) &amp;&amp;<br>            m_meta_data.<span class="hljs-built_in">getFlag</span>(NativeProperty::Enable));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就可以看出端倪了。<code>Field</code>和<code>Class</code>一样都继承自<code>TypeInfo</code>，<code>TypeInfo</code>又继承自<code>MetaInfo</code>，所以<code>Field</code>里其实包含了<code>m_properties</code>，对于一个<code>Field</code>，它只需要查看它的<code>m_properties</code>就可以知道自身是否有对应的annotation，于是就可以知道它相应的访问权限了。</p><hr /><p>现在我们已经知道了如何使用annotation来控制field的访问权限，我们最后还需要解决的问题就是这个模板文件的结构。</p><p><code>class Type&#123;&#123;class_name&#125;&#125;Operator</code>和<code>class Array&#123;&#123;vector_useful_name&#125;&#125;Operator</code>是为我们要实现的类的反射提供访问接口的工具类，它的方法都是静态的。但是很明显，现在每一个反射类都对应一个或两个（非vector的话则不会有<code>class Array&#123;&#123;vector_useful_name&#125;&#125;Operator</code>）工具类，但我们最终想要实现的其实是一个统一的接口，即给定一个类名，就能得到它的一系列函数。所以还需要进一步处理。</p><p><code>TypeWrapperRegister_&#123;&#123;class_name&#125;&#125;</code>这个函数就是将这一系列反射函数组合起来，然后加入到反射的字典当中。</p><p>这里以Animation_Clip里的AnimNodeMap为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TypeWrapperRegister_AnimNodeMap</span><span class="hljs-params">()</span></span>&#123;<br>        FieldFunctionTuple* f_field_function_tuple_convert=<span class="hljs-keyword">new</span> <span class="hljs-built_in">FieldFunctionTuple</span>(<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::set_convert,<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::get_convert,<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getClassName,<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getFieldName_convert,<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getFieldTypeName_convert,<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::isArray_convert);<br>        <span class="hljs-built_in">REGISTER_FIELD_TO_MAP</span>(<span class="hljs-string">&quot;AnimNodeMap&quot;</span>, f_field_function_tuple_convert);<br>        <br>        ArrayFunctionTuple* f_array_tuple_stdSSvectorLstdSSstringR = <span class="hljs-keyword">new</span>  <span class="hljs-built_in">ArrayFunctionTuple</span>(<br>            &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::set,<br>            &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::get,<br>            &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getSize,<br>            &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getArrayTypeName,<br>            &amp;ArrayReflectionOperator::ArraystdSSvectorLstdSSstringROperator::getElementTypeName);<br>        <span class="hljs-built_in">REGISTER_ARRAY_TO_MAP</span>(<span class="hljs-string">&quot;std::vector&lt;std::string&gt;&quot;</span>, f_array_tuple_stdSSvectorLstdSSstringR);<br>        ClassFunctionTuple* f_class_function_tuple_AnimNodeMap=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassFunctionTuple</span>(<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::getAnimNodeMapBaseClassReflectionInstanceList,<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::constructorWithJson,<br>            &amp;TypeFieldReflectionOparator::TypeAnimNodeMapOperator::writeByName);<br>        <span class="hljs-built_in">REGISTER_BASE_CLASS_TO_MAP</span>(<span class="hljs-string">&quot;AnimNodeMap&quot;</span>, f_class_function_tuple_AnimNodeMap);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面涉及到的一些类型及宏的定义如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\runtime\core\meta\reflection\reflection.h</span><br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">void</span>*, <span class="hljs-type">void</span>*)&gt;      SetFuncion;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>*(<span class="hljs-type">void</span>*)&gt;            GetFuncion;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*()&gt;           GetNameFuncion;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">void</span>*, <span class="hljs-type">void</span>*)&gt; SetArrayFunc;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>*(<span class="hljs-type">int</span>, <span class="hljs-type">void</span>*)&gt;       GetArrayFunc;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">void</span>*)&gt;              GetSizeFunc;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">bool</span>()&gt;                  GetBoolFunc;<br><br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span>*(<span class="hljs-type">const</span> PJson&amp;)&gt;     ConstructorWithPJson;<br><span class="hljs-keyword">typedef</span> std::function&lt;PJson(<span class="hljs-type">void</span>*)&gt;            WritePJsonByName;<br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">int</span>(Reflection::ReflectionInstance*&amp;, <span class="hljs-type">void</span>*)&gt; GetBaseClassReflectionInstanceListFunc;<br><br><span class="hljs-keyword">typedef</span> std::tuple&lt;SetFuncion, GetFuncion, GetNameFuncion, GetNameFuncion, GetNameFuncion, GetBoolFunc&gt; FieldFunctionTuple;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\runtime\core\meta\reflection\reflection.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REGISTER_FIELD_TO_MAP(name, value) TypeMetaRegisterinterface::registerToFieldMap(name, value);</span><br></code></pre></td></tr></table></figure><p>通过实例化一个包含一系列函数指针的tuple，再将tuple放入字典中，就完成了我们上述的目的。而这个字典呢，再进一步跟踪就可以发现是reflection.cpp中的静态全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\runtime\core\meta\reflection\reflection.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeMetaRegisterinterface</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">registerToClassMap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, ClassFunctionTuple* value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">registerToFieldMap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, FieldFunctionTuple* value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">registerToArrayMap</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, ArrayFunctionTuple* value)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">unregisterAll</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\runtime\core\meta\reflection\reflection.cpp</span><br><span class="hljs-keyword">namespace</span> Piccolo<br>&#123;<br>    <span class="hljs-keyword">namespace</span> Reflection<br>    &#123;<br><span class="hljs-type">static</span> std::map&lt;std::string, ClassFunctionTuple*&gt;      m_class_map;<br>        <span class="hljs-type">static</span> std::multimap&lt;std::string, FieldFunctionTuple*&gt; m_field_map;<br>        <span class="hljs-type">static</span> std::map&lt;std::string, ArrayFunctionTuple*&gt;      m_array_map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Piccolo的反射机制就算清楚了。接下来是最后的收尾工作，<code>TypeWrapperRegister_AnimNodeMap</code>是什么时候被调用的呢？在文件最后，类的注册函数又被重命名为了类名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\_generated\reflection\animation_clip.reflection.gen.h</span><br><span class="hljs-keyword">namespace</span> TypeWrappersRegister&#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AnimNodeMap</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">TypeWrapperRegister_AnimNodeMap</span>();&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AnimationChannel</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">TypeWrapperRegister_AnimationChannel</span>();&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AnimationClip</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">TypeWrapperRegister_AnimationClip</span>();&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AnimationAsset</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">TypeWrapperRegister_AnimationAsset</span>();&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在all_reflection里将所有反射类的注册函数组合成了一个函数Register。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\_generated\reflection\all_reflection.h</span><br><span class="hljs-keyword">namespace</span> Piccolo&#123;<br><span class="hljs-keyword">namespace</span> Reflection&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TypeMetaRegister::Register</span><span class="hljs-params">()</span></span>&#123;<br>    ...<br>    TypeWrappersRegister::<span class="hljs-built_in">AnimationComponent</span>();<br>    ...<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个Register函数会在引擎启动的时候被调用，完成反射的初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine\source\runtime\engine.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PiccoloEngine::startEngine</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; config_file_path)</span></span><br><span class="hljs-function"></span>&#123;<br>    Reflection::TypeMetaRegister::<span class="hljs-built_in">Register</span>();<br><br>    g_runtime_global_context.<span class="hljs-built_in">startSystems</span>(config_file_path);<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;engine start&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>反射系统完结撒花~</p><p>序列化系统和反射系统的思路基本一致，就是模板不太一样。因为序列化只需要把所有的类的读写统一放在一个静态类PSerializer中，特化读写模板函数即可，就不需要和Reflection一样在启动时初始化，所以Serializer反而会简单许多。</p><blockquote><p>8月11写的前一半文章，然后就忙保研考研去了，没想到再一次写就已经是9.24了。因为是边看代码边写的文章，所以可能有些地方读起来有些割裂，希望不会影响到阅读和理解</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码阅读</tag>
      
      <tag>Piccolo</tag>
      
      <tag>游戏引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Piccolo源码解读（一）——项目结构</title>
    <link href="/posts/2317033436/"/>
    <url>/posts/2317033436/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章基于的Piccolo版本的commit号为214542257eeda28b09495fe38910d42fa2ba48b4，为本人学习所用，所以可能存在不准确的地方，欢迎联系修改</p></blockquote><span id="more"></span><p>项目的构建官方给出的视频已经有所介绍，这里就不再赘述了，需要注意的是windows系统建议使用MSVC，最好不要尝试使用MinGW的gcc或clang，因为依赖的第三方库JoltPhysics的代码里会根据你是windows而假定你使用MSVC，光是修改Jolt的CMakeLists似乎不太能使它正确通过编译。</p><p>Piccolo的编译运行主要分为以下几个部分</p><ol type="1"><li>生成PiccoloParser</li><li>使用PiccoloParser读取项目源代码文件，在build目录下生成所有被include的头文件parser_header.h，并基于此生成反射所需的头文件，生成的文件在engine/source/_generated目录下，这部分被称为Precompile</li><li>根据生成好的反射头文件和项目源文件，生成可执行引擎程序</li></ol><p>这里我们直接看engine目录下的CMakeLists.txt，前面都是些准备工作，关键是最后这段。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(shader)<br><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-number">3</span>rdparty)<br><br><span class="hljs-keyword">add_subdirectory</span>(source/runtime)<br><span class="hljs-keyword">add_subdirectory</span>(source/editor)<br><span class="hljs-keyword">add_subdirectory</span>(source/meta_parser)<br><span class="hljs-comment">#add_subdirectory(source/test)</span><br><br><span class="hljs-keyword">set</span>(CODEGEN_TARGET <span class="hljs-string">&quot;PiccoloPreCompile&quot;</span>)<br><span class="hljs-keyword">include</span>(source/precompile/precompile.cmake)<br><span class="hljs-keyword">set_target_properties</span>(<span class="hljs-string">&quot;$&#123;CODEGEN_TARGET&#125;&quot;</span> PROPERTIES FOLDER <span class="hljs-string">&quot;Engine&quot;</span> )<br><br><span class="hljs-keyword">add_dependencies</span>(PiccoloRuntime <span class="hljs-string">&quot;$&#123;CODEGEN_TARGET&#125;&quot;</span>)<br><span class="hljs-keyword">add_dependencies</span>(<span class="hljs-string">&quot;$&#123;CODEGEN_TARGET&#125;&quot;</span> <span class="hljs-string">&quot;PiccoloParser&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里通过<code>add_subdirectory</code>和<code>include</code>，添加了各个target，包括我们前面提到的precompile，PiccoloRuntime以及PiccoloParser。通过add_dependencies，cmake定义了各个target之间的依赖关系，从而决定了执行顺序，PiccoloParser&gt; CODEGEN_TARGET &gt; PiccoloRuntime。</p><p>这里我们再稍微看一眼precompile.cmake，可以看到它最后一部分代码如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Called first time when building target </span><br><span class="hljs-keyword">add_custom_target</span>(<span class="hljs-variable">$&#123;PRECOMPILE_TARGET&#125;</span> ALL<br><br><span class="hljs-comment"># COMMAND # (DE<span class="hljs-doctag">BUG:</span> DON&#x27;T USE )</span><br><span class="hljs-comment">#     this will make configure_file() is called on each compile</span><br><span class="hljs-comment">#   $&#123;CMAKE_COMMAND&#125; -E touch $&#123;PRECOMPILE_PARAM_IN_PATH&#125;a</span><br><br><span class="hljs-comment"># If more than one COMMAND is specified they will be executed in order...</span><br><span class="hljs-keyword">COMMAND</span><br>  <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="hljs-string">&quot;************************************************************* &quot;</span><br><span class="hljs-keyword">COMMAND</span><br>  <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="hljs-string">&quot;**** [Precompile] BEGIN &quot;</span><br><span class="hljs-keyword">COMMAND</span><br>  <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="hljs-string">&quot;************************************************************* &quot;</span><br><br><span class="hljs-keyword">COMMAND</span><br>    <span class="hljs-variable">$&#123;PRECOMPILE_PARSER&#125;</span> <span class="hljs-string">&quot;$&#123;PICCOLO_PRECOMPILE_PARAMS_PATH&#125;&quot;</span>  <span class="hljs-string">&quot;$&#123;PARSER_INPUT&#125;&quot;</span>  <span class="hljs-string">&quot;$&#123;ENGINE_ROOT_DIR&#125;/source&quot;</span> <span class="hljs-variable">$&#123;sys_include&#125;</span> <span class="hljs-string">&quot;Piccolo&quot;</span> <span class="hljs-number">0</span><br><span class="hljs-comment">### BUILDING ====================================================================================</span><br><span class="hljs-keyword">COMMAND</span><br>    <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E echo <span class="hljs-string">&quot;+++ Precompile finished +++&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>通过这个custom_target的<code>COMMAND $&#123;PRECOMPILE_PARSER&#125; "$&#123;PICCOLO_PRECOMPILE_PARAMS_PATH&#125;"  "$&#123;PARSER_INPUT&#125;"  "$&#123;ENGINE_ROOT_DIR&#125;/source" $&#123;sys_include&#125; "Piccolo" 0</code>，它使用在它之前生成的PiccoloParser.exe对项目include进行解析，其中<code>"$&#123;PARSER_INPUT&#125;"</code>就是前面提到的parser_header.h，虽然这个变量名有点怪，看上去是输入，但实际上是precompile的输出。这里我们先看一眼parser_header.h的大致结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __PARSER_HEADER_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PARSER_HEADER_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&quot;D:/CppProj/Piccolo/engine/source/runtime/core/base/hash.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&quot;D:/CppProj/Piccolo/engine/source/runtime/core/base/macro.h&quot;</span></span><br><span class="hljs-string">&quot;</span><br><span class="hljs-string">#endif</span><br></code></pre></td></tr></table></figure><p>那么PiccoloParser是怎么工作的呢？跟一下代码，可以看到它的主要功能函数在engine/source/meta_parser/parser/parser.cpp，这个parser里的函数的参数名命名也感觉有点怪，不过不影响我们理解代码。下面代码的<code>m_source_include_file_name</code>就是parser_header.h。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">include_file.<span class="hljs-built_in">open</span>(m_source_include_file_name, std::ios::out);<br><span class="hljs-keyword">if</span> (!include_file.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Could not open the Source Include file: &quot;</span> &lt;&lt; m_source_include_file_name &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Generating the Source Include file: &quot;</span> &lt;&lt; m_source_include_file_name &lt;&lt; std::endl;<br><br>std::string output_filename = Utils::<span class="hljs-built_in">getFileName</span>(m_source_include_file_name);<br><br><span class="hljs-keyword">if</span> (output_filename.<span class="hljs-built_in">empty</span>())<br>&#123;<br>    output_filename = <span class="hljs-string">&quot;META_INPUT_HEADER_H&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Utils::<span class="hljs-built_in">replace</span>(output_filename, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>);<br>    Utils::<span class="hljs-built_in">replace</span>(output_filename, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;_&quot;</span>);<br>    Utils::<span class="hljs-built_in">toUpper</span>(output_filename);<br>&#125;<br>include_file &lt;&lt; <span class="hljs-string">&quot;#ifndef __&quot;</span> &lt;&lt; output_filename &lt;&lt; <span class="hljs-string">&quot;__&quot;</span> &lt;&lt; std::endl;<br>include_file &lt;&lt; <span class="hljs-string">&quot;#define __&quot;</span> &lt;&lt; output_filename &lt;&lt; <span class="hljs-string">&quot;__&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> include_item : inlcude_files)<br>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">temp_string</span><span class="hljs-params">(include_item)</span></span>;<br>    Utils::<span class="hljs-built_in">replace</span>(temp_string, <span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>    include_file &lt;&lt; <span class="hljs-string">&quot;#include  \&quot;&quot;</span> &lt;&lt; temp_string &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br>include_file &lt;&lt; <span class="hljs-string">&quot;#endif&quot;</span> &lt;&lt; std::endl;<br>include_file.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><p>代码还是非常直观的，可以看出我们的分析没有错，就是生成parser_header.h，其中include_files就是类似这样的字符串</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">D:<span class="hljs-regexp">/CppProj/</span>Piccolo<span class="hljs-regexp">/engine/</span><span class="hljs-keyword">source</span><span class="hljs-regexp">/runtime/</span>core<span class="hljs-regexp">/base/</span>hash.h;D:<span class="hljs-regexp">/CppProj/</span>Piccolo<span class="hljs-regexp">/engine/</span><span class="hljs-keyword">source</span><span class="hljs-regexp">/runtime/</span>core<span class="hljs-regexp">/base/m</span>acro.h;D:<span class="hljs-regexp">/CppProj/</span>Piccolo<span class="hljs-regexp">/engine/</span><span class="hljs-keyword">source</span><span class="hljs-regexp">/runtime/</span>core<span class="hljs-regexp">/color/</span>color.h;D:<span class="hljs-regexp">/CppProj/</span>Piccolo<span class="hljs-regexp">/engine/</span><span class="hljs-keyword">source</span><span class="hljs-regexp">/runtime/</span>core<span class="hljs-regexp">/log/</span>log_system.h;<br></code></pre></td></tr></table></figure><p>这个字符串读自engine/bin/precompile.json，那么这个文件是怎么生成的呢？</p><p>在precompile.cmake开头我们可以看到这样的代码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(PRECOMPILE_TOOLS_PATH <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/bin&quot;</span>)<br><span class="hljs-keyword">set</span>(PICCOLO_PRECOMPILE_PARAMS_IN_PATH <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/source/precompile/precompile.json.in&quot;</span>)<br><span class="hljs-keyword">set</span>(PICCOLO_PRECOMPILE_PARAMS_PATH <span class="hljs-string">&quot;$&#123;PRECOMPILE_TOOLS_PATH&#125;/precompile.json&quot;</span>)<br><span class="hljs-keyword">configure_file</span>(<span class="hljs-variable">$&#123;PICCOLO_PRECOMPILE_PARAMS_IN_PATH&#125;</span> <span class="hljs-variable">$&#123;PICCOLO_PRECOMPILE_PARAMS_PATH&#125;</span>)<br></code></pre></td></tr></table></figure><p>其实就是configure_file这个函数将<code>$&#123;PICCOLO_PRECOMPILE_PARAMS_IN_PATH&#125;</code>里的变量展开，放到了<code>$&#123;PICCOLO_PRECOMPILE_PARAMS_PATH&#125;</code>里。<code>$&#123;PICCOLO_PRECOMPILE_PARAMS_IN_PATH&#125;</code>就是precompile.cmake同目录下的precompile.json.in，它的内容很简单，就是<code>@PICCOLO_RUNTIME_HEADS@,@PICCOLO_EDITOR_HEADS@</code></p><p>这两个变量分别在engine/source/runtime/CMakeLists.txt和engine/source/editor/CMakeLists.txt中被设置，并设置到了PARENT_SCOPE，所以只有这两个文件夹下的include文件会作为parser_header.h的内容。回到开头的engine目录下的CMakeLists.txt，</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(source/runtime)<br><span class="hljs-keyword">add_subdirectory</span>(source/editor)<br><span class="hljs-keyword">add_subdirectory</span>(source/meta_parser)<br><span class="hljs-comment">#add_subdirectory(source/test)</span><br><br><span class="hljs-keyword">set</span>(CODEGEN_TARGET <span class="hljs-string">&quot;PiccoloPreCompile&quot;</span>)<br><span class="hljs-keyword">include</span>(source/precompile/precompile.cmake)<br></code></pre></td></tr></table></figure><p>这也就是为什么先添加runtime和editor为subdirectory，再includeprecompile的原因——为了让它们先设置好这些变量。</p><p>那么下一个问题，反射文件是什么时候生成的。实际上这点非常简单，source/meta_parser/main.cpp中的<code>parser.generateFiles();</code>就是生成反射文件。在<code>MetaParser</code>初始化的时候，它初始化了<code>ReflectionGenerator</code>和<code>SerializerGenerator</code>，并在<code>generateFiles</code>中遍历它们并generate。</p><p>最后，我们来看一下parser_header.h到底是用来做什么的。在parse完整个project后，也就是生成parser_header.h后，<code>MetaParser</code>还做了一些事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// engine/meta_parser/parser/parser/parser.cpp第175行</span><br>m_translation_unit = <span class="hljs-built_in">clang_createTranslationUnitFromSourceFile</span>(<br>    m_index, m_source_include_file_name.<span class="hljs-built_in">c_str</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(arguments.<span class="hljs-built_in">size</span>()), arguments.<span class="hljs-built_in">data</span>(), <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// m_source_include_file_name就是parser_header.h</span><br><span class="hljs-keyword">auto</span> cursor = <span class="hljs-built_in">clang_getTranslationUnitCursor</span>(m_translation_unit);<br><br>Namespace temp_namespace;<br><br><span class="hljs-built_in">buildClassAST</span>(cursor, temp_namespace);<br><br>temp_namespace.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure><p>它将这个文件传递给llvm的clang工具得到抽象语法树，之后遍历抽象语法树，通过<code>TRY_ADD_LANGUAGE_TYPE</code>维护两张表<code>m_schema_modules</code>和<code>m_type_table</code>，这两张表会在生成反射文件的函数<code>generateFiles</code>被用到，其中<code>m_schema_modules</code>中的内容会直接通过参数的形式传递给generate，而<code>m_type_table</code>的访问则是通过将私有的访问函数bind给generator实现（不了解bind和placeholder的话可以在<ahref="/2023/02/25/chang-pian-bi-ji/c/modern-cpp-tutorial-note/">这篇文章</a>搜索std::placeholder）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">MetaParser::getIncludeFile</span><span class="hljs-params">(std::string name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> iter = m_type_table.<span class="hljs-built_in">find</span>(name);<br>    <span class="hljs-keyword">return</span> iter == m_type_table.<span class="hljs-built_in">end</span>() ? std::<span class="hljs-built_in">string</span>() : iter-&gt;second;<br>&#125;<br><br>MetaParser::<span class="hljs-built_in">MetaParser</span>(<span class="hljs-type">const</span> std::string project_input_file,<br>                       <span class="hljs-type">const</span> std::string include_file_path,<br>                       <span class="hljs-type">const</span> std::string include_path,<br>                       <span class="hljs-type">const</span> std::string sys_include,<br>                       <span class="hljs-type">const</span> std::string module_name,<br>                       <span class="hljs-type">bool</span>              is_show_errors) :<br>    <span class="hljs-built_in">m_project_input_file</span>(project_input_file),<br>    <span class="hljs-built_in">m_source_include_file_name</span>(include_file_path), <span class="hljs-built_in">m_index</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">m_translation_unit</span>(<span class="hljs-literal">nullptr</span>),<br>    <span class="hljs-built_in">m_sys_include</span>(sys_include), <span class="hljs-built_in">m_module_name</span>(module_name), <span class="hljs-built_in">m_is_show_errors</span>(is_show_errors)<br>&#123;<br>    m_work_paths = Utils::<span class="hljs-built_in">split</span>(include_path, <span class="hljs-string">&quot;;&quot;</span>);<br><br>    m_generators.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> Generator::<span class="hljs-built_in">SerializerGenerator</span>(<br>        m_work_paths[<span class="hljs-number">0</span>], std::<span class="hljs-built_in">bind</span>(&amp;MetaParser::getIncludeFile, <span class="hljs-keyword">this</span>, std::placeholders::_1)));<br>    m_generators.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> Generator::<span class="hljs-built_in">ReflectionGenerator</span>(<br>        m_work_paths[<span class="hljs-number">0</span>], std::<span class="hljs-built_in">bind</span>(&amp;MetaParser::getIncludeFile, <span class="hljs-keyword">this</span>, std::placeholders::_1)));<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们就对整个项目的框架有了一定的认识，下一篇如果不出意外的话，我将会侧重解读反射系统的实现。</p>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码阅读</tag>
      
      <tag>Piccolo</tag>
      
      <tag>游戏引擎</tag>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UE中如何优雅地在GUI界面禁用游戏输入</title>
    <link href="/posts/3822428522/"/>
    <url>/posts/3822428522/</url>
    
    <content type="html"><![CDATA[<p>最近软工的大程需要在UE中制作GUI，我之前并没有使用过，所以基本上都是现查现用，但在搜索过程中发现网上并没有GUI打开期间禁用游戏输入的比较优雅的方案（也可能是我没找到），最后在实践中发现一种比较好的解决方案。</p><span id="more"></span><p>首先明确一下我想实现的最终效果，即游戏最终有多个GUI菜单，按下不同按钮打开不同的菜单，但是按下任意控制菜单的按键都能够关闭当前菜单，打开菜单后，用户将不能继续控制人物移动等，但游戏仍继续运行（即不停止游戏时间）。</p><p>在这里我首先是在Edit-Project Settings-Engine-Input-Bindings-ActionMappings里添加对应的按钮映射。</p><p>一种非常直接的想法是按下按钮打开GUI，之后Set Input Mode UIOnly，但是UI Only模式下按钮映射将不起作用。</p><p>另一种方案是UE里UMG支持StopAction，直接在Designer里选中该蓝图勾选StopAction就能实现禁用游戏输入。我的最终方案也基于这个。通过勾选StopAction，我们能实现在打开UI后禁用游戏输入，但是这个时候UI还不能用按钮关闭，我们需要在该UI的ConstructEvent里添加对Input Action的监听，在InputAction事件发生的回调函数里Remove FromParent，这样子就实现了关闭GUI。</p><p>但这个方案依然有一定的局限性，很容易发现，它的扩展性并不好。我们想要实现按下任意控制菜单的按钮都能关闭当前菜单，但是现在如果我们需要添加一个菜单，那么就需要在所有已有的菜单里添加对该按钮对应InputAction的监听以实现其他按钮也能关闭该菜单。</p><p>为了便于扩展，我们把这个过程抽取出来，作为<code>BaseMenuWidget_BP</code>，这个GUI只有一个空的Canvas，勾选StopAction，我们在它的Construct事件中添加对所有GUI的InputAction的监听，并在回调函数中摧毁它的子UI和它本身。</p><p>每当我们想要创建一个GUI时，我们创建一个InputAction的监听，在回调函数里创建<code>BaseMenuWidget_BP</code>，然后将我们想要创建的GUI作为它的Child。由于<code>BaseMenuWidget_BP</code>已经勾选了StopAction，所以我们想要创建的真正的GUI就不需要再勾选StopAction。在打开后，我们按下任意控制GUI的按钮，<code>BaseMenuWidget_BP</code>会连带它的child一起被摧毁，就达到了我们想要的效果。</p><p>下面是<code>BaseMenuWidget_BP</code>的完整蓝图。之后每当我们需要新增一个菜单只需要在这里添加一个InputAction的监听。</p><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/05/29/image-20230529141722728.png"alt="image-20230529141722728" /><figcaption aria-hidden="true">image-20230529141722728</figcaption></figure><p>下面是创建一个菜单的示例，每当我们想要创建一个菜单，需要先创建<code>BaseMenuWidget_BP</code>，然后把真正的菜单作为它的child。这里我对添加为子窗体做了一定的封装。</p><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/05/29/image-20230529141830958.png"alt="image-20230529141830958" /><figcaption aria-hidden="true">image-20230529141830958</figcaption></figure><p>封装的内容实际上就是这样一个简单的函数蓝图。</p><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/05/29/image-20230529141842337.png"alt="image-20230529141842337" /><figcaption aria-hidden="true">image-20230529141842337</figcaption></figure><p>但是这样还有最后一个问题，我们会发现打开Widget后，需要先点一下才能focus在Widget，关闭Widget后也需要再点一下才能重新控制视角。解决方案是在<code>BaseMenuWidget_BP</code>的EventConstruct中Set Input Mode Game And UI，主要要取消Hide Cursor DuringCapture，在HideWidget中将mode切回到GameMode，也就是Set Input Mode GameOnly。最终的蓝图如下。</p><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/05/29/image-20230529150639735.png"alt="image-20230529150639735" /><figcaption aria-hidden="true">image-20230529150639735</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE</tag>
      
      <tag>UMG</tag>
      
      <tag>GUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows自带处理软件的坑</title>
    <link href="/posts/3518714048/"/>
    <url>/posts/3518714048/</url>
    
    <content type="html"><![CDATA[<p>今天想把一个视频上传到github上，结果发现github单文件最大不能超过100MB，于是就被迫把视频减短一点。可惜前几天为了给UE腾空间，把PR等adobe一系列的软件都卸了，就只能用windows自带的视频编辑器。剪着剪着发现，不管我把视频减多短，视频分辨率调多低，导出的视频的大小都不变。</p><p>后来才发现原来是覆盖的问题。如果二次导出的文件直接覆盖之前导出的同名文件，那么视频虽然会变短、画质变差，但视频文件的大小不变。</p><p>这个bug同样存在于windows的图像编辑软件。</p><p>所以使用windows自带图像、视频编辑软件时还是进来另存为而不是直接覆盖原来的文件吧。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES202笔记</title>
    <link href="/posts/2758988255/"/>
    <url>/posts/2758988255/</url>
    
    <content type="html"><![CDATA[<h1 id="real-time-high-quality-rendering">Real-Time High QualityRendering</h1><p>实时：速度快于30FPS，对于VR、AR要求90FPS</p><p>interactive：像幻灯片一样，比较慢，但能交互</p><h2 id="cg-basics">CG Basics</h2><h3 id="graphics-pipeline">Graphics Pipeline</h3><pre><code class=" mermaid">flowchart TDid1(Application)id2[Vertex Processing]id3[Triangle Processing]id4[Rasterization]id5[Fragment Processing]id6[Framebuffer Operations]id7(display)id1--&gt;id2--&gt;|Vertex Stream|id3--&gt;|Triangle Stream|id4--&gt;|Fragment Stream|id5--&gt;|Shaded Fragments|id6--&gt;id7</code></pre><h3 id="opengl">OpenGL</h3><ol type="1"><li>Place objects/models<ul><li>Model specification</li><li>Model transformation</li><li>send object to GPU as a Vertex buffer object(VBO)</li></ul></li><li>Set up an easel<ul><li>View transformation</li><li>Create / use a framebuffer</li><li>Set camera, e.g. gluPerspective</li></ul></li><li>Attach a canvas to the easel<ul><li>OpenGL的一个优点：multiple render target(BRT)</li><li>一个renderingpass指定一个framebuffer，但可以有多个textures作为输出</li><li>framebuffer直接绘制到屏幕容易出现画面撕裂的效果，打开垂直同步其实就是不直接绘制，双重缓冲、三重缓冲技术</li></ul></li><li>Paint to the canvas<ul><li>顶点着色器、片元着色器</li><li>深度测试</li></ul></li></ol><h3 id="opengl-shading-language-glsl">OpenGL Shading Language(GLSL)</h3><blockquote><p>调试shader</p><ul><li><p>Nsight Graphics(跨平台，但仅支持NVIDIA GPUs)</p></li><li><p>RenderDoc(跨平台，不限制GPU)</p></li><li><p>用颜色作为输出print出来</p></li></ul></blockquote><h3 id="the-rendering-equation">The Rendering Equation</h3><p>In real-time rendering(RTR)</p><ul><li>Visibility is often explicitly considered</li><li>BRDF is often considered together with cosine term</li></ul><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20220901124347986.png" /></p><p>实时渲染中通常只考虑光线弹射一次</p><h2 id="real-time-shadows">Real-Time Shadows</h2><h3 id="recap-shadow-mapping">Recap: shadow mapping</h3><ul><li>A 2-Pass Algorithm<ul><li>先从光源发射光线，得到Shadow Map(SM)</li><li>从相机发射光源，根据SM</li></ul></li><li>An image-space algorithm<ul><li>Pro: 不需要知道场景的几何</li><li>Con:自遮挡和走样</li></ul></li></ul><p>先从光源出发，得到各个角度能照到的点的深度作为shadowmap。再从相机出发，根据相机照到的点检测是否在shadowmap中决定是否有阴影。</p><h4 id="shadow-mapping存在的问题">shadow mapping存在的问题</h4><p>光线与阴影所投平面不垂直时，由于shadowmap得到的每个点的深度是不连续的，会出现自遮挡的问题</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20220902081445037.png" /></p><p>为解决该问题，可以引入一个和光线与平面夹角有关的误差允许bias，但这样又会造成detachedshadow.</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20220902081706816.png" /></p><p>工业界往往通过调整bias达到既没有自遮挡又没有detachedshadow的效果。</p><p>其他的解决方案：Second-depth shadow mapping</p><ul><li>在shadowmap中记录最近和次近的点的深度，通过与最近和次近的点的中点的深度的比较决定是否有阴影</li><li>开销略大，且要求不能有没厚度的物体，所以基本没有被使用</li></ul><h3 id="the-math-behind-shadow-mapping">The math behind shadowmapping</h3><p><span class="math display">\[\int_{\Omega}f(x)g(x)dx\approx\frac{\int_\Omega f(x)dx}{\int_\Omegadx}\cdot\int_\Omega g(x)dx\tag {small support or smooth integrand}\]</span></p><blockquote><p>small support: 积分区间很小</p><p>smooth integrand: 被积函数积分范围内变化不大</p></blockquote><p>由此，可以得到渲染方程 <span class="math display">\[\begin{align}L_o(p,\omega_o)&amp;=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)cos\theta_iV(p,\omega_i)d\omega_i\\&amp;\approx\frac{\int_{\Omega+}V(p,\omega_i)d\omega_i}{\int_{\Omega+}d\omega_i}\cdot\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)cos\theta_id\omega_o\end{align}\]</span>约等式右边的第一项是Visibility，第二项是Shading，这其实就是shadowmap做的事。</p><p>什么时候近似准确</p><ul><li>Small support（积分限小）: point / directional lighting</li><li>Smooth integrand（变化小）: diffuse bsdf / constant radiance arealighting</li><li>两个满足一个就够了</li></ul><h3 id="percentage-closer-soft-shadowspcss">Percentage closer softshadows（PCSS）</h3><h4 id="percentage-closer-filteringpcf">Percentage CloserFiltering（PCF）</h4><ul><li>最初是用于抗锯齿</li><li>后发现可以用于软阴影</li></ul><p>将着色点相对light的深度和着色点在shadowmap上周围的一系列点（比如7*7，filtersize）的深度进行比较，取平均得到visibility。注意不是对shadowmap做模糊处理。</p><p>filter size越大，阴影越软，反之越硬。</p><p>可以通过调节不同地方的filtersize获得阴影软硬的变化，这样也就得到了PCSS。物体里阴影投射面越近的地方阴影越硬，越远越软。</p><h4 id="pcss原理">PCSS原理</h4><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20220902105814568.png" alt="image-20220902105814568" style="zoom:50%;" /></p><p><spanclass="math inline">\(w_{Penumbra}\)</span>实际上就是软阴影。</p><p>由相似可以得到 <span class="math display">\[w_{Penumbra}=(d_{Receiver}-d_{Blocker})\cdot w_{Light} / d_{Blocker}\]</span></p><h4 id="具体实现">具体实现</h4><blockquote><p>面光源取中心生成shadow map</p></blockquote><ol type="1"><li>Blocker search: getting the average blocker depth in a certainregion<ul><li>region可采用常数或启发式</li><li>启发式的region为着色点与光源的连线在shadowmap（近平面）上的范围</li><li><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20220902123942751.png" alt="image-20220902123942751" style="zoom:50%;" /></li></ul></li><li>Penumbra estimation: use the average blocker depth to determinefilter size</li><li>Percentage Closer Filtering</li></ol><p>在filtersize大的时候开销很大，可以采用稀疏采样再图像降噪的方法来降低开销。</p><h3 id="variance-soft-shadow-mapping">Variance soft shadow mapping</h3><blockquote><p>在temperal denoising方法提出后使用的没有PCSS多了</p></blockquote><h4 id="加速pcf">加速PCF</h4><p>Shadow Mapping实际上就是得出shadingpoint比filter的box里的百分之几的点近，如果知道分布，那么就可以快速得出这一点。</p><p>可以使用mean和variance来描述一个分布</p><ul><li>Mean<ul><li>HardwareMipMaping（只能求方形的mean，不能对任意矩形区域求mean，但很快）</li><li>Summed Area Tables（SAT，会慢一些）</li></ul></li><li>Variance<ul><li><span class="math inline">\(Var(X)=E(X^2)-E^2(X)\)</span><ul><li>需要额外的<span class="math inline">\(depth^2\)</span>的shadowmap，根据这个shadow map生成mipmap或SAT</li><li>可以将<spanclass="math inline">\(depth\)</span>作为一个颜色通道，<spanclass="math inline">\(depth^2\)</span>作为另一个颜色通道</li></ul></li></ul></li><li>计算CDF<ul><li>求数值解慢</li><li>查表（Error Function，在C++中是e2f）需要大量空间</li><li>用切比雪夫不等式来近似：<spanclass="math inline">\(P(x&gt;t)\le\frac{\sigma^2}{\sigma^2+(t-\mu)^2}\)</span>（<spanclass="math inline">\(t&gt;\mu\)</span>，对分布的类型没有要求，但是正态分布时非常近似）</li></ul></li></ul><h4 id="加速blocker-search">加速Blocker Search</h4><p>Blocker Search求的是一个块状区域内遮挡物的深度的均值<spanclass="math inline">\(z_{occ}\)</span>，记shadingpoint的深度为t，块状区域内非遮挡物的深度的均值为<spanclass="math inline">\(z_{unocc}\)</span>，则有 <spanclass="math display">\[\frac{N_1}{N}z_{unocc}+\frac{N_2}{N}z_{occ}=z_{Avg}\]</span> 用切比雪夫不等式近似，<spanclass="math inline">\(\frac{N_1}{N}=P(x&gt;t),\frac{N2}{N}=1-P(x&gt;t)\)</span>，大胆假设<spanclass="math inline">\(z_{unocc}=t\)</span>，这样就能解出<spanclass="math inline">\(z_{occ}\)</span></p><h3 id="mipmap-and-summed-area-variance-shadow-maps">MIPMAP andSummed-Area Variance Shadow Maps</h3><p>MIPMAP可能需要双线性插值甚至三线性插值，会不准。</p><p>SAT是记录从（0, 0）到（i,j）的矩形元素的和（前缀和思想的二维应用）。先按行并行求，再按列并行加起来。</p><h3 id="moment-shadow-mapping">Moment shadow mapping</h3><p>VSSM只用了<span class="math inline">\(z\)</span>和<spanclass="math inline">\(z^2\)</span>来表示分布，所以对于正态分布效果比较好，对其他分布则由于不够近似容易出现问题，会出现一些区域过黑（可以接受），一些区域过亮（lightleaking，不可接受）。MSM引入了更高阶的矩（moment）来实现更好地表述分布。通常到<spanclass="math inline">\(z^4\)</span>就能取得很好的效果。</p><p>但是从四阶矩重建出CDF开销比较大。</p><h3 id="distance-field-soft-shadows">Distance field soft shadows</h3><p>Distance Function: At any point, giving the minimum distance（couldbe signed distance） to the closest location on an object.即空间中一个点到所有物体的最近距离。</p><p>SDF：signed。可以定位物体内部的距离为负数，外部为正数。人们通常情况不管是否signed都称之为SDF。</p><h4 id="blend">blend</h4><p>SDF可以用于blend物体边界。直接对两张有明显边界的图进行线性插值显然无法得到边界移动的中间结果。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20230726140318617.png" /></p><p>但是SDF就可以很好地实现这一点。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20230726140353657.png" /></p><p>进而实现这样的变化。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20230726140541488.png" /></p><h4 id="usage">Usage</h4><h5 id="ray-marching">Ray Marching</h5><p>SDF的值可以看作a safe distancearound。因此，对于在p点的光线，可以前进<spanclass="math inline">\(SDF(p)\)</span>的距离，不断迭代，直到到达物体。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20230726140849208.png" /></p><h5 id="determine-the-approx-percentage-of-occlusion">determine theapprox percentage of occlusion</h5><p>SDF的值可以看作a safe angle seen from the eye。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20230726141054428.png" /></p><p>着色点的safe angle越小，表明被遮挡得越厉害，即less visibility。</p><p>safe angle的计算：在raymarching的时候计算各个点对应的角度，取最小的角度，表达式显而易见为<spanclass="math inline">\(arcsin(\frac{SDF(p)}{d_{travel}})\)</span>。但是反三角函数的计算比较复杂，实际上可以直接用反三角函数前的值来表示。即<spanclass="math inline">\(min\{\frac{kSDF(p)}{|p-o|},1.0\}\)</span>，o为光线出发的地方。这里的k实际上可以看作对阴影软硬的控制的系数，k越大阴影越硬。</p><ul><li>Pros<ul><li>Fast（不考虑DF的计算）</li><li>High quality</li></ul></li><li>Cons<ul><li>Need precomputation</li><li>Need heavy storage</li><li>对于物体形变需要重新计算SDF</li><li>Artifact</li></ul></li></ul><h2 id="real-time-environment-mapping">Real-time EnvironmentMapping</h2><p>认为光照来自无限远。</p><p>主流的两种存储方式：Spherical map和Cube map</p><h3 id="shading-from-environment-lighting">Shading from EnvironmentLighting</h3><p>由于上述的存储方式，环境光照又称为Image-Based Lighting（IBL）</p><p>使用它进行着色，在不考虑visibility的情况下 <spanclass="math display">\[L_o(p, \omega_o)=\int_{\Omega+}L_i(p, \omega_i)f_r(p, w_i,w_o)cos\theta_id\omega_i\]</span> <spanclass="math inline">\(\Omega+\)</span>表示上半球，和着色点的法线方向相关。</p><p>为解这个方程，直观的想法是使用蒙特卡洛积分，但是需要大量采样，开销很大。</p><p>在实时渲染中，往往不使用sampling。但是现在很多降噪方法的提出使得这一点变得不那么绝对。</p><p>BRDF往往要么是glossy的，要么是diffuse的。glossy意味着smallsupport，diffuse意味着smooth，</p><p>可以联想到这个近似式 <span class="math display">\[\int_\Omegaf(x)g(x)dx\approx\frac{\int_{\Omega_G}f(x)dx}{\int_{\Omega_G}dx}\int_\Omegag(x)dx\]</span> 那么渲染方程就可以写作 <span class="math display">\[L_o(p, \omega_o)\approx\frac{\int_{\Omega_{f_r}}L_i(p,\omega_i)d\omega_i}{\int_{\Omega_{f_r}}d\omega_i}\int_{\Omega+}f_r(p,\omega_i,\omega_o)cos\theta_id\omega_i\]</span> 右边的第一项其实就是对环境光做滤波。可以prefilter environmentlight，得到一组不同滤波核滤波的环境光。在着色时只需要查询着色点反射方向的prefilteredenvironment lighting即可。</p><p>实际上我们可以发现，原本的蒙特卡洛积分是在反射方向附近进行采样再加权平均，现在的则是预先filter再直接取值，两者非常近似。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/07/26/image-20230726152706419.png" /></p><p>对于右边的第二项，核心思想是预计算，但是直接预计算的话维度很大，需要大量的存储空间。</p><p>这里我们使用Microfacet模型，F为菲涅尔项 <span class="math display">\[\begin{align}\int_{\Omega+}f_rcos\theta_id\omega_i&amp;=\int_{\Omega+}\frac{f_r(p,\omega_i,\omega_o)}{F}Fcos\theta_id\omega_i\\&amp;\approx\int_{\Omega+}\frac{f_r}{F}(R_0+(1-R_0)(1-cos\theta)^5)cos\theta_id\omega_i（\text{Schlick&#39;sapproximation}）\\&amp;=R_0\int_{\Omega+}\frac{f_r}{F}(1-(1-cos\theta)^5)cos\theta_id\omega_i+\\&amp;\int_{\Omega+}\frac{f_r}{F}(1-cos\theta)^5cos\theta_id\omega_i\end{align}\]</span> 而<spanclass="math inline">\(f_r(i,o)=\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)}\)</span>，<spanclass="math inline">\(\frac{f_r}{F}=\frac{G(i,o,h)D(h)}{4(n,i)(n,o)}\)</span>，因为不考虑shadow，所以忽略G项（shadowing-maskingterm），此时只和D和<spanclass="math inline">\(\theta\)</span>有关。<spanclass="math inline">\(D(h)=\frac{e^{-\frac{tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2cos^4\theta_h}\)</span>，<spanclass="math inline">\(\theta_h\)</span>可以转化为<spanclass="math inline">\(\theta\)</span>的表达式，所以最终只和<spanclass="math inline">\(\alpha\)</span>（roughness）和<spanclass="math inline">\(cos\theta\)</span>有关，所以只需要预计算一个二维的表，作为一个texture。这个texture为LUT。</p><p>这种将乘积的积分（求和）拆开先求积分（求和）再求乘积的方法被称为SplitSum Approximation。</p><h3 id="shadow-from-environment-lighting">Shadow from EnvironmentLighting</h3><p>很难实现，通常工业界的做法是根据最强的光源决定阴影，或者用AmbientOcclusion。</p><h3 id="background-knowledge">Background knowledge</h3><h4 id="frequency-and-filtering">Frequency and filtering</h4><p>Any product integral can be considered as filtering <spanclass="math display">\[\int_\Omega f(x)g(x)dx\]</span> The frequency of the integral is the lowest of anyindividual's.</p><h4 id="basis-functions">Basis functions</h4><p>A set of functions that can be used to represent other functions ingeneral <span class="math display">\[f(x)=\sum_i c_i\cdot B_i(x)\]</span></p><h3 id="real-time-environment-lighting">Real-time environmentlighting</h3><h4 id="spherical-harmonicssh">Spherical Harmonics（SH）</h4><p>A set of 2D basis functions <spanclass="math inline">\(B_i(\omega)\)</span> defined on the sphere.</p><p>可视化如图</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/08/02/image-20230802164910221.png" /></p><p>给定一个<spanclass="math inline">\(\omega\)</span>，会与一个基函数有且只有一个交点，交点处的颜色即表示函数值的大小。</p><p><span class="math inline">\(l\)</span>是SH的阶数，第<spanclass="math inline">\(l\)</span>阶SH有<span class="math inline">\(2l +1\)</span>个基函数，前<span class="math inline">\(l\)</span>阶有<spanclass="math inline">\((l+1)^2\)</span>个基函数。</p><p>SH使用时往往取前三阶。</p><p>越高阶的SH表示越高频率的信息，所以SH往往适用于低频信息。</p><p>基函数的系数的求解称为投影，可以通过下式得到 <spanclass="math display">\[c_i=\int_\Omega f(\omega)B_i(\omega)d\omega\]</span> <spanclass="math inline">\(B_i(\omega)\)</span>由勒让德多项式（Legendrepolynomial）得到。</p><h4 id="prefiltered-environment-lighting">Prefiltered environmentlighting</h4><p>Diffuse的BRDF往往只有低频信息，所以基本只有前三阶（l=0,1,2）的系数非零。</p><p>Rendering Equation中<spanclass="math inline">\(L*fr*d\omega_i\)</span>可以将<spanclass="math inline">\(f_r\)</span>看作低通滤波（frequency of theintegral is the lowest of anyindividual's），所以实际上L也没必要含高频信息。</p><p>对于任何光照，只要brdf是diffuse的，那么用前三阶作为光照，平均误差不超过3%。</p><h4 id="precomputed-radiance-transferprt">Precomputed RadianceTransfer（PRT）</h4><p>把Rendering Equation <span class="math display">\[L(o)=\int_\Omega L(i)V(i)\rho(i,o)max(0,n\cdot i)di\]</span> 中的<spanclass="math inline">\(L(i)\)</span>看作lighting，<spanclass="math inline">\(V(i)\rho(i,o)max(0,n\cdot i)\)</span>看作lighttransport，可以发现lighting仅与<spanclass="math inline">\(i\)</span>有关，是一个球面函数，lighttransport的变量也只有<spanclass="math inline">\(i\)</span>，也是一个球面函数。</p><p><span class="math inline">\(L(i)\approx\sum l_j B_j(i)\)</span></p><p>考虑在场景中只有光照可以发生变化的情况，我们可以预计算lighttransport。</p><ul><li>Pro：可以方便地切换环境光，能够快速地处理光源的旋转，由于保留了V项，能够产生阴影</li><li>Con：场景中的物体不能移动</li></ul><h5 id="diffuse-case">Diffuse case</h5><p><span class="math display">\[\begin{align}L(o)&amp;=\rho\int_\Omega L(i)V(i)max(0,n\cdot i)di\\&amp;\approx \rho\sum l_j\int_\Omega B_j(i)V(i)max(0, n\cdot i)di\end{align}\]</span></p><p>在实时渲染中，往往认为积分和求和顺序总是可交换（除了differentiablerendering）</p><p>上式的积分可以预计算，于是得到 <span class="math display">\[L(o)\approx\rho\sum l_jT_j\]</span> 其中<span class="math inline">\(T_i\approx\int_\OmegaB_j(i)V(i)max(0,n\cdot i)di\)</span></p><p>可以看到，积分最终变成了两个函数在同一组基函数上的投影的乘积，即点乘。</p><p>另一种思路 <span class="math display">\[L(\omega_i)\approx\sum_p c_pB_p(\omega_i)\\T(\omega_i)\approx\rho\sum_q c_qB_q(\omega_i)\\\begin{align}L_o(p,\omega_o)&amp;=\int_{\Omega+}L(\omega_i)T(\omega_i)d\omega_i\\&amp;=\rho\sum_p\sum_qc_pc_q\int_{\Omega+}B_p(\omega_i)B_q(\omega_i)d\omega_i\\&amp;=\rho\sum l_jT_j（由正交性得）\end{align}\]</span></p><p>如果我们将上面<spanclass="math inline">\(T_j\)</span>的式子看作渲染方程，<spanclass="math inline">\(B_j\)</span>则相当于光照，<spanclass="math inline">\(T_j\)</span>实际上就是着色点在<spanclass="math inline">\(B_j\)</span>光照下的颜色。</p><h5 id="basis-functions-1">Basis functions</h5><p>采用SH作为basic function</p><p>SH的性质</p><ul><li>orthonormal<ul><li><span class="math inline">\(\int_\Omega B_j(i)\cdot B_k(i)di=1\text{if (j=k)}\)</span></li><li><span class="math inline">\(\int_\Omega B_j(i)\cdot B_k(i)di=0\text{if (j}\ne\text{k)}\)</span></li></ul></li><li>simple projection/reconstruction</li><li>simple rotation<ul><li>当光源发生旋转时，就是对<span class="math inline">\(\sum l_jB_j(i)\)</span>进行旋转，可以看作对各个<spanclass="math inline">\(B_j\)</span>进行旋转，而SH中<spanclass="math inline">\(B_j\)</span>旋转后的结果可以用同阶的SH的线性组合表示</li></ul></li><li>simple convolution</li><li>few basis functions: low freqs</li></ul><h5 id="glossy-case">Glossy case</h5><p><span class="math display">\[\begin{align}L(o)&amp;=\int_\Omega L(i)V(i)\rho(i,o)max(0,n\cdot i)di\\&amp;\approx\sum l_jT_j(o)\end{align}\]</span></p><p>在diffuse中，<span class="math inline">\(L\)</span>是一个值，lighttransport预计算得到向量<spanclass="math inline">\([T_1,T2,...T_n]\)</span>。</p><p>而在diffuse中，<spanclass="math inline">\(L(o)\)</span>是一个向量，lighttransport预计算得到矩阵，<spanclass="math inline">\(L(o)\)</span>约等于light的系数向量和transport系数矩阵的乘。</p><h4 id="more-basis-functions">More Basis Functions</h4><p>Wavelet（小波）</p><p>定义在图像块上，每个基函数的定义域不一定相同，（灰色为非定义域内）</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/08/02/image-20230802200504235.png" /></p><p>Wavelet可以保留各个频率的信息。</p><p>每次对图像进行Wavelettransform，仅会有很少的基函数的系数非零，通过这个进行数据压缩，是一种非线性的近似。</p><p>由于Wavelet定义在图像块上，人们往往使用cubemap表示环境光而不是sphere，对cubemap的每张图分别进行WaveletTransform。</p><p>Wavelet Transform</p><ul><li>将高频信息留在右上、左下、右下，稍微低频的留在左上角，再对左上角递归做这样的操作。</li></ul><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/08/02/image-20230802230222445.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/08/02/image-20230802201142396.png" /></p><p>JPEG就使用了一种类似小波变换的离散余弦变换DCT</p><p>小波变换一个比较大的缺点就是不支持旋转。</p><h2 id="real-time-global-illuminationin-3d">Real-time GlobalIllumination（in 3D）</h2><p>在实时渲染中，全局光照往往只要求one bounce indirect illumination</p><h3 id="reflective-shadow-mapsrsm">Reflective Shadow Maps（RSM）</h3><p>主要思路是将被直接光照照亮的表面作为新的次级光源，用来照亮其他点。</p><ul><li>用shadow map可以获得直接被光源照亮的点</li><li>shadow map上的每一个像素都是一个小的surfacepatch，可以作为面光源</li><li>渲染时只知道次级光源朝相机的radiance，但不知道朝被间接照亮的物体表面的radiance<ul><li>假设所有reflector都是diffuse的，于是朝被间接照亮的物体表面的radiance等于朝相机的radiance（对接受物没有要求）</li></ul></li></ul><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/08/06/image-20230806141007346.png" /><span class="math display">\[\begin{align}L_o(p,\omega_o)&amp;=\int_{\Omega_{patch}}Li(p,\omega_i)V(p,\omega_i)f_{r_p}(p,\omega_i,\omega_o)cos\theta_id\omega_i\\&amp;=\int_{A_{patch}}L_i(q\rightarrowp)V(p,\omega_i)f_{r_p}(p,q\rightarrow p,\omega_o)\frac{cos\theta_pcos\theta_q}{||q-p||^2}dA\end{align}\]</span> 对于diffuse的reflect，<spanclass="math inline">\(f_{r_q}=\frac{\rho}{\pi}\)</span>，<spanclass="math inline">\(\rho\)</span>为albedo，根据BRDF的定义，有<spanclass="math inline">\(L_i=f_{r_q}\cdot\frac{\Phi}{dA}\)</span>，其中<spanclass="math inline">\(\Phi\)</span>是incident flux，由光源决定。</p><p>由此可以得到q给x点的Irradiance，<spanclass="math inline">\(E_q(x,n)=L_i(q\rightarrow p)\cdot\frac{cos\theta_pcos\theta_q}{||q-p||^2}dA=\Phi_q\frac{max\{0,&lt;n_q|x-x_q&gt;\}max\{0,&lt;n|x_q-x&gt;\}}{||x-x_q||^4}\)</span></p><p>遮挡问题由于没法求解，所以visibility直接不算</p><p>对于每一个shading point，都需要求shadowmap上的所有像素的贡献，这样很明显计算量太大了，而且有一些像素可以简单地判断出没有贡献。为了实现判断，需要在shadowmap上记录一些额外的信息，除了深度以外，还包括世界坐标、法向量、flux。可以通过着色点和secondarylight连线的方向和法线的夹角判断简单的遮挡关系。</p><p>为了减少计算量，采用和PCSS类似的方法，仅对部分点进行采样。考虑到彼此之间越近的reflector和receiver贡献越大，假设深度图上越近且深度接近的点的世界坐标也足够近，仅对这些点进行采样，这样子计算量就不再是shadowmap的分辨率，而可以压缩到400个patch。</p><p>RSM技术通常被用来做游戏中的手电筒。</p><ul><li>Pros：易于实现</li><li>Cons：<ul><li>由于采用了shadow map，performance和光源数线性相关</li><li>No visibility check for indirect illumination</li><li>Many assumptions：diffuse reflectors，depth as distance, etc</li><li>Sampling rate/ quality trade off</li></ul></li></ul><h3 id="light-propagation-volumeslpv">Light PropagationVolumes（LPV）</h3><p>Key idea：Radiance travels in a straight line and does not change</p><p>Keysolution：将空间划分为网格，从被光源直接照亮的物体表面出发，通过网格向各方向传播</p><p>具体步骤：</p><ol type="1"><li>用和RSM一样的方法得到被光源直接照亮的点的集合，可以适当减少surfacepatch的数量</li><li>将点云作为虚拟光源注入到网格中<ul><li>Sum up directional radiance distribution in each grid cell</li><li>将和投影到二阶球谐函数上</li></ul></li><li>Volumetric radiance propagation<ul><li>For each grid cell, collect the radiance received from each of its 6faces</li><li>Sum up, and again use SH to represent</li><li>Repeat this propagation several times till the volume becomesstable（差不多4到5次收敛）</li></ul></li><li>Scene lighting with final light propagation volume<ul><li>For any shading point, find the grid cell it is located in</li><li>Grab the incident radiance in the grid cell（from alldirections）</li><li>shade</li></ul></li></ol><p>疑惑：grid cell是如何收集radiance的</p><ul><li>如果是像cubemap一样收集，那岂不是不向grid中心的信息都丢失了？</li><li>如果是简单地相加，那不就相当于把各个面接收到的光的起点都移动到gridcell的中心，那光线就不是沿直线传播了呀？而且按照论文中的图示，感觉论文就是这样做的，不能理解。</li></ul><h3 id="voxel-global-illuminationvxgi">Voxel GlobalIllumination（VXGI）</h3><h2 id="real-time-global-illuminationscrenn-space">Real-Time GlobalIllumination（screnn space）</h2>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>长篇笔记</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unity package手动下载</title>
    <link href="/posts/1754838349/"/>
    <url>/posts/1754838349/</url>
    
    <content type="html"><![CDATA[<p>今天做软工大程的时候遇到一个需求，要把Unity里的模型导出成fbx（其实就是UnityAssetStore里免费资源比UE里多好多，想把Unity的资源转到UE里去）。Unity里提供了一个比较官方的package的，也就是FBXExporter。但不知道为什么，我一台电脑上可以看到5.0.0版本的，另一台电脑上同样版本的Unity确只能看到4.1.2版本。5.0.0相对4.1.2有一个重要的导出选项EmbededTexture，所以我必须要使用5.0.0的版本。</p><p>本来以为只是另一台电脑上没有开enablelpre-release的选项，可是发现开了也没有用，还是找不到。</p><p>于是就想着，那就手动下包再安装吧。可是找来找去，也只找到插件的文档的链接，下载地址是一点踪迹也没有。</p><p>后来翻unity论坛，才偶然发现unity把包的除packagemanager的下载方式都隐藏了起来，大概是想大力推packagemanager（可惜packagemanager貌似有点bug，看到好多用19、20的unity的都有和我同样的问题）。现在没有直观的web界面用于包管理了，但可以通过访问url直接下载包。至于这个url，可以从包的文档的链接推出来。</p><p>比如我要下载一个FBXExporter，它的文档链接是<code>https://docs.unity3d.com/Packages/com.unity.formats.fbx@5.0/manual/index.html</code>，那么就可以访问这个网页<code>https://download.packages.unity.com/com.unity.formats.fbx/</code>来获取各种包的信息。在这个网页里查找你想要的版本对应的tarball链接，访问就可以下载了。</p><p>下载下来的文件可以重命名加上<code>.tgz</code>后缀，然后在Unity的packagemanager里点击"+"再点击"Add package fromtarball"，选中下载的文件就可以安装想要的版本了。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>functor</title>
    <link href="/posts/786566374/"/>
    <url>/posts/786566374/</url>
    
    <content type="html"><![CDATA[<blockquote><p>看八股文途中无意间看到仿函数，特意去了解了下</p></blockquote><span id="more"></span><p>仿函数（Functor）指的是重载了<code>()</code>运算符的类，对象可以像函数一样被调用。</p><p>适用场景</p><ul><li>当一个函数多次调用需要的许多参数都一致时，可以将那些不怎么变化的参数作为成员变量在初始化时传入，变化的量作为仿函数的参数调用时传入</li></ul><p>此外，仿函数可以被视作函数指针。利用这点以及类的继承，可以实现类似函数继承，STL里就用到了这个技巧（比如<code>functional</code>里的<code>greater</code>和<code>less</code>）。</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程服务器编程：使用muduo C++ 网络库</title>
    <link href="/posts/3669776500/"/>
    <url>/posts/3669776500/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读《Linux多线程服务器编程》时记录下的笔记</p></blockquote><span id="more"></span><h2 id="c多线程系统编程">C++多线程系统编程</h2><h3 id="线程安全的对象生命期管理">线程安全的对象生命期管理</h3><p>多线程编程中，构造函数中不要把this传出去，半构造的对象可能带来不可预计的后果，即使是构造函数的最后，因为它可能作为基类，基类构造完了，不代表子类构造结束了。</p><p>这种情况下往往需要二段式构造，需要一个额外的initialize函数。既然允许二段式构造，那也不必在构造函数中抛出异常，而可以根据initialize函数的返回值确认构造是否正常。</p><p>使用成员变量mutex不能够保护析构函数，因为析构函数会把mutex析构，此时如果有其他函数被mutex拦住，将发生未定义行为。</p><p>遇到要对多个物体加锁的场景，尤其是物体由参数传入时，要注意加锁顺序，可以通过比较地址大小决定枷锁顺序。</p>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>长篇笔记</tag>
      
      <tag>多线程</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程笔记</title>
    <link href="/posts/3589769194/"/>
    <url>/posts/3589769194/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读《Linux高性能服务器编程》时记录下的笔记</p></blockquote><span id="more"></span><p>/proc/sys/net/ipv4/下定义了大量tcp连接相关的内核变量。</p><p>一些常用的工具：tcpdump、iptables、telnet、nc、netstat、iperf、squid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -p client_port server_ip server_port # 建立连接<br>nc -l port # 监听port<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tcpdump -n -i 网卡名 port 端口号 # -t会关闭时间戳<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -nat # 查看连接状态<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">iperf -s # 测量网络状况的工具，-s将其作为服务器运行，默认监听5001端口，并丢弃收到的所有数据<br></code></pre></td></tr></table></figure><p>squid是代理服务器，支持正向代理、反向代理</p><p>/etc/init.d/目录下有众多服务器程序，如httpd、vsftpd、sshd、mysqld，由脚本程序service(/usr/sbin/service)提供统一管理(start,stop, restart)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">arp -d target_ip # 删除ARP高速缓存中target_ip的MAC地址<br></code></pre></td></tr></table></figure><p>tcp状态转移：</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/11/image-20230211164629980.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/11/image-20230211173213744.png" /></p><p>客户端执行半关闭后（FIN_WAIT_2），未等服务器关闭连接就强行退出，此时客户端连接由内核来接管，称为孤儿连接。Linux内核变量定义了最大孤儿连接数(tcp_max_orphans)和最长停留时间(tcp_fin_timeout)</p><p>主动断开连接的服务器会由于处于TIME_WAIT状态而不能在原端口（服务器往往运行在知名端口）立即重启，可以通过socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态的连接占用的端口。</p><p>TCP传输的紧急数据往往又称带外数据(Out Of Band,OOB)，紧急指针只会指向紧急数据的下一字节，所以只有带外数据的最后一个字节会作为紧急数据。通常情况下，带外数据存储在特殊的缓存中，带外缓存只有1字节，如果设置SO_OOBINLINE则带外数据将和普通数据一样被存放在TCP接收缓冲区。</p><p>Linux中两个TCP超时重传的内核参数tcp_retries1(最少重传次数)、tcp_retries2(最多重传次数)</p><h4 id="拥塞控制">拥塞控制</h4><p>接收方通过发送窗口(SWND)控制发送方发送的报文段数量，发送方通过接收通告窗口(RWND)控制发送方的SWND。发送方还有拥塞窗口(CWND)，SWND=min(RWND,CWND)，这些都以字节为单位。</p><p>在使用DNS服务之前，Linux会先进行本地查询，在/etc/hosts配置文件中查找主机名对应的IP地址。</p><p>/etc/host.conf文件可以自定义系统解析主机名的方法和顺序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">order hosts,bind # hosts表示/etc/hosts,bind表示DNS服务<br>multi on<br></code></pre></td></tr></table></figure><h2 id="linux网络编程">Linux网络编程</h2><p>现代PC大多采用小端字节序，所以小端字节序又称为主机字节序。发送端总是将数据转为大端字节序，所以大端字节序也称为网络字节序。</p><p>linux提供一系列主机字节序和网络字节序间转换的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-comment">// h: host, n: net, l: long, s: short</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> hostshort)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> netlong)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> netshort)</span>;<br></code></pre></td></tr></table></figure><p>Linux将许多东西都看作文件进行处理，socket也是如此。</p><h3 id="socket">Socket</h3><p>socket网络编程中通用biao'ssocket地址的是结构体sockaddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sa_family; <span class="hljs-comment">// 所属地址族，如AF_UNIX、AF_INET、AF_INET6</span><br>    <span class="hljs-comment">// 协议族PF_*和地址族完全对应，可以混用</span><br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>]; <span class="hljs-comment">// 地址，根据地址族类型有不同含义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/11/image-20230211232419525.png" /></p><p>由于14字节的sa_data无法满足多数需求，Linux定义了新的socket地址结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __ss_align; <span class="hljs-comment">// 仅用作地址对齐</span><br>    <span class="hljs-type">char</span> __ss_padding[<span class="hljs-number">128</span>-<span class="hljs-keyword">sizeof</span>(__ss_align)];<br>&#125;;<br></code></pre></td></tr></table></figure><p>为方便使用，Linux提供了协议族的专用socket地址——sockaddr_un(UNIX本地协议族),sockaddr_in(IPv4，#include &lt;netinet/in.h&gt;),sockaddr_in6(IPv6)，它们的port应用大端格式(n)</p><h4 id="ip地址转换函数">IP地址转换函数</h4><p>ipv4有以下函数(a表示字符串，n表示二进制数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* strptr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cp, <span class="hljs-keyword">struct</span> in_addr* inp)</span>;<br><span class="hljs-type">char</span>* <span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr in)</span>;<br></code></pre></td></tr></table></figure><p>需要注意的是inet_ntoa返回的是其内部静态变量的指针，所以是不可重入的。</p><p>有同时支持IPv4,IPv6的函数(p表示字符串地址，n表示二进制数，af为地址族)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">void</span>* dst)</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* src, <span class="hljs-type">char</span>* dst, <span class="hljs-type">socklen_t</span> cnt)</span>;<br></code></pre></td></tr></table></figure><p>inet_pton成功时返回1，失败返回0并设置errno。</p><p>inet_ntop成功时返回dst地址，失败则返回NULL并设置errno。cnt用于指定dst的大小，这里往往使用以下宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET_ADDRSTRLEN 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure><h4 id="创建socket">创建socket</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * domain: 地址族</span><br><span class="hljs-comment"> * type: 是服务类型，如SOCK_STREAM,SOCK_UGRAM，对于TCP/IP协议族，SOCK_STREAM表示传输层使用TCP，SOCK_UGRAM表示传输层使用UTP，可以与SOCK_NONBLOCK, SOCK_CLOEXEC相与控制是否阻塞以及fork创建子进程时子进程是否关闭该socket</span><br><span class="hljs-comment"> * protocol: 在前两个参数构成的协议集合下，再选择一个具体的协议。由于前两个基本已经确定了具体的协议，所以几乎都用0(表默认)</span><br><span class="hljs-comment"> * return: 文件描述符。失败则返回-1并设置errno</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="命名socket">命名socket</h4><p>将socket与socket地址绑定称为给socket命名。通常只有服务器需要命名socket，而客户端采用匿名方式，由操作系统自动分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* my_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">// 成功时返回0，失败则返回-1并设置errno</span><br><span class="hljs-comment">// 常见errno有EACCES(被绑定地址是受保护地址，比如知名服务端口), EADDRINUSE(被绑定地址正在使用中，比如处于TIME_WAIT)</span><br></code></pre></td></tr></table></figure><h4 id="监听socket">监听socket</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><span class="hljs-comment">// backlog指定内核监听队列的最大长度。如果监听队列长度超过backlog，服务器将不受理新的客户连接，客户端也将受到ECONNREFUSED错误信息。在内核版本2.2之前，backlog指的是所有处于半连接(SYN_RCVD)和完全连接的socket上限，之后则表示处于完全连接的socket上限，处于半连接的socket上限由/proc/sys/net/ipv4/tcp_max_syn_backlog定义。backlog的典型值为5。返回值同上。</span><br><span class="hljs-comment">// 实际实现中，监听队列的最大长度会略大于backlog</span><br></code></pre></td></tr></table></figure><p>服务端开始监听后，客户端就可以与服务端建立TCP连接。</p><h4 id="接收连接">接收连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br><span class="hljs-comment">// 用于获取客户端socket地址。实际工作过程是从监听队列中取出连接，并不涉及到网络</span><br><span class="hljs-comment">// 返回值同上</span><br></code></pre></td></tr></table></figure><h4 id="发起连接">发起连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, constr <span class="hljs-keyword">struct</span> sockaddr *serv_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">// 常见errno有ECONNREFUSED(目标端口不存在，连接被拒绝)、ETIMEDOUT(连接超时)</span><br></code></pre></td></tr></table></figure><h4 id="关闭连接">关闭连接</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><span class="hljs-comment">// 将fd的引用-1，如果为0则关闭socket</span><br><br><span class="hljs-comment">// 如果无论如何都要立即关闭socket，应使用shutdown</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> howto)</span>;<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212110434692.png" /></p><h4 id="数据读写">数据读写</h4><h5 id="tcp">TCP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">// 读取sockfd上的数据，返回实际读取数据长度(&lt;=len)</span><br><span class="hljs-comment">// len通常为buf大小-1</span><br><span class="hljs-comment">// 返回0表面通信对方已经关闭连接</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">// 往sockfd上写入数据，返回实际写入数据长度</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212114708920.png" /></p><p>没有特殊要求就用0</p><p>MSG_OOB发送的数据仅有最后一字节会作为OOB数据被接收，且对正常数据的接收会被OOB数据截断，中间夹杂着OOB数据的数据需要多次recv才能读出。</p><h5 id="udp">UDP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags, <span class="hljs-keyword">struct</span> sockaddr* src_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> fags, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* dest_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure><p>这两个函数同样可以用于面向连接的数据读写，只需要将最后两个参数设置为NULL。</p><h5 id="通用数据读写">通用数据读写</h5><p>可以用于TCP、UDP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> msghdr* msg, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> msghdr* msg, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span>* msg_name; <span class="hljs-comment">// socket地址，TCP则为NULL</span><br>    <span class="hljs-type">socklen_t</span> msg_namelen; <span class="hljs-comment">// socket地址的长度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>* <span class="hljs-title">msg_iov</span>;</span> <span class="hljs-comment">// 分散的内存块，iovec数组</span><br>    <span class="hljs-type">int</span> msg_iovlen; <span class="hljs-comment">// 分散内存块的数量，数组元素数</span><br>    <span class="hljs-type">void</span>* msg_control; <span class="hljs-comment">// 指向辅助数据的起始位置，往往是cmsghdr</span><br>    <span class="hljs-type">socklen_t</span> msg_controllen; <span class="hljs-comment">// 辅助数据的大小</span><br>    <span class="hljs-type">int</span> msg_flags; <span class="hljs-comment">// 复制函数中的flags参数，并在调用过程中更新，所以调用函数前无需设置</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span>* iov_base; <span class="hljs-comment">// 内存起始地址</span><br>    <span class="hljs-type">size_t</span> iov_len; <span class="hljs-comment">// 这块内存的长度</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>数据存在分散的内存块中，需要分散读(scatterread)，发送时一并发送，称为集中写(gather write)</p><h4 id="带外标记">带外标记</h4><p>由于实际应用中程序不知道什么时候OOB数据到来，Linux提供了函数用于判断下一个被读取的数据是否是带外数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sockatmark</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span>;<br><span class="hljs-comment">// 如果下一个被读取的数据是OOB，则返回1</span><br></code></pre></td></tr></table></figure><h4 id="地址信息函数">地址信息函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockname</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr* address, <span class="hljs-type">socklen_t</span>* address_len)</span>;<br><span class="hljs-comment">// 获取本地sockfd对应的socket address</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getpeername</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr* address, <span class="hljs-type">socklen_t</span>* address_len)</span>;<br><span class="hljs-comment">// 获取远端与sockfd连接的socket address，与accept几乎一致</span><br></code></pre></td></tr></table></figure><h4 id="socket选项">socket选项</h4><p>socket文件描述符属性读取和修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> option_name, <span class="hljs-type">void</span>* option_value, </span><br><span class="hljs-params">               <span class="hljs-type">socklen_t</span>* <span class="hljs-keyword">restrict</span> option_len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> option_name, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* option_value,</span><br><span class="hljs-params">               <span class="hljs-type">socklen_t</span> option_len)</span>;<br><span class="hljs-comment">// level指定要操作的协议(IPv4、IPv6、TCP等)，option_name指定选项</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212140412656.png" /></p><p>部分选项仅在listen、connect前设置有效：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY。</p><p>SO_REUSEADDR可以使得sock即使处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用，也可以通过/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态。</p><p>SO_RCVBUF、SO_SNDBUF用来控制接收缓冲区和发送缓冲区，setsockopt时实际上是将缓冲区设为max(2*value,min_value)。可以通过/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制接收缓冲区和发送缓冲区没有最小值限制。</p><p>SO_RCVLOWAT和SO_SNDLOWAT是低水位标记，当接收缓冲区的可读数据总数大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据，当发送缓冲区中的空闲空间大于低水位标记时，I/O复用系统调用将通知应用程序可以往对应的socket上写入数据。默认情况下，低水位标记都为1字节。</p><p>SO_LINGER用于控制close系统调用的行为。默认情况下，close将立即返回，TCP会把发送缓冲区中残留的数据发送给对方。SO_LINGER选项需要linger结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linger</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> l_onoff; <span class="hljs-comment">// 0表示off，非0表示on</span><br>    <span class="hljs-type">int</span> l_linger;<span class="hljs-comment">// 滞留时间</span><br>&#125;;<br><span class="hljs-comment">// 如果是off，则close为默认行为</span><br><span class="hljs-comment">// 如果是on，l_linger等于0，则close立即返回，发送缓冲区残留的数据被丢弃，同时给对方发送一个复位报文段，即一种异常终止连接的方法。</span><br><span class="hljs-comment">// 如果是on且l_linger非0，</span><br><span class="hljs-comment">// 如果是阻塞的socket，则会尝试在l_linger时间内发完所有残留数据并得到对方确认，</span><br><span class="hljs-comment">//如果没有成功则返回-1并设置errno为EWOULDBLOCK</span><br><span class="hljs-comment">//如果是非阻塞的socket，则close立即返回，可以根据返回值和errno判断残留数据是否发送完毕。</span><br></code></pre></td></tr></table></figure><h4 id="网络信息api">网络信息API</h4><h5 id="host">host</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-keyword">struct</span> hostent* <span class="hljs-title function_">gethostbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span>;<br><span class="hljs-comment">// 先在/etc/hosts中查找，再去访问DNS服务器</span><br><span class="hljs-keyword">struct</span> hostent* <span class="hljs-title function_">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> type)</span>;<br><span class="hljs-comment">// type为地址族</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span>* h_name;<span class="hljs-comment">// 主机名</span><br>    <span class="hljs-type">char</span>** h_aliases;<span class="hljs-comment">// 主机别名列表</span><br>    <span class="hljs-type">int</span> h_addrtype;<span class="hljs-comment">// 地址族</span><br>    <span class="hljs-type">int</span> h_length;<span class="hljs-comment">// 地址长度</span><br>    <span class="hljs-type">char</span>** h_addr_list;<span class="hljs-comment">// 按网络字节序列出的主机IP地址列表</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="service">service</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-keyword">struct</span> servent* <span class="hljs-title function_">getservbyname</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* proto)</span>;<br><span class="hljs-keyword">struct</span> servent* <span class="hljs-title function_">getservbyport</span><span class="hljs-params">(<span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* proto)</span>;<br><span class="hljs-comment">// 通过读取/etc/services</span><br><span class="hljs-comment">// name指定服务名字，tcp表示流服务，udp表示数据报服务，NULL表示所有类型服务</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span>* s_name;<br>    <span class="hljs-type">char</span>** s_aliases;<br>    <span class="hljs-type">int</span> s_port;<br>    <span class="hljs-type">char</span>* s_proto;<span class="hljs-comment">// 服务类型，如tcp、udp</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是以上四个host和service的函数都是不可重入的。可重入版本是函数_r。</p><hr /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* hostname, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* service, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> addrinfo* hints, <span class="hljs-keyword">struct</span> addrinfo** result)</span>;<br><span class="hljs-comment">// 该函数可以用于同时获取IP地址(根据主机名)和端口号(根据服务名)结果存在result中，result指向一个链表</span><br><span class="hljs-comment">// hints用于实现对输出更精确的控制，可以被设置为NULL。可以设置ai_flags,ai_family, ai_socktype,ai_protocol，其他字段必须设为NULL</span><br><span class="hljs-comment">// 可重入性取决于内部实现</span><br><span class="hljs-comment">// 该函数会动态分配内存</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> ai_flags;<br>    <span class="hljs-type">int</span> ai_family;<span class="hljs-comment">// 地址族</span><br>    <span class="hljs-type">int</span> ai_socktype;<span class="hljs-comment">// 服务类型，如SOCK_STREAM、SOCK_DGRAM</span><br>    <span class="hljs-type">int</span> ai_protocol;<span class="hljs-comment">// 具体的网络协议，与socket的第三个参数类似，由于地址族和服务类型基本已经确定了网络协议，所以通常为0</span><br>    <span class="hljs-type">socklen_t</span> ai_addrlen;<br>    <span class="hljs-type">char</span>* ai_canonname;<span class="hljs-comment">// 主机的别名</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>* <span class="hljs-title">ai_addr</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>* <span class="hljs-title">ai_next</span>;</span><br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">freeaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> addrinfo* res)</span>; <span class="hljs-comment">// 用于释放空间</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212155534220.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* sockaddr, <span class="hljs-type">socklen_t</span> addrlen, <span class="hljs-type">char</span>* host,</span><br><span class="hljs-params">               <span class="hljs-type">socklen_t</span> hostlen, <span class="hljs-type">char</span>* serv, <span class="hljs-type">socklen_t</span> servlen, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">// 用于同时获取主机名和服务名</span><br><span class="hljs-comment">// flags控制它的行为</span><br><span class="hljs-comment">// 可重入性取决于内部实现</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212160149921.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212160211863.png" /></p><p>Linux提供了将errno转换成易读字符串形式的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">gai_strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> error)</span>;<br></code></pre></td></tr></table></figure><h2 id="高级io函数">高级I/O函数</h2><h3 id="pipe">pipe</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span>;<br><span class="hljs-comment">// 将两个文件描述符用管道连接，fd[0]能从管道读出数据，fd[1]能向管道写入数据</span><br><span class="hljs-comment">// 默认情况下，这一对文件操作符都是阻塞的。</span><br><span class="hljs-comment">// 如果管道的写端文件描述符fd[1]的引用计数减少至0，则fd[0]的read会返回0，即读取到了EOF。</span><br><span class="hljs-comment">// 如果管道的读端文件描述符fd[0]的引用计数减少至0，则fd[1]的write会引发SIGPIPE信号</span><br></code></pre></td></tr></table></figure><p>管道容量默认是65536字节，可以通过fcntl函数来修改。</p><p>可以通过socketpair方便地创建双向管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socketpair</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol, <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span>;<br><span class="hljs-comment">// domain只能使用AF_UNIX，因为仅能在本地使用双向管道</span><br></code></pre></td></tr></table></figure><h3 id="dup和dup2">dup和dup2</h3><p>当我们希望将标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接(比如CGI编程)时，可以用该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> file_descriptor)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> file_descriptor_one, <span class="hljs-type">int</span> file_descriptor_two)</span>;<br><span class="hljs-comment">// 创建一个新的与file_descriptor指向相同文件、管道或网络连接的文件描述符(属性不复制)</span><br><span class="hljs-comment">// dup返回的文件描述符总是取系统当前可用的最小文件描述符整数值</span><br><span class="hljs-comment">// dup2返回第一个不小于file_descriptor_two的整数值</span><br></code></pre></td></tr></table></figure><p>可以通过close原本的文件(比如标准输入、输出)，再dup要重定向到的文件，使得新的文件描述符的值恰好与close的相同从而达到重定向的作用。</p><h3 id="分散度和集中写">分散度和集中写</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec* <span class="hljs-built_in">vector</span>, <span class="hljs-type">int</span> count)</span>;<br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec* <span class="hljs-built_in">vector</span>, <span class="hljs-type">int</span> count)</span>;<br></code></pre></td></tr></table></figure><h3 id="sendfile">sendfile</h3><p>sendfile用于在两个文件描述符之间直接传递数据(完全在内核中操作，效率很高，零拷贝)，通常用于将文件通过网络发送。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span>* offset, <span class="hljs-type">size_t</span> count)</span>;<br><span class="hljs-comment">// in_fd必须是支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道</span><br><span class="hljs-comment">// out_fd必须是socket</span><br></code></pre></td></tr></table></figure><h3 id="mmap和munmap">mmap和munmap</h3><p>mmap用于申请一段内存空间，可用于进程间通信的共享内存，也可以将文件直接映射到其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>* start, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-comment">// start允许用户自行指定内存的起始地址，如果为NULL则系统分配，prot用于设置内存段的访问权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>* start, <span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212234249278.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/12/image-20230212234408327.png" /></p><p>其中MAP_SHARED和MAP_PRIVATE互斥。</p><p>mmap失败返回MAP_FAILED((void*)-1)并设置errno</p><h3 id="splice">splice</h3><p>用于在两个文件描述符之间移动数据，同样是零拷贝操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">splice</span><span class="hljs-params">(<span class="hljs-type">int</span> fd_in, <span class="hljs-type">loff_t</span>* off_in, <span class="hljs-type">int</span> fd_out, <span class="hljs-type">loff_t</span>* off_out,</span><br><span class="hljs-params">              <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">// 如果fd_in是管道，那么off_in必须为NULL</span><br><span class="hljs-comment">// fd_in和fd_out必须至少有一个是管道文件描述符，返回移动字节数量。失败时返回-1并设置errno</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/13/image-20230213000202267.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/13/image-20230213000427938.png" /></p><h3 id="tee">tee</h3><p>用于在两个管道文件描述符之间复制数据，也是零拷贝，且不消耗数据，原文件描述符上的数据仍然可以用于后续的读操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">tee</span><span class="hljs-params">(<span class="hljs-type">int</span> fd_in, <span class="hljs-type">int</span> fd_out, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><h3 id="fcntl">fcntl</h3><p>对文件描述符进行各种操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ...)</span>;<br></code></pre></td></tr></table></figure><p>常用cmd如下</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/13/image-20230213104855588.png" /></p><p>在网络编程中，往往可以用来将文件描述符设置为非阻塞的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span><br>&#123;<br>    <span class="hljs-type">int</span> old_option = fcntl(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    fcntl(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option; <span class="hljs-comment">// 以便日后恢复该状态标志</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此外，SIGIO、SIGURG信号必须与某个文件描述符通过fcntl关联后才可使用。</p><p>当被关联的文件描述符可读或可写时，系统将触发SIGIO信号，当被关联的文件描述符(必须是一个socket)上有带外数据可读时，系统将触发SIGURG信号。</p><h2 id="linux服务器程序规范">Linux服务器程序规范</h2><ul><li><p>Linux服务器程序一般以后台进程形式运行。后台进程又称守护进程(daemon)。它没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是init进程(PID为1的进程)。</p></li><li><p>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台进程都在/var/log目录下拥有自己的日志目录。</p></li><li><p>Linux服务器程序一般以某个专门的非root身份运行。比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。</p></li><li><p>Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在/etc目录下</p></li><li><p>Linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录该后台进程的PID。比如syslogd 的PID文件是/var/run/syslogd.pid.</p></li><li><p>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</p></li></ul><h3 id="日志">日志</h3><p>Linux用一个守护进程(daemon)syslogd来处理系统日志，不过现在的Linux系统上使用的都是它的升级版rsyslogd。</p><p>rsyslogd可以接受用户进程和内核的日志。用户进程通过syslog函数生成系统日志，该函数将日志输出到一个AF_UNIX的socket的文件/dev/log中，rsyslogd则监听该文件以获取用户进程的输出。内核日志在老的Linux系统上是通过另一个守护进程rklogd来管理的，rsyslogd则是利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的ringbuffer中，ringbuffer的内容则直接映射到/proc/kmsg文件中。rsyslogd通过读取该文件获得内核日志。</p><p>rsyslogd会对收到的日志进行分发。默认情况下，调试信息会保存至/var/log/debug，普通信息保存至/var/log/messages，内核消息保存至/var/log/kern.log。可以在/etc/rsyslog.conf文件进行配置(主配置文件，子配置文件通常为/etc/rsyslog.d/*.conf)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">syslog</span><span class="hljs-params">(<span class="hljs-type">int</span> priority, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message, ...)</span>;<br><span class="hljs-comment">// priority: 设施值 | 日志级别</span><br><span class="hljs-comment">// 设施值的默认值是LOG_USER</span><br><span class="hljs-comment">// 常见日志级别：</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_EMERG0 <span class="hljs-comment">// 系统不可用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ALERT1 <span class="hljs-comment">// 报警，需要立即采取动作</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_CRIT2 <span class="hljs-comment">// 非常严重的情况</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ERR3 <span class="hljs-comment">// 错误</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_WARNING4 <span class="hljs-comment">// 警告</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_NOTICE5 <span class="hljs-comment">// 通知</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_INFO6 <span class="hljs-comment">// 信息</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_DEBUG7 <span class="hljs-comment">// 调试</span></span><br></code></pre></td></tr></table></figure><p>为了修改日志的格式，可以使用openlog函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">openlog</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ident, <span class="hljs-type">int</span> logopt, <span class="hljs-type">int</span> facility)</span>;<br><span class="hljs-comment">// 并不是用于打开日志，而是为了改变syslog的输出格式，实际上是打开一个文件描述符与syslog进行通信</span><br><span class="hljs-comment">// ident字符串会被添加到之后syslog的每条日志消息的日期和时间之后，往往用于标识程序</span><br><span class="hljs-comment">// logopt有</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_PID0x01<span class="hljs-comment">// 在日志消息中包含PID</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_CONS0x02<span class="hljs-comment">// 如果消息不能记录到日志文件，则打印至终端</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ODELAY0x04<span class="hljs-comment">// 延迟openlog直到第一次调用syslog</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_NDELAY0x08<span class="hljs-comment">// 不延迟openlog</span></span><br><span class="hljs-comment">// facility用于修改syslog的默认设施值</span><br></code></pre></td></tr></table></figure><p>为过滤日志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setlogmask</span><span class="hljs-params">(<span class="hljs-type">int</span> maskpri)</span>;<br><span class="hljs-comment">// maskpri为日志掩码，日志级别大于日志掩码的会被忽略</span><br><span class="hljs-comment">// 返回修改之前的日志掩码</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">closelog</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 关闭打开的用于与syslog通信的文件描述符</span><br></code></pre></td></tr></table></figure><h3 id="用户">用户</h3><p>进程拥有两个用户ID:UID、EUID。用户运行某程序的代码时拥有该程序的EUID权限。同样组也有类似的EGID。EUID为root的进程称为特权进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">uid_t</span> <span class="hljs-title function_">getuid</span><span class="hljs-params">()</span>;<br><span class="hljs-type">uid_t</span> <span class="hljs-title function_">geteuid</span><span class="hljs-params">()</span>;<br><span class="hljs-type">gid_t</span> <span class="hljs-title function_">getgid</span><span class="hljs-params">()</span>;<br><span class="hljs-type">gid_t</span> <span class="hljs-title function_">getegid</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setuid</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> uid)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">seteuid</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> uid)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setgid</span><span class="hljs-params">(<span class="hljs-type">gid_t</span> gid)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setegid</span><span class="hljs-params">(<span class="hljs-type">gid_t</span> gid)</span>;<br></code></pre></td></tr></table></figure><h3 id="进程间关系">进程间关系</h3><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID外还有PGID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>;<br></code></pre></td></tr></table></figure><p>每个进程组都有一个首领进程，其PGID和PID相同。进程组将一直存在，直到其中所有进程都退出，或者加入到其他进程组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">pid_t</span> pgid)</span>;<br><span class="hljs-comment">// 设置目标pid进程所属进程组</span><br><span class="hljs-comment">// 如果pid == pgid则该pid进程被设置为首领进程</span><br><span class="hljs-comment">// 如果pid为0则设置当前进程的PGID为pgid</span><br><span class="hljs-comment">// 如果pgid为0则使用pid作为目标PGID</span><br></code></pre></td></tr></table></figure><p>一个进程只能设置自己或者其子进程的PGID，并且当子进程调用exec系列函数后不能再在父进程中对它设置PGID。</p><p>非首领进程可以创建会话。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">setsid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// 调用进程成为会话的首领，此时该进程是新会话的唯一成员</span><br><span class="hljs-comment">// 新建一个进程组，其PGID就是调用进程的PID，即调用进程成为该组的首领</span><br><span class="hljs-comment">// 调用进程将甩开终端（如果有的话）</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">getsid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span>; <span class="hljs-comment">// 返回PGID</span><br></code></pre></td></tr></table></figure><h3 id="系统资源限制">系统资源限制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getrlimit</span><span class="hljs-params">(<span class="hljs-type">int</span> resource, <span class="hljs-keyword">struct</span> rlimit* rlim)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setrlimit</span><span class="hljs-params">(<span class="hljs-type">int</span> resource, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> rlimit* rlim)</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">rlim_t</span> rlim_cur; <span class="hljs-comment">// 软限制，是建议性的、最好不要超越的，超越可能系统会向进程发送信号以终止其运行</span><br>    <span class="hljs-type">rlim_t</span> rlim_max; <span class="hljs-comment">// 硬限制一般是软限制的上限</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>普通程序可以减小硬限制，只有root身份运行的程序才能增加硬限制。</p><p>可以使用ulimit命令修改当前shell环境下的资源限制，这种修改对该shell启动的所有后续程序有效。也可以通过修改配置文件来修改，这种修改永久生效。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/14/image-20230214205905882.png" /></p><h3 id="改变工作目录和根目录">改变工作目录和根目录</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-comment">// 返回绝对路径，如果大于size，则返回NULL并设置errno为ERANGE</span><br><span class="hljs-comment">// 如果buf为NULL且size非0则会动态分配内存</span><br><span class="hljs-comment">// 成功时返回指针，失败则返回NULL并设置errno</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">chroot</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path)</span>;<br><span class="hljs-comment">// 改变进程根目录</span><br><span class="hljs-comment">// 不改变进程的当前工作目录，所以在chroot之后还需要chdir(&quot;/&quot;)切换至新的根目录</span><br><span class="hljs-comment">// 在调用chroot之后，进程原先打开的文件描述符依然生效</span><br><span class="hljs-comment">// 只有特权进程才能改变根目录</span><br></code></pre></td></tr></table></figure><h3 id="服务器程序后台化">服务器程序后台化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 内部实现逻辑</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">daemonize</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建子进程，关闭父进程，这样可以使程序在后台运行</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// fork fail</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 父进程</span><br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置文件权限掩码，当进程创建新文件时文件的权限将是mode &amp; 0777</span><br>    umask(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//创建新的会话，设置本进程为进程组的首领</span><br>    <span class="hljs-type">pid_t</span> sid = setsid();<br>    <span class="hljs-keyword">if</span> (sid &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 切换工作目录</span><br>    <span class="hljs-keyword">if</span> (chdir(<span class="hljs-string">&quot;/&quot;</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 关闭标准输入、输出、错误输出设备</span><br>    close(STDIN_FILENO);<br>    close(STDOUT_FILENO);<br>    close(STDERR_FILENO);<br>    <br>    <span class="hljs-comment">// 关闭其他已经打开的文件描述符，略</span><br>    <br>    <span class="hljs-comment">// 将标准输入、输出、错误输出都重定向到/dev/null文件</span><br>    open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY); <span class="hljs-comment">// 因为此时open返回的fd是0，恰好是标准输入</span><br>    open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="hljs-comment">// fd是1</span><br>    open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RWWR); <span class="hljs-comment">// fd是2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Linux提供了完成同样功能的库函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#included <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">daemon</span><span class="hljs-params">(<span class="hljs-type">int</span> nochdir, <span class="hljs-type">int</span> noclose)</span>;<br><span class="hljs-comment">// 如果nochdir为0则工作目录被改为&quot;/&quot;，否则继续使用当前工作目录</span><br><span class="hljs-comment">// 如果noclose为0，则标准输入、输出、错误输出都被重定向到/dev/null，否则依然使用原来的设备</span><br></code></pre></td></tr></table></figure><h2 id="高性能服务器程序框架">高性能服务器程序框架</h2><h3 id="io模型">I/O模型</h3><p>socket创建时默认阻塞，可以通过socket系统调用的第二个参数传递SOCK_NONBLOCK或通过fcntl的F_SETFL设置非阻塞。</p><p>socket的基本API中，可能被阻塞的系统调用包括accept、send、recv、connect。</p><p>针对非阻塞的I/O执行的系统调用总是立即返回，如果事件没有立即发生，则这些系统调用返回-1.对于非阻塞的accept、send、recv，事件未发生时errno通常被设置成EAGAIN或EWOULDBLOCK，对于connect则是EINPROGRESS。</p><p>非阻塞I/O通常要与其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p><p>I/O复用是最常用的I/O通知机制，应用程序通过I/O服用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序，如select、poll、epoll_wait。I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们能同时监听多个I/O事件。</p><p>SIGIO信号也可以用来报告I/O事件。可以为一个文件描述符指定宿主进程，当该文件描述符上有事件发生时，宿主进程将捕获到SIGIO信号，SIGIO信号的信号处理函数将被触发。</p><p>异步I/O的读写操作总是立即返回，而不论I/O是否阻塞，I/O读写由内核接管，内核通知I/O完成事件。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215101637318.png" /></p><h3 id="两种高效的事件处理模式">两种高效的事件处理模式</h3><h4 id="reactor">Reactor</h4><p>主线程(I/O处理单元)只负责监听文件描述上是否有事件发生，有的话立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接收新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步I/O模型（以epoll_wait为例）实现的Reactor模式的工作流程是：</p><ol type="1"><li>主线程往epoll内核事件表中注册socket上的读就绪事件</li><li>主线程调用epoll_wait等待socket上有数据可读</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li><li>主线程调用epoll_wait等待socket可写</li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</li></ol><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215105136707.png" /></p><h4 id="proactor">Proactor</h4><p>所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p><p>使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模式的工作流程是：</p><ol type="1"><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册）</li><li>主线程继续处理其他逻辑</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）</li><li>主线程继续处理其他逻辑</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</li></ol><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215110002602.png" /></p><h4 id="用同步io模拟proactor">用同步I/O模拟Proactor</h4><p>以epoll_wait为例</p><ol type="1"><li>主线程往epoll内核事件表中注册socket上的读就绪事件</li><li>主线程调用epoll_wait等待socket上有数据可读</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核时事件中注册socket上的写就绪事件</li><li>主线程调用epoll_wait等待socket可写</li><li>当socket可写时，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果</li></ol><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215111053991.png" /></p><h3 id="两种高效的并发模式">两种高效的并发模式</h3><h4id="半同步半异步half-synchalf-async模式">半同步/半异步(half-sync/half-async)模式</h4><p>同步线程用于处理客户逻辑，异步线程用于处理I/O事件。</p><p>一种变体成为半同步/半反应堆(half-sync/half-reactive)模式</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215111941790.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215112002602.png" /></p><h4id="领导者追随者leaderfollowers模式">领导者/追随者(Leader/Followers)模式</h4><p>多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式</p><p>在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件，而其他线程都是追随者，他们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件。</p><p>包含组件：HandleSet、ThreadSet、EventHandler、ConcreteEvetHandler</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215113831016.png" /></p><p>HandleSet</p><ul><li>Handle用于表示I/O资源</li><li>wait_for_event监听句柄上的I/O事件，将就绪事件通知给领导者线程</li><li>领导者线程调用绑定到Handle上的事件处理器处理事件(绑定由register_handle实现)</li></ul><p>ThreadSet</p><ul><li>线程集中的线程必定处于三种状态之一<ul><li>Leader: 当前处于领导者身份，负责等待句柄集上的I/O事件</li><li>Processing:正在处理事件。领导者检测到I/O事件后可以转移到Processing状态进行处理，并调用promote_new_leader推选新的领导，也可以指定其他追随者来处理事件(EventHandoff)，此时领导者的身份不变。当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导者，则它成为新的领导者，否则它就直接转变为追随者</li><li>Follower:当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务</li></ul></li></ul><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215114703096.png" /></p><p>ConcreteEventHandler</p><ul><li>是事件处理器的派生类，必须重新实现基类的handle_event方法</li></ul><h3 id="有限状态机">有限状态机</h3><h3 id="池">池</h3><p>内存池、进程池、线程池和连接池</p><h2 id="io复用">I/O复用</h2><h3 id="select">select</h3><p>在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds,</span><br><span class="hljs-params">           <span class="hljs-keyword">struct</span> timeval* timeout)</span>;<br><span class="hljs-comment">// nfds: 被监听的文件描述符的总数，通常被设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的</span><br><span class="hljs-comment">// readfds、writefds、exceptfds分别指向可读、可写、异常等事件对应的文件描述符集合，select返回时内核会通过修改它们来通知应用程序哪些文件描述符已经就绪</span><br><span class="hljs-comment">// timeout用来设置select函数的超时时间，内核会修改它来告诉应用程序select等待了多久。如果是NULL则select会一直阻塞，直到某个文件描述符就绪</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> tv_sec;<span class="hljs-comment">// 秒</span><br>    <span class="hljs-type">long</span> tv_usec;<span class="hljs-comment">// 微妙</span><br>&#125;;<br><span class="hljs-comment">// 成功时返回就绪文件描述符总数</span><br><span class="hljs-comment">// 如果select等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fd_set，本质是一个bitmap</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typesizes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FD_SETSIZE 1024</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FD_SETSIZE __FD_SETSIZE</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __fd_mask;<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __NFDBITS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NFDBITS (8 * (int) sizeof(__fd_mask))</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __USE_XOPEN</span><br>   __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FDS_BITS(set) ((set)-&gt;fds_bits)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FDS_BITS(set) ((set)-&gt;__fds_bits)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; fd_set;<br><span class="hljs-comment">// fd_set仅包含一个整型数组，该数组的每个元素的每一位标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定</span><br><span class="hljs-comment">// 在执行select前，1表示监听的文件描述符，在执行select后，1表示就绪的文件描述符</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Linux提供了一系列宏来访问fd_set中的位</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br>FD_ZERO(fd_set* fdset);<span class="hljs-comment">// 清除fdset的所有位</span><br>FD_SET(<span class="hljs-type">int</span> fd, fd_set* fdset);<span class="hljs-comment">// 设置fdset的位fd，即监听fd</span><br>FD_CLR(<span class="hljs-type">int</span> fd, fd_set* fdset);<span class="hljs-comment">// 清除fdset的位fd</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set* fdset)</span>;<span class="hljs-comment">// 测试fdset的位fd是否被设置，即是否就绪</span><br><span class="hljs-comment">// 由于select会修改fd_set，所以每次调用select前都应重新FD_SET</span><br></code></pre></td></tr></table></figure><p>网络编程中，socket可读就绪：</p><ul><li>socket内核接收缓存区中的字节数大于等于其低水位标记SO_RCVLOWAT</li><li>socket通信对方关闭连接</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误(此时可以使用getsockopt来读取和清除该错误)</li></ul><p>socket可写就绪:</p><ul><li>socket内核发送缓冲区中的可用字节数大于等于其低水位标记SO_SNDLOWAT</li><li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号</li><li>socket使用非阻塞connect连接成功或失败(超时)之后</li><li>socket上有未处理的错误(此时可以使用getsockopt来读取和清除该错误)</li></ul><p>异常就绪:</p><ul><li>socket上接收到带外数据</li></ul><h3 id="poll">poll</h3><p>与select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd* fds, <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-comment">// fds是一个数组，nfds指定数组元素个数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">short</span> events;<span class="hljs-comment">// 注册的事件，一系列事件的按位或</span><br>    <span class="hljs-type">short</span> revents;<span class="hljs-comment">// 实际发生的事件，由内核填充</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">nfds_t</span>;<br><span class="hljs-comment">// timeout指定超时事件，单位是毫秒，timeout为-1时poll将阻塞直到某个事件发生</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/15/image-20230215190240547.png" /></p><p>POLLRDNORM、POLLRDBAND、POLLWRNORM、POLLWRBAND由XOPEN规范定义，它们实际上是将POLLIN事件和POLLOUT事件分得更细致，以区别对待普通数据和优先数据，但Linux并不完全支持它们。</p><p>使用POLLRDHUP事件时需要在代码最开始处定义_GNU_SOURCE。</p><h3 id="epoll系列系统调用">epoll系列系统调用</h3><p>epoll是Linux特有的I/O复用函数，使用一组函数完成任务。</p><p>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。</p><p>epoll需要使用一个额外的文件描述符来标识内核中的事件表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><span class="hljs-comment">// size不起作用，只是给内核一个提示，告诉它事件表需要多大</span><br><span class="hljs-comment">// 返回值是其他所有epoll系统调用的第一个参数epfd</span><br></code></pre></td></tr></table></figure><p>通过epoll_ctl对事件表进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event* event)</span>;<br><span class="hljs-comment">// op有3种: EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">__uint32_t</span> events; <span class="hljs-comment">// epoll事件</span><br>    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">// 用户数据</span><br>&#125;;<br><span class="hljs-comment">// epoll支持的事件类型和poll基本相同，只需要在宏前加E就可以了</span><br><span class="hljs-comment">// epoll还有两个额外的事件类型EPOLLET和EPOLLONESHOT，它们对应epoll的高效运作非常关键</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span>* ptr;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">uint32_t</span> u32;<br>    <span class="hljs-type">uint64_t</span> u64;<br>&#125; <span class="hljs-type">epoll_data_t</span>;<br><span class="hljs-comment">// ptr可用来指向与fd相关的用户数据，但由于是union，使用ptr时一般将fd放到ptr指向的空间中</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event* events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-comment">// events是该函数的输出，所有就绪的事件都会被复制到这个数组中</span><br><span class="hljs-comment">// timeout为-1将阻塞</span><br></code></pre></td></tr></table></figure><p>epoll对文件描述符有两种操作模式：LT(电平触发)模式和ET(边沿触发)模式。LT是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。</p><p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理此事件。当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通报该事件，直到事件被处理。</p><p>对于采用ET模式的，通知后，应用程序必须立即处理该事件，后续的epoll_wait调用将不再向应用程序通知该事件。</p><p>从实现上来看，ET和LT的区别在于事件就绪的判断。</p><p>对于LT</p><ul><li>读操作：缓冲区不为空</li><li>写操作：缓冲区不为满</li></ul><p>对于ET</p><ul><li>读操作<ul><li>缓冲区内容变多</li><li>缓冲区不为空且EPOLLIN事件 EPOLL_CTL_MOD</li></ul></li><li>读操作<ul><li>缓冲区内容减少</li><li>缓冲区不为满且EPOLLOUT事件 EPOLL_CTL_MOD</li></ul></li></ul><p>即使使用ET模式，一个socket上的某个事件还是可能被触发多次。一个线程在读取完某个socket上的数据后开始处理这些数据，而数据处理过程中该socket上又有新的数据可读(EPOLLIN再次触发)，此时另一个线程又被唤醒来读取这些数据。于是就出现了两个线程同时操作一个socket的局面。为避免该问题，可以使用EPOLLONESHOT。</p><p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或异常事件，且只触发一次，直到再次使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件(EPOLL_CTL_MOD)。</p><h3 id="三种io复用函数比较">三种I/O复用函数比较</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/16/image-20230216193744103.png" /></p><p>epoll直接将事件结果复制到数组中，避免了遍历，因而更适用连接数量多而活动连接较少的情况。</p><p>select一般有最大值限制，虽然可以修改，但容易产生不可预期的错误。</p><h3 id="io复用的高级应用">I/O复用的高级应用</h3><p>非阻塞的socket进行connect，如果返回时连接还没有建立，将设置errno为EINPROGRESS。在这种情况下，我们应监听这个连接暂时失败的socket上的可写事件。当select、poll等函数返回后，利用getsockopt来读取错误码并清除该socket上的错误。如果错误码是0则连接成功建立，否则失败。但需要注意的是，这方法存在移植性问题。首先，非阻塞的socket可能导致connect始终失败。其次，select对处于EINPROGRESS状态下的socket可能不起作用。最后，对于出错的socket，getsockopt在不同系统上返回值不一样，Linux返回-1，伯克利的UNIX返回0。</p><p>同一个端口可以创建多个socket用于处理不同服务如TCP、UDP。</p><h3 id="超级服务xinetd">超级服务xinetd</h3><p>Linux因特网服务inetd是超级服务，同时管理着多个子服务，即监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版xinetd。它新增了一些控制选项，提高了安全性。</p><p>主配置文件/etc/xinetd.conf，/etc/xinetd.d子配置文件夹</p><p>它的子服务telnet的配置文件/etc/xinetd.d/telnet典型内容如下</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/18/image-20230218103740678.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/18/image-20230218103809851.png" /></p><p>对于其他更多配置，可以参考man。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/18/image-20230218104615208.png" /></p><h2 id="信号">信号</h2><p>信号的产生</p><ol type="1"><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如Ctrl+c通常会给进程发送一个中断信号</li><li>系统异常。比如浮点异常和非法内存访问</li><li>系统状态变化。比如alarm定时器到期将引起SIGALRM信号</li><li>运行Kill命令或调用kill函数</li></ol><p>服务器程序必须处理（或至少忽略）一些常见的信号，以免异常终止。</p><hr /><p>linux使用kill函数发送信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#included <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-comment">// 如果sig为0则不发生任何信号，但依然为检测目标进程或进程组是否存在</span><br><span class="hljs-comment">// 但这种检测方式是不可靠的，一方面这种检测方式不是原子操作，另一方面进程PID的回绕可能导致被检测的PID不是我们期望的进程的PID（回绕是因为linux系统是按顺序循环分配PID的）</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/19/image-20230219221328859.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/19/image-20230219221438951.png" /></p><p>用户可以通过给信号绑定信号处理函数来实现对信号的响应。信号处理函数应该是可重入的，并且由于我们希望同一个信号在多次触发时能够不被屏蔽，信号处理函数应该能够迅速执行完，所以信号处理函数往往只是作为一个中介，将信号值通过管道传递给主循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">__sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">// 信号处理函数的类型</span><br><span class="hljs-comment">// 由于往往是多个信号都绑定同一个信号处理函数，用一个int信号来说明是哪个信号是必要的</span><br><br><span class="hljs-comment">// 自定义信号处理函数</span><br><span class="hljs-comment">// 需要保存恢复errno</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    <span class="hljs-type">int</span> origin_errno = errno;<br>    <span class="hljs-comment">// handling process</span><br>    errno = origin_errno;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了自定义信号处理函数，Linux还提供了两个特殊的标识来进行其他处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/signum.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIG_DFL ((__sighandler_t) 0)</span><br><span class="hljs-comment">// 使用信号的默认处理方式</span><br><span class="hljs-comment">// 结束进程(Term)、忽略信号(Ign)、结束进程并生成核心转储文件(Core)、暂停进程(Stop)、继续进程(Cont)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIG_IGN ((__sighandler_t) 1)</span><br><span class="hljs-comment">// 忽略目标信号</span><br></code></pre></td></tr></table></figure><p>Linux将可用信号(标准信号+POSIX实时信号)都定义在bits/signum.h中</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/19/image-20230219225747499.png" /></p><p>如果程序在执行处于阻塞状态的系统调用时收到信号，并且该信号设置了信号处理函数，则默认情况下系统调用将被中断并且errno被设置为EINTR。可以使用sigaction函数为信号设置SA_RESTART标志以自动重启被该信号中断的系统调用。</p><p>对默认行为是暂停进程的信号(比如SIGSTOP、SIGTTIN)，如果没有设置信号处理函数，它们也是可以中断某些系统调用的(比如connect、epoll_wait)。这是Linux独有的。</p><p>绑定信号处理函数使用signal系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">_sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">_sighandler_t</span> _handler)</span>;<br><span class="hljs-comment">// 返回之前这个sig注册的_handler，也即上一次调用这个sig时传入的_handler，第一次为sig调用是则为SIG_DFL</span><br><span class="hljs-comment">// 错误则返回SIG_ERR，并设置errno</span><br></code></pre></td></tr></table></figure><p>但这个系统调用基本deprecated了，更常用的是sigaction。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction* act, <span class="hljs-keyword">struct</span> sigaction* oact)</span>;<br><span class="hljs-comment">// act指定新的信号处理方式，oact则输出之前的信号处理方式</span><br><span class="hljs-comment">// sig不能是SIGKILL和SIGSTOP</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __USE_POSIX199309</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-type">_sighandler_t</span> sa_handler;<br>        <span class="hljs-type">void</span> (*sa_sigaction) (<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span>*, <span class="hljs-type">void</span>*);<br>    &#125;_sigaction_handler;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sa_handler __sigaction_handler.sa_handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sa_sigaction __sigaction_handler.sa_sigaction</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-type">_sighandler_t</span> sa_handler;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-type">_sigset_t</span> sa_mask; <span class="hljs-comment">// 实际上是一个bitmap，用于设置进程原有信号掩码基础上额外的信号掩码，以指定哪些信号在执行handler的时候应被挂起(没被mask的信号将会打断该信号处理过程)</span><br>    <span class="hljs-type">int</span> sa_flags; <span class="hljs-comment">// 用于设置程序收到信号时的行为</span><br>    <span class="hljs-type">void</span> (*sa_restorer)(<span class="hljs-type">void</span>); <span class="hljs-comment">// deprecated，最好不要使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/19/image-20230219234743231.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/sigset.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _SIGSET_NWORDS (1024 / (8 * sizeof(unsigned long int)))</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __val[_SIGSET_NWORDS];<br>&#125;<span class="hljs-type">__sigset_t</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span>* _set)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span>* _set)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span>* _set, <span class="hljs-type">int</span> _signo)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span>* _set, <span class="hljs-type">int</span> _signo)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigismember</span><span class="hljs-params">(_const <span class="hljs-type">sigset_t</span>* _set, <span class="hljs-type">int</span> _signo)</span>;<br></code></pre></td></tr></table></figure><p>如果只是想要设置/获得进程掩码，可以使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> _how, _const <span class="hljs-type">sigset_t</span>* _set, <span class="hljs-type">sigset_t</span>* _oset)</span>;<br><span class="hljs-comment">// _set为NULL时_oset依然能获取进程当前的信号掩码</span><br></code></pre></td></tr></table></figure><p>设置信号掩码后，被屏蔽的信号将不能被进程接收，但该信号会被暂时挂起。此时如果取消屏蔽，它依然能被进程接收到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span>* <span class="hljs-built_in">set</span>)</span>;<span class="hljs-comment">// 获取进程当前被挂起的信号集</span><br></code></pre></td></tr></table></figure><p>显然，即使该信号被多次触发，也只能被检测到一次。</p><h3 id="网络编程相关信号">网络编程相关信号</h3><h4 id="sighup">SIGHUP</h4><p>当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，这个信号往往是强制要求服务器重读配置文件。</p><h4 id="sigpipe">SIGPIPE</h4><p>默认情况下，往一个读端关闭的管道或者socket连接中写数据将引发SIGPIPE，程序接收到SIGPIPE信号的默认行为是结束进程，所以往往需要在代码中捕获并处理该信号，或者至少忽略它。引起SIGPIPE信号的写操作将设置errno为EPIPE。</p><p>我们可以使用send函数的MSG_NOSIGNAL标志来禁止写操作触发SIGPIPE信号。在这种情况下应使用send函数反馈的errno来判断管道或socket连接的读端是否已经关闭。也可以用I/O复用系统调用来检测。管道的读端关闭时，写端文件描述符上的POLLHUP事件将被触发，socket连接被对方关闭时，socket上的POLLRDHUP事件将被触发。</p><h4 id="sigurg">SIGURG</h4><p>收到带外数据</p><h2 id="定时器">定时器</h2><p>Linux提供了三种定时方法</p><ul><li>socket选项SO_RCVTIMEO和SO_SNDTIMEO</li><li>SIGALRM信号</li><li>I/O复用系统调用的超时参数</li></ul><h3id="socket选项so_rcvtimeo和so_sndtimeo">socket选项SO_RCVTIMEO和SO_SNDTIMEO</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/20/image-20230220131845521.png" /></p><h3 id="sigalrm信号">SIGALRM信号</h3><p>由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。</p><p>如果不需要非常精确，可以使用alarm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span>;<br><span class="hljs-comment">// 取消之前设置的闹钟并设置新的闹钟，返回值为之前闹钟剩下的时间(之前没有设置过则为0)</span><br><span class="hljs-comment">// 如果sedonds为0，则之前设置的闹钟会取消，并将剩下的时间返回</span><br></code></pre></td></tr></table></figure><p>getitimer/setitimer通过which参数提供了更精确的时间选项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-keyword">struct</span> itimerval* value)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setitimer</span><span class="hljs-params">(<span class="hljs-type">int</span> which, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> itimerval* <span class="hljs-keyword">restrict</span> value, <span class="hljs-keyword">struct</span> itimerval* <span class="hljs-keyword">restrict</span> ovalue)</span>;<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>which</th><th>description</th></tr></thead><tbody><tr class="odd"><td>ITIMER_REAL</td><td>以系统真实的时间来计算，它送出SIGALRM信号</td></tr><tr class="even"><td>ITIMER_VIRTUAL</td><td>以该进程在用户态下花费的时间来计算，它送出SIGVTALRM信号</td></tr><tr class="odd"><td>ITIMER_PROF</td><td>以该进程在用户态下和内核态下花费的时间来计算，它送出SIGPROF信号</td></tr></tbody></table><h3 id="io复用系统调用的超时参数">I/O复用系统调用的超时参数</h3><p>如果epoll_wait的返回值等于0，则过去了timeout时间，否则经过了(end -start) * 1000ms。</p><h3 id="高性能定时器">高性能定时器</h3><h4 id="时间轮timingwheel">时间轮(TimingWheel)</h4><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/20/image-20230220144825625.png" /></p><p>指针指向当前所在的时间槽slot，每个tick(slot interval,si)移动到下一个槽。每个槽都是一个定时器链表。指针每指向一个槽，都要遍历该槽里的所有定时器。指针花费N*si走完一个round，不是所有定时器都在一个round内的，所以每个定时器还有个round变量记录还剩几个round才到时间，如果指针指向定时器所在的槽且定时器的round为0则表明时间到。</p><p>若当前指针指向槽cs，要添加一个定时时间为ti的定时器，则该定时器应被插入槽ts的链表中，有ts = ( cs + ( ti / si ) ) % N如果想要提高定时精度，需要si够小；要提高执行效率，需要N购大。</p><p>可以实现多层级的时间轮控制不同粒度的定时。</p><h4 id="时间堆">时间堆</h4><p>每次都以所有定时器中超时值最小的定时器的超时值发出SIGALRM，一旦SIGALRM，则最小的定时器必然到期。我们可以处理该定时器然后找出下一个超时时间最小的定时器并设置。最小堆非常适合于解决该问题。</p><h2 id="高性能io框架库libevent">高性能I/O框架库Libevent</h2><p>ACE、ASIO、Libevent都是开源的优秀的I/O框架库，其中Libevent相对轻量级。</p><p>基于Reactor模式实现的I/O框架库包含组件：句柄、事件多路分发器(EventDemultiplexer)、事件处理器(EventHandler)和具体的事件处理器(ConcreteEventHandler)。</p><p>事件源：I/O事件、信号和定时事件</p><p>一个事件源通常和一个句柄绑定在一起。当内核检测到事件发生时，它将通过句柄来通知应用程序这一事件。Linux的I/O事件的句柄是文件描述符，信号事件的句柄是信号值。</p><p>I/O框架库一般将系统支持的各种I/O复用系统调用封装成统一的接口，称为事件多路分发器。它的demultiplex方法是等待事件的核心函数。</p><p>当事件多路分发器检测到有事件发生时，通过句柄通知应用程序。事件处理器需与句柄绑定。</p><p>事件处理器一般提供一个get_handle方法，它返回与该事件处理器关联的句柄。</p><p>Reactor提供几个主要方法</p><ul><li>handler_events:执行事件循环。重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器</li><li>register_handler:调用事件多路分发器的register_event方法来往事件多路分发器中注册一个事件</li><li>remove_handler:调用事件多路分发器的remove_event方法来删除事件多路分发器中的一个事件。</li></ul><p>Libevent跨平台支持、统一事件源、线程安全，基于Reactor模式实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;event2/event.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> evsignal_new(b, x, cb, arg) \</span><br><span class="hljs-meta">event_new((b), (x),  EV_SIGNAL|EV_PERSIST, (cb), (arg))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> evtimer_new(b, cb, arg)event_new((b), -1, 0, (cb), (arg))</span><br><span class="hljs-keyword">struct</span> event* <span class="hljs-title function_">event_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base* base, <span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-type">short</span> events,</span><br><span class="hljs-params">                       <span class="hljs-type">void</span> (*cb)(<span class="hljs-type">evutil_socket_t</span>, <span class="hljs-type">short</span>, <span class="hljs-type">void</span>*), <span class="hljs-type">void</span>* arg)</span>;<br><span class="hljs-comment">// fd是句柄</span><br><span class="hljs-comment">// events如下</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_TIMEOUT0x01 <span class="hljs-comment">// 定时</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_READ0x02 <span class="hljs-comment">// 可读</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_WRITE0x04 <span class="hljs-comment">// 可写</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_SIGNAL0x08 <span class="hljs-comment">// 信号</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_PERSIST0x10 <span class="hljs-comment">// 永久。事件被触发后，自动重新对这个event调用event_add</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_ET0x20 <span class="hljs-comment">// 边沿触发，需要I/O复用系统调用支持，比如epoll</span></span><br><span class="hljs-comment">// cb是回调函数，相当于事件处理器的handle_event，arg是传给它的参数</span><br><span class="hljs-comment">// 返回事件处理器对象</span><br></code></pre></td></tr></table></figure><p>事件由事件多路分发器管理，事件处理器则由事件队列管理。</p><hr /><p>总体流程</p><ol type="1"><li>调用event_init创建event_base对象，相当于Reactor实例</li><li>用event_new（evsignal_new、evtimer_new）创建事件处理器</li><li>用event_add将事件处理器添加到注册事件队列中，并将该事件处理器对应的事件添加到事件多路分发器中，相当于register_handler</li><li>调用event_base_dispatch执行事件循环</li><li>使用*_free来释放系统资源</li></ol><hr /><p>struct event有许多指针，这些指针将多个structevent串成了多个尾队列。<code>ev_next</code>形成注册事件队列；<code>ev_active_next</code>形成活动事件队列（活动事件队列不止一个，不同优先级的事件处理器被激活后插入不同的活动事件队列。在事件循环中，Reactor将按优先级从高到低遍历所有活动事件队列）；联合体ev_timeout_pos在通用定时器（即简单链表实现的）中用<code>ev_next_with_common_timeout</code>形成通用定时器队列，在时间堆中用<code>min_heap_idx</code>指示位置。一个定时器是否要采用通用定时器取决于其超时值大小；联合体_ev用<code>ev_ioev_io_next</code>形成具有相同文件描述符的I/O事件队列，用<code>ev_signal.ev_signal_next</code>形成信号事件队列，<code>ev_signal.ev_ncalls</code>指定信号事件发生时Reactor需要执行多少次该事件对应的事件处理器的回调函数（在启用<code>ev_flags</code>的EV情况下），<code>ev_pncalls</code>要么NULL，要么指向它。</p><p><code>ev_res</code>记录当前激活事件的类型。</p><p><code>ev_flags</code>如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVLIST_TIMEOUT 0x01 <span class="hljs-comment">// 事件处理器从属于通用定时器队列或时间堆</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVLIST_INSERTED 0x02 <span class="hljs-comment">// 事件处理器从属于事件队列</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVLIST_SIGNAL0x04 <span class="hljs-comment">// 没有使用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVLIST_ACTIVE0x08 <span class="hljs-comment">// 事件处理器从属于活动事件队列</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVLIST_INTERNAL 0x10 <span class="hljs-comment">// 内部使用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVLIST_INIT0x80 <span class="hljs-comment">// 事件处理器已经被初始化</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EVLIST_ALL(0xf000 | 0x9f)<span class="hljs-comment">// 定义所有标志</span></span><br></code></pre></td></tr></table></figure><p><code>ev_pri</code>为优先级，越小优先级越高</p><p><code>ev_closure</code>定义执行回调函数时的行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_CLOSURE_NONE 0 <span class="hljs-comment">// 默认行为</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_CLOSURE_SIGNAL1<span class="hljs-comment">// 执行信号事件处理器的回调函数时，调用ev_ncalls次回调函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_CLOSURE_PERSIST 2<span class="hljs-comment">// 执行完回调函数后，再次将事件处理器加入注册事件队列中</span></span><br></code></pre></td></tr></table></figure><p><code>ev_timeout</code>仅对定时器有效</p><h2 id="多进程编程">多进程编程</h2><h3 id="fork">fork</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// 在父进程中返回的是子进程的PID，在子进程中返回0</span><br><span class="hljs-comment">// 复制当前进程，在内核进程表中创建一个新的进程表项，新的进程表项有很多属性和原进程相同，如堆指针、栈指针和标志寄存器的值，但也有很多属性被赋予了新的值，比如PID，信号位图被清除</span><br><span class="hljs-comment">// 子进程代码和父进程完全相同，同时还会复制父进程的数据（堆数据、栈数据、静态数据），数据的复制采用的是copy on write</span><br><span class="hljs-comment">// 父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加一。父进程的用户根目录、当前工作目录等的引用计数也会加一</span><br></code></pre></td></tr></table></figure><h3 id="exec系列系统调用">exec系列系统调用</h3><p>替换当前进程映像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span>** environ;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ...)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* arg, ..., <span class="hljs-type">char</span>* <span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">char</span>* <span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span>* <span class="hljs-type">const</span> envp[])</span>;<br><span class="hljs-comment">// path指定可执行文件的完整路径，file指定文件名，该文件的具体位置在PATH中搜寻</span><br><span class="hljs-comment">// arg、argv被传递给新程序的main</span><br><span class="hljs-comment">// envp设置新程序的环境变量，如果未设置，新程序会使用由全局变量environ指定的环境变量</span><br><span class="hljs-comment">// 一般情况下不返回，因为如果没出差则原程序exec调用之后的代码都不会执行，已经被完全替换。出错时返回-1并设置errno</span><br><span class="hljs-comment">// 不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性</span><br></code></pre></td></tr></table></figure><h3 id="处理僵尸进程">处理僵尸进程</h3><p>父进程一般需要跟踪子进程的退出状态。当子进程结束运行后，内核不会立即释放该进程的进程表表项。在子进程结束运行之后，父进程读取其状态之前，称该子进程处于僵尸态。父进程先于子进程结束，子进程的PPID被设置为1，即init进程，init进程接管了该子进程，并等待其结束，该状态子进程也称为僵尸态。停留在僵尸态的子进程依然占据着内核资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-comment">// 等待子进程的结束，并获取子进程的返回信息</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>* stat_loc)</span>;<br><span class="hljs-comment">// 阻塞，等待任一个子进程结束，返回结束运行的子进程的PID并将子进程的退出状态信息存储于stat_loc参数指向的内存中</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span>* stat_loc, <span class="hljs-type">int</span> options)</span>;<br><span class="hljs-comment">// 只等待由pid指定的子进程，如果pid==-1则等待任一个子进程结束</span><br><span class="hljs-comment">// 如果options为WNOHANG则非阻塞，调用时目标子进程还没有结束或意外结束则返回0，否则返回该子进程的PID。</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/23/image-20230223220730369.png"alt="退出状态信息" /><figcaption aria-hidden="true">退出状态信息</figcaption></figure><p>在事件已经发生的情况下执行非阻塞调用才能提高程序的效率。子进程在结束时会给父进程发送SIGCHLD信号，父进程可以通过该信号得知子进程是否结束，并在知道结束后调用waitpid以彻底结束它。</p><h3 id="进程间通信">进程间通信</h3><h4 id="用管道在父子间通信">用管道在父子间通信</h4><p>fork后原先打开的管道文件描述符<code>fd[0]</code>和<code>fd[1]</code>依然处于打开状态，由于一对管道只能保证一个方向的数据传输，所以父进程和子进程必须有一个关闭<code>fd[0]</code>，另一个关闭<code>fd[1]</code>。</p><h4 id="无关联进程之间的通信">无关联进程之间的通信</h4><p>FIFO管道</p><p>有一种特殊的管道称为FIFO（先进先出），也叫命名管道。它能用于无关联进程之间的通信，但网络编程中使用不多。</p><h5 id="信号量semaphore">信号量（Semaphore）</h5><p>Linux/Unix常用P（传递）、V（释放）来代替信号量中的wait、signal。</p><p>对于信号量SV</p><ul><li>P(SV):如果SV的值大于0，则减1，继续执行；如果为0，则挂起进程的执行</li><li>V(SV):如果有其他进程因为等待SV而挂起，就唤醒一个被挂起的进程；如果没有，则将SV加一</li></ul><h6 id="semget系统调用">semget系统调用</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">int</span> num_sems, <span class="hljs-type">int</span> sem_flags)</span>;<br><span class="hljs-comment">// key用来唯一标识一个全局的信号量集，要通过信号量通信的进程需要使用相同的key来创建/获取该信号量</span><br><span class="hljs-comment">// sem_flags低9位表示权限，和open的mode参数相同。IPC_CREAT是一个高位标志，表示创建新的信号量集，但不能保证信号量是还不存在的。使用IPC_CREATE | IPC_EXCL来确保是一组新的唯一的信号量集，它会使得如果产生的信号量已经存在，semget会返回-1并设置errno为EEXIST。这与open的O_CREAT|O_EXCL类似。</span><br><span class="hljs-comment">// 将key设为IPC_PRIVATE（注意不是sem_flags）时，sem_flags的低9位以外的值全被忽略，生成一个新的信号量集（更准确的说法是IPC_NEW，但由于历史遗留问题）</span><br><span class="hljs-comment">// 成功时返回信号量集的标识符</span><br></code></pre></td></tr></table></figure><p><code>semget</code>函数在创建信号量集时会对与之关联的内核数据结构体semid_ds执行创建并初始化操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-comment">// 描述IPC对象（信号量、共享内存、消息队列）的权限</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_perm</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">key_t</span> key;<br>    <span class="hljs-type">uid_t</span> uid; <span class="hljs-comment">// 被初始化为调用进程的有效用户/组ID</span><br>    <span class="hljs-type">gid_t</span> gid;<br>    <span class="hljs-type">uid_t</span> cuid;<br>    <span class="hljs-type">gid_t</span> cgid;<br>    <span class="hljs-type">mode_t</span> mode; <span class="hljs-comment">// 初始化时低9为设置成sem_flags的低9位</span><br>    <span class="hljs-comment">// 省略其他</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_perm</span> <span class="hljs-title">sem_perm</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> sem_nsems; <span class="hljs-comment">// 信号量数目，初始化成num_sems</span><br>    <span class="hljs-type">time_t</span> sem_otime; <span class="hljs-comment">// 最后一次调用semop的时间，初始化为0</span><br>    <span class="hljs-type">time_t</span> sem_ctime; <span class="hljs-comment">// 最后一次调用semctl的时间，初始化为当前的系统时间</span><br>    <span class="hljs-comment">// 省略其他</span><br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="semop系统调用">semop系统调用</h6><p>与每个信号量关联的一些重要的内核变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> semval;<span class="hljs-comment">// 信号量的值</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> semzcnt;<span class="hljs-comment">// 等待信号量值变为0的进程数量</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> semncnt;<span class="hljs-comment">// 等待信号量值增加的进程数量</span><br><span class="hljs-type">pid_t</span> sempid;<span class="hljs-comment">// 最后一次指向semop操作的进程ID</span><br></code></pre></td></tr></table></figure><p><code>semop</code>对信号量的操作实际上就是对这些内核变量的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semop</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id, <span class="hljs-keyword">struct</span> sembuf* sem_ops, <span class="hljs-type">size_t</span> num_sem_ops)</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_num; <span class="hljs-comment">// 信号集中信号量的编号</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_op;<span class="hljs-comment">// 操作类型，正数、0、负数</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_flg;<span class="hljs-comment">// 可选值：IPC_NOWAIT和SEM_UNDO，SEM_UNDO表示当进程退出时，UNDO当前在进行的semop</span><br>&#125;;<br><span class="hljs-comment">// sem_ops和num_sem_ops组成一个数组，semop对数组元素依次操作，该过程是原子操作，失败的时候所有操作都不被执行。</span><br><span class="hljs-comment">// 如果sem_op大于0，则semop将被操作的信号量的值semval增加sem_op。该操作要求调用进程在对被操作信号量集上拥有写权限。此时若设置了SEM_UNDO，则系统将更新进程的semadj变量</span><br><span class="hljs-comment">// 如果sem_op等于0，表示这是一个“等待0”操作。该操作要求调用进程对呗操作信号量拥有读权限。如果此时信号量的值是0，则调用立即成功返回。如果信号量的值不是0，则semop操作失败或者阻塞进程以等待信号量变为0（根据IPC_NOWAIT是否设置，失败会设置errno为EAGAIN）。如果未指定IPC_NOWAIT，则信号量semzcnt加1，进程被投入睡眠，知道下列3个条件之一发生：</span><br><span class="hljs-comment">// 信号量的值变为0，此时系统将该信号量semzcnt减1.</span><br><span class="hljs-comment">// 被操作的信号量所在的信号量集被进程移除，此时，semop调用失败返回，errno被设置为EIDRM。</span><br><span class="hljs-comment">// 调用被信号中断，此时，semop调用失败返回，errno被设置EINTR，同时系统将信号量的semzcnt减1。</span><br><span class="hljs-comment">// 如果sem_op小于0，则表示对信号量进行减操作。即期望获得信号量，该操作要求调用进程对被操作信号量集拥有写权限。如果信号的值semval大于或者等于sem_op的绝对值，则semop操作成功，调用进程立即获得信号量，并且系统将该信号量的semval减去sem_op的绝对值。此时如果设置了SEM_UNDO标志，则系统将更新进程的semadj变量。如果信号量的值semval小于sem_op的绝对值，则semop失败返回或者阻塞等待信号量可用。在这种情况下，IPC_NOWAIT的标志被指定时，semop立即返回一个错误，并设置errno为EAGAIN。如果为指定IPC_NOWAIT标志，则信号量的semncnt加1，进程被投入睡眠知道下面三个条件满足：</span><br><span class="hljs-comment">// 信号量的值semval大于等于sem_op的绝对值，此时信号量的semncnt减1，并将semval减去sem_op的绝对值。</span><br><span class="hljs-comment">// 被操作信号量所在的信号量集被进程删除，调用返回失败，errno被设置为EIDRM；</span><br><span class="hljs-comment">// 调用被信号中断，此时semop调用失败返回，errno被设置为EINTR，同时系统将semncnt值减1。</span><br></code></pre></td></tr></table></figure><h6 id="semctl系统调用">semctl系统调用</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">semctl</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id, <span class="hljs-type">int</span> sem_number, <span class="hljs-type">int</span> command, ...)</span>;<br><span class="hljs-comment">// sem_id是信号集，sem_number是被操作信号量在信号集中的下标</span><br><span class="hljs-comment">// 第四个参数类型由用户自己定义，但sys/sem.h给出了推荐格式</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">semun</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> val;<span class="hljs-comment">// 用于SETVAL命令</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semid_ds</span>* <span class="hljs-title">buf</span>;</span><span class="hljs-comment">// 用于IPC_STAT和IPC_SET命令</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>* <span class="hljs-built_in">array</span>;<span class="hljs-comment">// 用于GETALL和SETALL命令</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seminfo</span>* __<span class="hljs-title">buf</span>;</span><span class="hljs-comment">// 用于IPC_INFO命令</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seminfo</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> semmap;<span class="hljs-comment">// Linux内核没有使用</span><br>    <span class="hljs-type">int</span> semmni;<span class="hljs-comment">// 系统最多可以拥有的信号量集数目</span><br>    <span class="hljs-type">int</span> semmns;<span class="hljs-comment">// 系统最多可以拥有的信号量数目</span><br>    <span class="hljs-type">int</span> semmnu;<span class="hljs-comment">// Linux内核没有使用</span><br>    <span class="hljs-type">int</span> semmsl;<span class="hljs-comment">// 一个信号量集最多允许包含的信号量数目</span><br>    <span class="hljs-type">int</span> semopm;<span class="hljs-comment">// semop一次能最多执行的sem_op操作数目</span><br>    <span class="hljs-type">int</span> semume;<span class="hljs-comment">// Linux内核没有使用</span><br>    <span class="hljs-type">int</span> semusz;<span class="hljs-comment">// sem_undo结构体的大小</span><br>    <span class="hljs-type">int</span> semvmx;<span class="hljs-comment">// 最大允许的信号量值</span><br>    <span class="hljs-type">int</span> semaem;<span class="hljs-comment">// 最多允许的UNDO次数（带SEM_UNDO标志的semop操作的次数）</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/24/image-20230224101657459.png"alt="semctl的command参数" /><figcaption aria-hidden="true">semctl的command参数</figcaption></figure><blockquote><p>除GETNCNT、GETPID、GETVAL、GETZCNT、SETVAL的其他操作都是针对整个信号量集的，此时semctl的参数sem_num被忽略</p></blockquote><h5 id="共享内存">共享内存</h5><p>共享内存是效率最高的IPC，但是往往需要配合一些其他手段来防止竞态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>; <span class="hljs-comment">// 创建一段新的共享内存，或者获取一段已经存在的共享内存</span><br><span class="hljs-comment">// 如果创建新的共享内存，size必须被指定。如果是获取已经存在的共享内存，则size可以设置为0</span><br><span class="hljs-comment">// shmflg除了支持IPC_CREATE、IPC_EXCL外还支持SHM_HUGETLB（类似mmap的MAP_HUGETLB，系统将使用大页面来为共享内存分配空间）、SHM_NORESERVE（类似mmap的MAP_NORESERVE，不为共享内存保留交换分区（swap空间），这样，当物理内存不足时，对该共享内存执行写操作将触发SIGSEGV信号）</span><br><span class="hljs-comment">// 返回共享内存标识符</span><br><span class="hljs-comment">// 创建共享内存时共享内存的所有字节都被初始化为0，与之关联的内核数据结构shmid_ds被创建和初始化</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shmid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_perm</span> <span class="hljs-title">shm_perm</span>;</span> <span class="hljs-comment">// 共享内存的操作权限</span><br>    <span class="hljs-type">size_t</span> shm_segsz;<span class="hljs-comment">// 共享内存大小，初始化为size</span><br>    <span class="hljs-type">__time_t</span> shm_atime;<span class="hljs-comment">// 对这段内存最后一次调用shmat的时间，初始化为0</span><br>    <span class="hljs-type">__time_t</span> shm_dtime;<span class="hljs-comment">// 对这段内存最后一次调用shmdt的时间，初始化为0</span><br>    <span class="hljs-type">__time_t</span> shm_ctime;<span class="hljs-comment">// 对这段内存最后一次调用shmctl的时间，初始化为当前时间</span><br>    <span class="hljs-type">__pid_t</span> shm_cpid;<span class="hljs-comment">// 创建者的PID</span><br>    <span class="hljs-type">__pid_t</span> shm_lpid;<span class="hljs-comment">// 最后一次执行shmat或shmdt操作的进程的PID，初始化为0</span><br>    <span class="hljs-type">shmatt_t</span> shm_nattach;<span class="hljs-comment">// 目前关联到此共享内存的进程数量，初始化为0</span><br>    <span class="hljs-comment">// 省略其他</span><br>&#125;;<br><span class="hljs-comment">// shm_perm初始化和sem_perm类似</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shm_id, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* shm_addr, <span class="hljs-type">int</span> shmflg)</span>; <span class="hljs-comment">// 在使用前需要attach到进程的某块地址空间</span><br><span class="hljs-comment">// 如果shm_addr为NULL则由操作系统选择，这能保证代码的可移植性</span><br><span class="hljs-comment">// 如果shm_addr非空且SHM_RND未设置，则被关联到指定地址</span><br><span class="hljs-comment">// 如果shm_addr非空且设置了SHM_RND，被关联的地址是shm_addr-(shm_addr % SHMLBA)，即向下圆整到离shm_addr最近的SHMLBA的整数倍地址处，SHMLBA（Segment Low Boundary Address Multiple）是内存页面（PAGE_SIZE）的整数倍，现在Linux内核中恰好相等。</span><br><span class="hljs-comment">// 除了SHM_RND，shmflg还支持SHM_RDONLY（只读）、SHM_REMAP（如果地址shmaddr已经被关联到一段共享内存上，则取消之前关联的，重新关联）、SHM_EXEC（执行权限，对共享内存而言，执行权限实际上和读权限一样）</span><br><span class="hljs-comment">// 成功时返回被关联到的地址，并修改内核数据结构shmid_ds（sh_nattach加一，shm_lpid设置为调用进程的PID、shm_atime设置为当前的时间）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* shm_addr)</span>;<span class="hljs-comment">// 使用后需要detach</span><br><span class="hljs-comment">// 成功返回0，同样修改shm_nattach、shm_lpid，此外设置shm_dtime为当前时间</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shm_id, <span class="hljs-type">int</span> command, <span class="hljs-keyword">struct</span> shmid_ds* buf)</span>;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/24/image-20230224111606441.png"alt="shmctl支持的命令" /><figcaption aria-hidden="true">shmctl支持的命令</figcaption></figure><h6 id="共享内存的posix方法">共享内存的POSIX方法</h6><p>利用mmap和它的MAP_ANONYMOUS可以实现父子进程之间的匿名内存共享。</p><p>通过打开同一个文件，mmap也可以实现无关进程之间的内存共享。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-comment">// 在进行mmap前，需要先通过shm_open打开shmfd</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">shm_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> oflag, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">// 从可移植性考虑，name应是&#x27;/&#x27;+basename，长度不超过NAME_MAX</span><br><span class="hljs-comment">// flg与open完全相同，O_RDONLY、O_RDWR、O_CREAT（不存在则创建，低9位为权限，初始长度为0）、O_TRUNC（如果已经存在则截断使其长度为0）</span><br><br><span class="hljs-comment">// 之后使用mmap进行内存的共享，失败返回MAP_FAILED</span><br><span class="hljs-comment">// munmap</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shm_unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span>;<br><span class="hljs-comment">// 将name参数指定的共享内存对象标记为待删除，当所有使用该共享内存对象的进程都使用munmap将它从进程中分离之后，系统将销毁这个共享内存对象所占据的资源</span><br><span class="hljs-comment">// 编译时需-lrt</span><br></code></pre></td></tr></table></figure><h5 id="消息队列">消息队列</h5><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式，每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">int</span> msgflg)</span>;<br><span class="hljs-comment">// 参数与semget相同</span><br><span class="hljs-comment">// 如果用于创建消息队列，则与之关联的内核数据结构msqid_ds将被创建并初始化</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msqid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_perm</span> <span class="hljs-title">msg_perm</span>;</span> <span class="hljs-comment">// 消息队列的操作权限</span><br>    <span class="hljs-type">time_t</span> msg_stime;<span class="hljs-comment">// 最后一次调用msgsnd的时间</span><br>    <span class="hljs-type">time_t</span> msg_rtime;<span class="hljs-comment">// 最后一次调用msgrcv的时间</span><br>    <span class="hljs-type">time_t</span> msg_ctime;<span class="hljs-comment">// 最后一次被修改的时间</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __msg_cbytes;<span class="hljs-comment">// 消息队列中已有的字节数</span><br>    <span class="hljs-type">msgqnum_t</span> msg_qnum;<span class="hljs-comment">// 消息队列中已有的消息数</span><br>    <span class="hljs-type">msglen_t</span> msg_qbytes;<span class="hljs-comment">// 消息队列允许的最大字节数</span><br>    <span class="hljs-type">pid_t</span> msg_lspid;<span class="hljs-comment">// 最后执行msgsnd的进程的PID</span><br>    <span class="hljs-type">pid_t</span> msg_lrpid;<span class="hljs-comment">// 最后执行msgrcv的进程的PID</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* msg_ptr, <span class="hljs-type">size_t</span> msg_sz, <span class="hljs-type">int</span> msgflg)</span>;<br><span class="hljs-comment">// msgflg通常仅支持IPC_NOWAIT标志</span><br><span class="hljs-comment">// 默认情况下，发送消息时如果消息队列满了，则msgsnd将阻塞，但如果IPC_NOWAIT标志被指定，则msgsnd将立即返回并设置errno为EAGAIN</span><br><span class="hljs-comment">// 处于阻塞状态的msgsnd调用可能被两种异常情况终端：</span><br><span class="hljs-comment">// 消息队列被移除，此时msgsnd调用将立即返回并设置errno为EIDRM</span><br><span class="hljs-comment">//程序接收到信号，此时msgsnd调用将立即返回并设置errno为EINTR</span><br><span class="hljs-comment">// msg_ptr参数指向一个准备发送的消息，消息必须被定义为如下类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msgbuf</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> mtype; <span class="hljs-comment">// 必须是正整数</span><br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">512</span>];<br>&#125;;<br><span class="hljs-comment">// 成功时将修改内核数据结构msqid_ds，将msg_qnum加1，将msg_lspid设置为调用进程的PID，将msg_stime设置为当前时间</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span>* msg_ptr, <span class="hljs-type">size_t</span> msg_sz, <span class="hljs-type">long</span> <span class="hljs-type">int</span> msgtype, <span class="hljs-type">int</span> msgflg)</span>;<br><span class="hljs-comment">// msgtype == 0则读取消息队列中的第一个消息</span><br><span class="hljs-comment">// msgtype &gt; 0 则读取消息队列中第一个类型为msgtype的消息（除非指定了MSG_EXCEPT）</span><br><span class="hljs-comment">// msgtype &lt; 0 则读取消息队列中第一个类型值比msgtype的绝对值小的消息</span><br><span class="hljs-comment">// msgflg支持IPC_NOWAIT（没有消息设置ENOMSG）、MSG_EXCEPT（msgtype&gt;0则接收消息队列中第一个非msgtype类型的消息）、MSG_NOERROR（如果消息数据部分的长度超过了msg_sz就将它阶段）</span><br><span class="hljs-comment">// 处于阻塞状态的msgrcv同样会被两种异常情况中断</span><br><span class="hljs-comment">// 成功时将修改内核数据结构msqid_ds，将msg_qnum减1，将msg_lrpid设置为调用进程的PID，将msg_rtime设置为当前时间</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">msgctl</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">int</span> command, <span class="hljs-keyword">struct</span> msqid_ds* buf)</span>;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/24/image-20230224141703485.png"alt="msgctl支持的command" /><figcaption aria-hidden="true">msgctl支持的command</figcaption></figure><h4 id="ipc命令">IPC命令</h4><p><code>ipcs</code>命令可以查看当前系统上有哪些共享资源实例</p><p>可以使用<code>ipcrm</code>命令删除遗留在系统中的共享资源</p><h3 id="进程间传递文件描述符">进程间传递文件描述符</h3><p>只要传递文件描述符的值就好了</p><h2 id="多线程编程">多线程编程</h2><h3 id="线程">线程</h3><p>NPTL是目前Linux的标准线程库，内核线程与用户线程1:1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span>* thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr,</span><br><span class="hljs-params">                  <span class="hljs-type">void</span>* (*start_routine)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span>* arg)</span>;<br><span class="hljs-comment">// attr传递NULL表示使用默认线程属性</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/pthreadtypes.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><br><span class="hljs-comment">// C++中使用它时，start_routine必须是static函数</span><br></code></pre></td></tr></table></figure><p>一个用户可以打开的线程数量不能超过RLIMIT_NPROC软资源限制。系统上所有用户能创建的线程总数也不能超过/proc/sys/kernel/threads-max内核参数所定义的值。</p><p>线程函数在结束时最好调用如下函数以确保安全、干净地退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#inclue <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>* retval)</span>;<br></code></pre></td></tr></table></figure><p><code>pthread_exit</code>通过retval参数项线程的回收者传递其退出信息，它永远不会失败。</p><p>一个进程中的所有线程都可以调用<code>pthread_join</code>函数来回收其他线程（前提是目标线程是可回收的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span>** retval)</span>;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/24/image-20230224150333563.png"alt="pthread_join可能引发的错误码" /><figcaption aria-hidden="true">pthread_join可能引发的错误码</figcaption></figure><p>希望异常终止一个线程（取消线程）时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><p>接收到取消请求的目标线程可以决定是否允许被取消以及如何取消</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_setcancelstate</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span>* oldstate)</span>;<br><span class="hljs-comment">// 设置是否允许取消</span><br><span class="hljs-comment">// PTHREAD_CANCEL_ENABLE 允许被取消，是默认值</span><br><span class="hljs-comment">// PTHREAD_CANCEL_DISABLE 禁止被取消。这种情况下，如果一个线程收到取消请求，它会将请求挂起，直到该线程允许被取消</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_setcanceltype</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">int</span> *oldtype)</span>;<br><span class="hljs-comment">// 设置如何取消</span><br><span class="hljs-comment">// PTHREAD_CANCEL_ASYNCHRONOUS 收到取消请求后立即取消</span><br><span class="hljs-comment">// PTHREAD_CANCEL_DEFERRED 允许推迟，直到它调用了所谓的取消点函数（pthread_join、pthread_testcancel、pthread_cond_wait、pthread_cond_timedwait、sem_wait、sigwait，根据POSIX标准，其他可能阻塞的系统调用比如read、wait也可以成为取消点，不过为了安全起见，我们最好在可能会被取消的代码中调用pthread_testcancel函数以设置取消点）</span><br></code></pre></td></tr></table></figure><p>pthread_attr_t定义了一套完整的线程属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/pthreadtypes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SIZEOF_PTHREAD_ATTR_T 36</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];<br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align; <span class="hljs-comment">// 使得sizeof(long int)字节对齐</span><br>&#125;<span class="hljs-type">pthread_attr_t</span>;<br></code></pre></td></tr></table></figure><p>线程库定义了一系列函数来操作它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getdetachstate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr, <span class="hljs-type">int</span>* detachstate)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr, <span class="hljs-type">int</span> detachstate)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getstackaddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr, <span class="hljs-type">void</span>** stackaddr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setstackaddr</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr, <span class="hljs-type">void</span>* stackaddr)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getstacksize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr, <span class="hljs-type">size_t</span>* stacksize)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setstacksize</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">void</span>* stackaddr , <span class="hljs-type">size_t</span> stacksize)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getguardsize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_addr_t</span>* __attr , <span class="hljs-type">size_t</span>* guardsize)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setguardsize</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">size_t</span> guardsize)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getschedparam</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-keyword">struct</span> sched_param* param)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setschedparam</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sched_param* param)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getschedpolicy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">int</span>* policy)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setschedpolicy</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">int</span> policy)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getinheritsched</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">int</span>* inherit)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setinheritsched</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">int</span> inherit)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_getscope</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">int</span>* scope)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_attr_setscope</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span>* attr , <span class="hljs-type">int</span> scope)</span>;<br></code></pre></td></tr></table></figure><p>detachstate有两个值，PTHREAD_CREATE_JOINABLE（默认值）和PTHREAD_CREATE_DETACH（脱离线程）。脱离线程在退出时将自行释放其占用的系统资源。可以使用<code>pthread_detach</code>来将线程设为脱离线程。</p><p>stack相关的属性是线程堆栈，一般来说不需要自己管理，因为Linux默认为每个线程分配了足够的堆栈空间（一般是8MB）。可以使用ulimt-s来查看或修改该默认值。</p><p>guardsize是保护区大小，如果guardsize大于0，则系统创建线程的时候会在其堆栈的尾部额外分配guardsize字节的空间，作为保护堆栈不被错误地覆盖的区域。如果使用者通过pthread_attr_setstackaddr或pthread_attr_setstack函数手动设置线程的堆栈，则guardsize属性将被忽略。</p><p>schedparam是线程调度参数，它的结构体目前只有一个整型成员sched_priority。</p><p>schedpolicy是线程调度策略，有SCHED_FIFO、SCHED_RR、SCHED_OTHER（默认值）。前两种只能用于以超级用户身份运行的进程。</p><p>inheritsched，是否继承调用线程的调度属性，有PTHREAD_INHERIT_SCHED和PTHREAD_EXPLICIT_SCHED两个值。前者表示继承，这种情况下再设置新的调度参数属性将没有任何效果，后者表示调用者要明确地指定新线程的调度参数。</p><p>scope，线程间竞争CPU的范围，即线程优先级的有效范围。POSIX定义了PTHREAD_SCOPE_SYSTEM和PTHREAD_SCOPE_PROCESS两个可选值，前者表示所有线程一起竞争，后者表示仅与属于同一进程的线程竞争CPU。目前Linux只支持PTHREAD_SCOPE_SYSTEM。</p><h3 id="posix信号量">POSIX信号量</h3><p>常用的POSIX信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>* sem , <span class="hljs-type">int</span> pshared , <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span>;<br><span class="hljs-comment">// pshared指定信号量类型，如果为0则是当前进程的局部信号量，否则就可以在多个进程间共享</span><br><span class="hljs-comment">// 初始化一个已经被初始化的信号量将导致不可预期的结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>* sem)</span>;<br><span class="hljs-comment">// 如果销毁一个正被其他线程等待的信号量将导致不可预期的结果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>* sem)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>* sem)</span>;<br><span class="hljs-comment">// 非阻塞，立即返回，信号量值为0则设置EAGAIN</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>* sem)</span>;<br></code></pre></td></tr></table></figure><h3 id="互斥锁">互斥锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>* mutex , <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span>* mutexattr)</span>;<br><span class="hljs-comment">// mutexattr为NULL则设为默认属性</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>* mutex)</span>;<br><span class="hljs-comment">// 销毁一个已经加锁的互斥锁将导致不可预期的后果</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>* mutex)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>* mutex)</span>;<br><span class="hljs-comment">// 非阻塞，错误码EBUSY</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>* mutex)</span>;<br></code></pre></td></tr></table></figure><p>还可以使用下面的方式初始化<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code></p><p>获取和设置互斥锁属性的函数有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-comment">/*初始化互斥锁属性对象*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutexattr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutexattr_t</span>* attr)</span>;<br><span class="hljs-comment">/*销毁互斥锁属性对象*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutexattr_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutexattr_t</span>* attr)</span>;<br><span class="hljs-comment">/*获取和设置互斥锁的pshared属性*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutexattr_getpshared</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span>* attr , <span class="hljs-type">int</span>* pshared)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutexattr_setpshared</span><span class="hljs-params">(<span class="hljs-type">pthread_mutexattr_t</span>* attr , <span class="hljs-type">int</span> pshared)</span>;<br><span class="hljs-comment">/*获取和设置互斥锁的type属性*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutexattr_gettype</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span>* attr , <span class="hljs-type">int</span>* type)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutexattr_settype</span><span class="hljs-params">(<span class="hljs-type">pthread_mutexattr_t</span>* attr , <span class="hljs-type">int</span> type)</span>;<br></code></pre></td></tr></table></figure><p>属性pshared指定是否允许跨进程共享互斥锁，PTHREAD_PROCESS_SHARED和PTHREAD_PROCESS_PRIVATE</p><p>属性type指定互斥锁类型</p><ul><li>PTHREAD_MUTEX_NORMAL，普通锁，是默认类型，当一个线程对一个普通锁加锁以后，其余请求该锁的线程将形成一个等待队列，并在该锁解锁后按优先级获得它。这种锁类型保证了资源分配的公平性。但这种锁也容易引发问题：一个线程如果对一个已经加锁的普通锁再次加锁，将引发死锁；对一个已经被其他线程加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁，将导致不可预期的后果。</li><li>PTHREAD_MUTEX_ERRORCHECK，检错锁。一个线程如果对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLK。对一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错锁再次解锁，则解锁操作返回EPERM。</li><li>PTHREAD_MUTEX_RECURSIVE，嵌套锁。这种锁允许一个线程在释放锁之前多次对它加锁而不发生死锁。不过其他线程如果要获得这个锁，则当前锁的拥有者必须执行相应次数的解锁操作。对一个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁再次解锁，则解锁操作返回EPERM。</li><li>PTHREAD_MUTEX_DEFAULT，默认锁。一个线程如果对一个已经加锁的默认锁再次加锁，或者对一个已经被其他线程加锁的默认锁解锁，或者对一个已经解锁的默认锁再次解锁，将导致不可预期的后果。这种锁在实现的时候可能被映射为上面三种锁之一。</li></ul><h3 id="条件变量">条件变量</h3><p>条件变量用于在线程之间同步共享数据的值。条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>* cond , <span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span>* cond_attr)</span>;<br><span class="hljs-comment">// 如果cond_attr设置为NULL则使用默认属性</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>* cond)</span>;<br><span class="hljs-comment">// 销毁一个正在被等待的条件变量将失败并返回EBUSY</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>* cond)</span>;<br><span class="hljs-comment">// 以广播的方式唤醒所有等待目标条件变量的线程</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>* cond)</span>;<br><span class="hljs-comment">// 唤醒一个</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>* cond , <span class="hljs-type">pthread_mutex_t</span>* mutex)</span>;<br><span class="hljs-comment">// mutex是用于保护条件变量的互斥锁，以确保pthread_cond_wait操作的原子性。在执行该函数前，必须确保mutex已经加锁，否则将导致不可预期的结果</span><br><span class="hljs-comment">// 在执行时，首先把线程放入条件变量的等待队列，然后将互斥锁mutex解锁。mutex可以保证在函数开始执行到其调用线程被放入条件变量的等待队列之间的这段时间条件变量不会被其他函数修改</span><br><span class="hljs-comment">// 成功返回时，mutex将再次被锁上</span><br></code></pre></td></tr></table></figure><p>同样可以通过<code>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</code>初始化。</p><p>有时候我们可能想唤醒一个指定的线程，但pthread没有对该需求提供解决方法。不过我们可以间接地实现该需求：定义一个能够唯一表示目标线程的全局变量，在唤醒等待条件变量的线程前先设置该变量为目标线程，然后采用广播方式唤醒所有等待条件变量的线程，这些线程被唤醒后都检查该变量以判断被唤醒的是否是自己，如果是就开始执行后续代码，如果不是则返回继续等待。</p><h3 id="线程同步机制包装类">线程同步机制包装类</h3><p>可以将这些同步机制分别封装成类方便复用代码，符合RAII。</p><h3 id="多线程环境">多线程环境</h3><h4 id="线程和进程">线程和进程</h4><p>子进程并不会复制父进程的所有进程，而是复制调用fork的那个线程，并且自动继承父进程中互斥锁、条件变量的状态。这引起了一个问题，子进程可能不清楚从父进程继承而来的互斥锁的具体状态，这个互斥锁可能被加锁了，但并不是由调用fork函数的那个线程锁住的，而是由其他线程锁住的。pthread提供了一个专门的函数pthread_atfork以确保fork调用后父进程和子进程都拥有一个清楚的锁状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_atfork</span><span class="hljs-params">(<span class="hljs-type">void</span> (*prepare)(<span class="hljs-type">void</span>), <span class="hljs-type">void</span> (*parent)(<span class="hljs-type">void</span>), <span class="hljs-type">void</span> (*child)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-comment">// 调用多次会注册多个函数，prepare按照注册时的逆序，parent和child按注册时的顺序</span><br></code></pre></td></tr></table></figure><p>prepare句柄将在fork调用创建出子进程之前被执行，它可以用来锁住所有父进程中的互斥锁。parent句柄则是fork调用创建出子进程之后，而fork返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中被锁住的互斥锁。child句柄是fork返回之前，在子进程中被执行，也是用于释放所有在prepare句柄中被锁住的互斥锁。</p><p>当其他线程加锁时，prepare试图acquire会被阻塞，直到其他线程释放锁，此时prepare能正常获得锁，然后在parent和child中分别释放，就能使得其他线程锁的状态都能释放。</p><h4 id="线程和信号">线程和信号</h4><p>在多线程环境下，设置进程信号掩码时不应用sigprocmask，而应使用下面的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_sigmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how, <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span>* newmask, <span class="hljs-type">sigset_t</span>* oldmask)</span>;<br></code></pre></td></tr></table></figure><p>进程中的所有线程共享该进程的信号，线程库将根据线程掩码决定把信号发送给哪个具体的线程。所有线程共享信号处理函数，当我们在某个线程中设置了某个信号的信号处理函数后，它将覆盖其他线程为同一个信号设置的信号处理函数。因此，一般情况下应定义一个专门的线程来处理所有的信号避免意外出错。这可以通过如下两个步骤来实现：</p><ol type="1"><li>在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，这样所有新创建的子线程都将自动继承这个信号掩码，所有线程都不会响应被屏蔽的信号</li><li>在专门的线程处理函数中调用如下函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigwait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span>* <span class="hljs-built_in">set</span>, <span class="hljs-type">int</span>* sig)</span>;<br></code></pre></td></tr></table></figure><p>可以使用下面的函数将信号发送给指定的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_kill</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">int</span> sig)</span>;<br><span class="hljs-comment">// sig是0时不发送信号，但仍执行错误检查，可以用来检测目标线程是否存在</span><br></code></pre></td></tr></table></figure><h2 id="进程池和线程池">进程池和线程池</h2><p>池的子进程的数目一般在3~10个之间，子线程的数目应该和CPU数量差不多。</p><p>在服务器启动之初就创建好可以使得子进程没有复制一些不必要的空间，占用资源较少。</p><h2 id="服务器调制调试和测试">服务器调制、调试和测试</h2><h3 id="最大文件描述符数">最大文件描述符数</h3><p><code>ulimit -n</code>查看用户级文件描述符数限制</p><p><code>ulimit -SHn &lt;max-file-number&gt;</code>临时修改</p><p>永久修改需要在/etc/security/limits.conf中（分别修改硬限制和软限制）</p><blockquote><p>hard nofile <max-file-number></p><p>soft nofile <max-file-number></p></blockquote><hr /><p>如果要修改系统级文件描述符限制，可使用<code>sysctl -w fs.file-max=&lt;max-file-number&gt;</code>（临时）</p><p>永久修改需在/etc/sysctl.conf中</p><blockquote><p>fs.file-max=<max-file-number></p></blockquote><p>然后执行sysctl -p</p><h3 id="调整内核参数">调整内核参数</h3><p>几乎所有的内核模块，包括内核核心模块和驱动程序，都在/proc/sys文件系统下提供了某些配置文件以供用户调整模块的属性和行为，通常一个配置文件对应一个内核参数，文件名就是参数的名字，文件的内容是参数的值，我们可以通过命令<code>sysctl -a</code>查看所有这些内核参数。可以通过直接修改/proc/sys目录下的文件的方式来修改这些系统参数外，也可以使用sysctl命令来修改它们。这两种修改方式都是临时的。</p><p>要永久修改应在/etc/sysctl.conf文件中加入相应参数及其数值，并执行sysctl -p使之生效。</p><h4 id="文件相关">文件相关</h4><p>/proc/sys/fs目录下的内核参数都与文件系统相关。</p><p>/proc/sys/fs/fs/file-max，系统级文件描述符数限制，修改这个参数是临时修改。一般修改/proc/sys/fs/file-max后，应用程序需要把/proc/sys/fs/inode-max 设置为/proc/sys/fs/fs/file-max值的3-4倍，否则可能导致i 节点数不够用。</p><p>/proc/sys/fs/epoll/max_user_watches，一个用户能够往epoll内核事件表注册的事件总量。它是指该用户打开的所有epoll实例总共能监听的事件数目，而不是单个epoll实例能监听的事件数目。往epoll内核事件表中注册一个事件，在32位系统上大概消耗90字节的内核空间，在64位系统上则消耗160字节的内核空间。所以，这个内核参数限制了epoll使用的内核内存总量。</p><h4 id="网络相关">网络相关</h4><p>内核中网络模块的相关参数都位于/proc/sys/net 目录下，其中和TCP/IP协议相关的参数主要位于如下三个目录中：core 、ipv4 、ipv6 。</p><p>/proc/sys/net/core/somaxconn，指定listen监听队列里，能够建立完整连接从而进入ESTABLISHED状态的socket 的最大数目。</p><p>/proc/sys/net/ipv4/tcp_max_syn_backlog，指定listen监听队列里，能够转移至ESTABLISHED或者SYN_RCVD状态的socket的最大数目。</p><p>/proc/sys/net/ipv4/tcp_wmem，它包含了3个值，分别指定一个socket的TCP写缓存区的最小值、默认值和最大值。</p><p>/proc/sys/net/ipv4/tcp_rmem，它包含了3个值，分别指定一个socket的TCP读缓存区的最小值、默认值和最大值。</p><p>/proc/sys/net/ipv4/tcp_syncookies，指定是否打开TCP同步标签。同步标签通过启动cookie来防止一个监听socket因不停的重复接收来自同一个地址的连接请求（同步报文段），而导致listen监听队列溢出（所谓的SYN风暴）。</p><h3 id="gdb调试">gdb调试</h3><h4 id="调试多进程">调试多进程</h4><h5 id="单独调试子进程">单独调试子进程</h5><p>运行gdb，在gdb里执行<code>attach &lt;pid&gt;</code></p><h5 id="follow-fork-mode">follow-fork-mode</h5><p>在gdb里<code>set follow-fork-mode &lt;mode&gt;</code>，mode为parent或child，选择程序在执行fork后调试父进程还是子进程。</p><h4 id="调试多线程">调试多线程</h4><p><code>info threads</code>显示当前所有可调试的线程，gdb会为每一个线程分配一个ID，根据ID来操作对应的线程，ID前有“*”的是当前被调试的线程。</p><p><code>thread &lt;ID&gt;</code>调试目标进程</p><p>在调试多线程程序时，默认除了被调试的线程在执行外，其他线程也在继续执行。可以通过<code>set scheduler-locking [off|on|step]</code>设置其他线程的运行状态。off表示不锁定任何线程，这是默认值，on表示只有当前被调试的线程会继续执行，step表示在单步执行的时候只有当前线程会执行。</p><h3 id="压力测试">压力测试</h3><p>如果是本机测试，可以单纯用I/O复用，因为多线程和多进程本身的调度也要消耗大量时间。</p><h2 id="系统检测工具">系统检测工具</h2><h3 id="tcpdump">tcpdump</h3><p>网络抓包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">-n <span class="hljs-comment"># 使用IP地址表示主机，而不是主机名；使用数字表示端口号，而不是服务名称</span><br>-i <span class="hljs-comment"># 指定要监听的网卡接口。-i any表示抓取所有网卡接口上的数据包</span><br>-v <span class="hljs-comment"># 输出一个稍微详细的信息，例如显示IP数据包中的TTL和TOS信息</span><br>-t <span class="hljs-comment"># 不打印时间戳</span><br>-e <span class="hljs-comment"># 进现实以太网帧头部信息</span><br>-c <span class="hljs-comment"># 仅抓取指定数量的数据包</span><br>-x <span class="hljs-comment"># 以十六进制显示数据包的内容，但不显示包中以太网帧的头部信息</span><br>-X <span class="hljs-comment"># 与-x类似，但还打印每个十六进制字节对应的ASCII字符</span><br>-XX <span class="hljs-comment"># 与-X相同，不过还打印以太网帧的头部信息</span><br>-s <span class="hljs-comment"># 设置抓包时的抓取长度</span><br>-S <span class="hljs-comment"># 以绝对值来显示TCP报文段的序号，而不是相对值</span><br>-w <span class="hljs-comment"># 将tcpdump的输出以特殊的格式定向到某个文件</span><br>-r <span class="hljs-comment">#从文件读取数据包信息并显示之</span><br></code></pre></td></tr></table></figure><p>还支持用表达式进一步过滤数据包，操作数分三种，type（类型，包括host、net、port和portrange），dir（方向），proto（协议）</p><p><code>tcpdump net 1.2.3.0/24</code></p><p><code>tcpdump dst port 13579</code></p><p><code>tcpdump icmp</code></p><p><code>tcpdump ip host ernest-laptop and not Kongming20</code></p><p>可以用括号改变优先级，但括号存在时应把tcpdump后面的整个表达式用单引号引起来，或用反斜杠对括号进行转义。</p><p><code>tcpdump 'src 10.0.2.4 and (dst port 3389 or 22)'</code></p><p>此外还允许直接使用数据包中的部分协议字段的内容来过滤数据包，比如仅抓取TCP同步报文段</p><p><code>tcpdump 'tcp[13] &amp; 2 != 0'</code>（TCP头部第14个字节的第2个位是同步标志）</p><p><code>tcpdump 'tcp[tcpflags] &amp; tcp-syn != 0'</code></p><h3 id="lsof">lsof</h3><p>列出当前系统打开的文件描述符</p><h3 id="nc">nc</h3><p>主要被用来快速构建网络连接，以调试客户端、服务器程序。</p><h3 id="strace">strace</h3><p>测试服务器性能的重要工具，跟踪程序运行过程中执行的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号名输出到标准输出或指定文件。</p><h3 id="netstat">netstat</h3><p>功能强大的网络信息统计工具，可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息。不过获取路由表信息和网卡接口信息更实用的是route和ipconfig。</p><h3 id="vmstat">vmstat</h3><p>是virtual memorystatistics的缩写，能实时输出系统的各种资源的使用情况，比如进程信息、内存使用、CPU使用率以及I/O使用情况</p><p>可以使用iostat获得磁盘使用情况的更多信息，也可以使用mpstat获得CPU使用的更多信息。vmstat主要用于查看系统内存的使用情况。</p><h3 id="ifstat">ifstat</h3><p>是interfacestatistics的缩写，是一个简单的网络流量监测工具。使用ifstat命令可以大概估计各个时段服务器的总输入、输出流量。</p><h3 id="mpstat">mpstat</h3><p>是multi-processorstatistics的缩写，能实时监测多处理器系统上每个CPU的使用情况。mpstat和iostat命令通常都集成在sysstat中。</p>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>长篇笔记</tag>
      
      <tag>Linux</tag>
      
      <tag>C</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modern Cpp Tutorial笔记</title>
    <link href="/posts/1427194570/"/>
    <url>/posts/1427194570/</url>
    
    <content type="html"><![CDATA[<blockquote><p>浏览github上modern cpp tutorial时记录下的笔记</p></blockquote><span id="more"></span><h3 id="chapter1">Chapter1</h3><p>The string literal constant is no longer allowed to be assigned to a<code>char *</code>. If you need to assign and initialize a<code>char *</code> with a string literal constant, you should use<code>const char *</code> or <code>auto</code>.</p><p>如果混用C和C++，应对C代码做额外处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// foo.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// foo.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br></code></pre></td></tr></table></figure><p>并在编译时先单独编译C代码，再链接到cpp代码上。</p><h3 id="chapter-2">Chapter 2</h3><p>C++ <strong>does not allow</strong> to implicitly convert<code>void *</code> to other types. The type of <code>nullptr</code> is<code>nullptr_t</code>, which can be implicitly converted to any pointeror member pointer type, and can be compared equally or unequally withthem.</p><p>Starting with C++14, the constexpr function can use simple statementssuch as local variables, loops, and branches internally.</p><p>the function of <code>constexpr</code> can use recursion</p><p>C++17 if的括号里也可以定义变量了</p><h4 id="structured-binding">structured binding</h4><p>C++17提供了方便的tuple。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><br><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;456&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> [x, y, z] = <span class="hljs-built_in">f</span>();<br>    std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类型推导">类型推导</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// arr as int *</span><br></code></pre></td></tr></table></figure><p>C++20甚至支持函数参数用auto</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">5</span>; <span class="hljs-comment">// type int</span><br><span class="hljs-keyword">auto</span> j = <span class="hljs-number">6</span>; <span class="hljs-comment">// type int</span><br>std::cout &lt;&lt; <span class="hljs-built_in">add</span>(i, j) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>auto不能用于数组类型的推导</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> auto_arr2[<span class="hljs-number">10</span>] = &#123;arr&#125;;   <span class="hljs-comment">// illegal, can&#x27;t infer array type</span><br></code></pre></td></tr></table></figure><p>使用std::is_same&lt;decltype(x), int&gt;::value判断类型是否相同</p><p>c++11模板函数返回类型的推导需要如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add2</span><span class="hljs-params">(T x, U y)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++14则可以用auto直接推导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add3</span><span class="hljs-params">(T x, U y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>In simple terms, <code>decltype(auto)</code> is mainly used to derivethe return type of a forwarding function or package, which does notrequire us to explicitly specify the parameter expression of<code>decltype</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string  <span class="hljs-title">lookup1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::string&amp; <span class="hljs-title">lookup2</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>在c++11中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">look_up_a_string_1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lookup1</span>();<br>&#125;<br><span class="hljs-function">std::string&amp; <span class="hljs-title">look_up_a_string_2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lookup2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>c++14</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">look_up_a_string_1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lookup1</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">look_up_a_string_2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lookup2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>if constexpr</p><p>常用于模板函数</p><hr /><p>C++11引入了extern templates以避免过多重复实例化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::vector&lt;<span class="hljs-type">bool</span>&gt;;          <span class="hljs-comment">// force instantiation</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::vector&lt;<span class="hljs-type">double</span>&gt;; <span class="hljs-comment">// should not instantiation in current file</span><br></code></pre></td></tr></table></figure><p>typedef不支持模板参数，但using支持</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// not allowed</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typedef</span> MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;<br></code></pre></td></tr></table></figure><h4 id="variadic-templates">Variadic templates</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Magic</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt; <span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str, Args... args)</span></span>;<br></code></pre></td></tr></table></figure><p>使用sizeof...()获取参数个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">printf3</span><span class="hljs-params">(T value, Ts... args)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>    (<span class="hljs-type">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;<br>        std::cout &lt;&lt; args &lt;&lt; std::endl;<br>    &#125;(), value)...&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了解包，一种标准方式为递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T0&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf1</span><span class="hljs-params">(T0 value)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf1</span><span class="hljs-params">(T value, Ts... args)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>    <span class="hljs-built_in">printf1</span>(args...);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">1.1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是利用sizeof...可以更方便地实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T0, <span class="hljs-keyword">typename</span>... T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf2</span><span class="hljs-params">(T0 t0, T... t)</span> </span>&#123;<br>    std::cout &lt;&lt; t0 &lt;&lt; std::endl;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>...(t) &gt; <span class="hljs-number">0</span>)</span> <span class="hljs-title">printf2</span><span class="hljs-params">(t...)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种方式是利用fold expression</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">printf3</span><span class="hljs-params">(T value, Ts... args)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>    (<span class="hljs-type">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;<br>        std::cout &lt;&lt; args &lt;&lt; std::endl;<br>    &#125;(), value)...&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>C++11引入了delegateconstruct，即constructor可以调用本类的其他constructor</p><p>使用using来继承父类constructor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subclass</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::Base; <span class="hljs-comment">// inheritance constructor</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubClass1</span> <span class="hljs-keyword">final</span>: Base &#123;<br>&#125;; <span class="hljs-comment">// legal</span><br></code></pre></td></tr></table></figure><hr /><p>enum class可以指定underlying type。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">new_enum</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123;<br>    value1,<br>    value2,<br>    value3 = <span class="hljs-number">100</span>,<br>    value4 = <span class="hljs-number">100</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value,<br>        std::ostream&gt;::type&amp; stream, <span class="hljs-type">const</span> T&amp; e)<br>&#123;<br>    <span class="hljs-keyword">return</span> stream &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h3 id="chapter-3">Chapter 3</h3><p>mutable声明的成员变量可以被const成员函数修改</p><hr /><p>lambda expression</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">[capture list] (parameter list) mutable(optional) <span class="hljs-keyword">exception</span> attribute -&gt; <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> <span class="hljs-type">&#123;</span><br><span class="hljs-type"></span>// <span class="hljs-keyword">function</span> <span class="hljs-title">body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>the captured variable is copied/referenced when the lambda expressionis created, not when it is called</p><p>还允许expression capture</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> important = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> add = [v1 = <span class="hljs-number">1</span>, v2 = std::<span class="hljs-built_in">move</span>(important)](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">return</span> x+y+v1+(*v2);<br>    &#125;;<br></code></pre></td></tr></table></figure><p>类型推导与auto一致</p><p>lambda表达式没法用模板，但是C++14以后参数列表可以用auto，起到了类似模板的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lambda_generic</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> generic = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) &#123;<br>        <span class="hljs-keyword">return</span> x+y;<br>    &#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-built_in">generic</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">generic</span>(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>std::placeholder::_1 中的 "_1": 表示新的可调用对象中的第一个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// bind parameter 1, 2 on function foo,</span><br>    <span class="hljs-comment">// and use std::placeholders::_1 as placeholder for the first parameter.</span><br>    <span class="hljs-keyword">auto</span> bindFoo = std::<span class="hljs-built_in">bind</span>(foo, std::placeholders::_1, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// when call bindFoo, we only need one param left</span><br>    <span class="hljs-built_in">bindFoo</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>constant references allow binding to non-lvalues</p><h3 id="chapter-4">Chapter 4</h3><p>vector.shrink_to_fit可以根据当前size调整capacity，而clear不会改变capacity</p><p>将std::array转化为数组指针可以通过&amp;arr[0]或arr.data()。</p><p>std::forward_list是单向链表</p><p>std::map、std::set由红黑树实现，std::unordered_map、std::unordered_multimap、std::unordered_set、std::unordered_multiset由哈希表实现</p><hr /><p>std::tuple用于存储不同类型的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> gpa;<br><span class="hljs-type">char</span> grade;<br>std::string name;<br><br><span class="hljs-comment">// unpack tuples</span><br><span class="hljs-keyword">auto</span> tuple = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">3.8</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&quot;John&quot;</span>);<br>std::<span class="hljs-built_in">tie</span>(gpa, grade, name) = tuple;<br><span class="hljs-comment">// std::get用于从tuple中取得数据，支持index和类型(C++14)，如果取的类型在tuple中不唯一则会产生运行时错误</span><br>std::string str = std::<span class="hljs-built_in">get</span>&lt;std::string&gt;(tuple);<br><span class="hljs-type">char</span> c = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(tuple);<br></code></pre></td></tr></table></figure><hr /><p>std::variant&lt;T...Ts&gt;类似union(C++17)，声明一个动态类型的变量，该变量的类型在Ts中变化，一个时间只能为一个类型，可以根据.index()得到当前使用的类型的下标。可以用std::get获取值，如果获取的非它当前的类型，会抛出异常std::bad_variant_access</p><p>利用std::variant递归可以实现非常量索引的get。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> n, <span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-keyword">constexpr</span> std::variant&lt;T...&gt; _tuple_index(<span class="hljs-type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="hljs-type">size_t</span> i) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(n &gt;= <span class="hljs-keyword">sizeof</span>...(T))</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throw</span> <span class="hljs-title">std::out_of_range</span><span class="hljs-params">(<span class="hljs-string">&quot;越界.&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (i == n)<br>        <span class="hljs-keyword">return</span> std::variant&lt;T...&gt;&#123; std::in_place_index&lt;n&gt;, std::<span class="hljs-built_in">get</span>&lt;n&gt;(tpl) &#125;;<br>    <span class="hljs-keyword">return</span> _tuple_index&lt;(n &lt; <span class="hljs-keyword">sizeof</span>...(T)<span class="hljs-number">-1</span> ? n+<span class="hljs-number">1</span> : <span class="hljs-number">0</span>)&gt;(tpl, i);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> std::variant&lt;T...&gt; <span class="hljs-title">tuple_index</span><span class="hljs-params">(<span class="hljs-type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="hljs-type">size_t</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _tuple_index&lt;<span class="hljs-number">0</span>&gt;(tpl, i);<br>&#125;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">tuple_index</span>(tuple, i);<br></code></pre></td></tr></table></figure><p>可以使用std::tuple_cat来连接tuple</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">tuple_len</span><span class="hljs-params">(T &amp;tpl)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::tuple_size&lt;T&gt;::value;<br>&#125;<br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-built_in">tuple_len</span>(new_tuple); ++i)<br>    <span class="hljs-comment">// runtime indexing</span><br>    <span class="hljs-built_in">tuple_index</span>(new_tuple, i);<br></code></pre></td></tr></table></figure><h3 id="chapter-5">Chapter 5</h3><p>std::shared_ptr</p><p>use_count得到reference count</p><p>reset取消该指针的reference，不影响其他指针。</p><hr /><p><code>std::weak_ptr</code> has no implemented <code>*</code> and<code>-&gt;</code> operators</p><p>the <code>expired()</code> method of a <code>std::weak_ptr</code>returns <code>false</code> when the resource is not released</p><p>The <code>lock()</code> method returns a <code>std::shared_ptr</code>to the original object when the resource is not released, or<code>nullptr</code> otherwise.</p><h3 id="chapter-6">Chapter 6</h3><p>std::regex</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string fnames[] = &#123;<span class="hljs-string">&quot;foo.txt&quot;</span>, <span class="hljs-string">&quot;bar.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;a0.txt&quot;</span>, <span class="hljs-string">&quot;AAA.txt&quot;</span>&#125;;<br><span class="hljs-function">std::regex <span class="hljs-title">txt_regex</span><span class="hljs-params">(<span class="hljs-string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;<br>std::<span class="hljs-built_in">regex_match</span>(fname, txt_regex); <span class="hljs-comment">// 返回值为bool</span><br>std::smatch base_match; <span class="hljs-comment">// std::match_results&lt;std::string::const_iterator&gt;</span><br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_match</span>(fname, base_match, txt_regex)) &#123;<br>    <span class="hljs-comment">// the first element of std::smatch matches the entire string</span><br>    <span class="hljs-comment">// the second element of std::smatch matches the first expression</span><br>    <span class="hljs-comment">// with brackets</span><br>    <span class="hljs-keyword">if</span> (base_match.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>        std::string base = base_match[<span class="hljs-number">1</span>].<span class="hljs-built_in">str</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;sub-match[0]: &quot;</span> &lt;&lt; base_match[<span class="hljs-number">0</span>].<span class="hljs-built_in">str</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; fname &lt;&lt; <span class="hljs-string">&quot; sub-match[1]: &quot;</span> &lt;&lt; base &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>长篇笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++学习笔记</title>
    <link href="/posts/2255851676/"/>
    <url>/posts/2255851676/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读《Effective C++》时记录下的笔记</p></blockquote><span id="more"></span><h2 id="accustoming-yourself-to-c">Accustoming Yourself to C++</h2><h3 id="prefer-consts-enums-and-inlines-to-defines">Prefer consts,enums, and inlines to #defines</h3><p>#define是preprocessor负责的，它可能导致报错时提示信息不便于问题定位，且#define定义的常量无法局限在一个类内。</p><hr /><p>const的优势</p><ul><li>对于一些更复杂的类型如浮点，它可以生成更少的代码，不像#define一样会导致复制多份。</li><li>调试信息更便于追溯。</li></ul><p>当想要把一个const限制在类的作用域中的时候，需要作为成员变量，并使用static确保最多只有一份该constant。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006200258629.png" /></p><p>上图只有constant的declaration，类内的静态integral常量在没用到取地址操作时可以不提供definition。否则，应该在实现文件中进行definition，如果declaration已经给了初值，那么definition可以不给。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006200702148.png" /></p><p>只有integral的类内静态常量可以在declaration的时候直接给初值。</p><hr /><p>对于类的编译直接需要被初始化的常量的情况，如声明一个指定大小的数组，可以用enumhack。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006203841107.png" /></p><p>一个良好的编译器不会为integral的#define和enum分配内存空间。</p><hr /><p>即使用看样子实现没有问题的宏函数，也可能存在潜在的问题。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006204732277.png" /></p><p>用inline则既可以没有函数的开销，又安全，又可以有作用域。</p><hr /><p>#ifdef / #ifndef等内容依然起着重要的不可替代的作用。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006205114692.png" /></p><h3 id="use-const-whenever-possible">Use const whenever possible</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006205504068.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006205957198.png" /></p><hr /><p>把非built-in type的函数返回值设为const有利于避免下面的错误（built-intype本身就不允许返回值被修改）。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006210709545.png" /></p><p>用mutable修饰变量使得即使在const的memberfunction中也可以修改它们。</p><p>当const和non-const的memberfunction功能完全一致但返回值类型不同时，可以用下面的方法减少代码重复。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006215557460.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221006215614061.png" /></p><h3 id="make-sure-that-objects-are-initialized-before-theyre-used">Makesure that objects are initialized before they're used</h3><p>ctor的member initializationlist是initialization而不是assignment，所以效率往往会高于在ctor中进行赋值（因为赋值前先进行了一次defaultconstruct，对于built-in type并没有效率上的差别）。</p><p>const、reference必须initialize而不能assign。</p><p>初始化顺序为基类成员变量优先，按变量声明顺序初始化而不是在initializationlist中的顺序，为保持一致性，initializationlist中的顺序应和变量声明顺序保持一致。</p><hr /><p>对于non-local的static变量，可以通过将它变成一个local的static变量，即把它的definition放入一个函数中，通过函数访问它。因为C++中确保第一次遇到localstatic物体的definition时会将其初始化。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007141606325.png" /></p><p>对于多线程程序，这样的做法依然存在问题，可以在进入多线程之前手动调用所有返回static物体的函数来确保它们初始化完成。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007142641515.png" /></p><h2 id="constructors-destructors-and-assignment-operators">Constructors,Destructors, and Assignment Operators</h2><h3 id="know-what-functions-c-silently-writes-and-calls">Know whatfunctions C++ silently writes and calls</h3><p>编译器会自动生成public、inline的ctor、dtor、copy ctor、copyoperator如果代码中有用到对应的功能且没有声明。dtor在继承自的基类的destructor声明为virtual的时候也会是virtual。</p><p>编译器不支持生成含reference或const的类成员的copyassignment，因为它们必须在初始化的时候就确定，不支持二次赋值，应当自己实现copyassignment。</p><h3id="explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want">Explicitlydisallow the use of compiler-generated functions you do not want</h3><p>declare private（避免被client调用） and notdefined（避免类内部调用，调用会发生link error）</p><p>为了使它在编译器就报错，可以使用以下技巧。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007155715743.png" /></p><p>因为如果代码中使用到了copy，编译器自动生成的copy会尝试调用父类的copy，而父类的copy是private。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007160108852.png" /></p><h3 id="declare-destructors-virtual-in-polymophic-base-classes">Declaredestructors virtual in polymophic base classes</h3><p>如果父类的dtor是virtual的，在用父类指针delete时，会先调用子类的dtor，再调用父类的dtor。</p><p>The rule for giving base classes virtual destructors applies only topolymorphic base classes — to base classes designed to allow themanipulation of derived class types through base class interfaces.</p><p>将不需要virtual的dtor声明为virtual会造成不必要的内存消耗(vptr)。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007163847023.png" /></p><h3 id="prevent-exceptions-from-leaving-destructors">Prevent exceptionsfrom leaving destructors</h3><p>应当尽量避免destructor中抛出异常。</p><p>对于以下为确保数据库连接关闭而在dtor中进行可能抛出异常的操作</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007165707205.png" /></p><p>可以改为</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007165829438.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007165852754.png" /></p><h3id="never-call-virtual-functions-during-construction-or-destruction">Nevercall virtual functions during construction or destruction</h3><p>不应该在constructor里调用或间接调用virtualfunction因为如果该类A是另一个类B的父类，那么B构造过程会先调用A的构造函数，A的构造函数调用的virtualfunction是A的而不是B的。destructor类似。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007173656450.png" /></p><h3 id="have-assignment-operators-return-a-reference-to-this">Haveassignment operators return a reference to *this</h3><p>为了能够连等。适用于各种assignment操作符，如+=。</p><h3 id="handle-assignment-to-self-in-operator">Handle assignment to selfin operator=</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007185555602.png" /></p><p>像上面这种代码如果不判断是否是自己则可能pb和rhs.pb是同一个，存在指针悬空的问题。</p><p>但这样是不exception-safe的，一旦pb = newBitmap()抛出异常，pb将指向已经被free的地址。</p><p>下面的做法则既解决了assignment to self也确保了exception-safety。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007185938374.png" /></p><p>如果构造非常消耗资源，可以加是否为自己的判断。如果assignment toself不经常发生，那么不判断会更好一些。</p><hr /><p>下面的方法兼顾了assignment to self和exception-safety。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007190250906.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007190301078.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007185014590.png" /></p><h3 id="copy-all-parts-of-an-object">Copy all parts of an object</h3><p>对于一个子类，记得调用它父类的copy functions。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007194249092.png" /></p><p>如果觉得这两个函数有较高的重复性，可以另写一个private的函数，而不是尝试在一个copyfunction里调用另一个copy function。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221007194352511.png" /></p><h2 id="resource-management">Resource Management</h2><h3 id="use-objects-to-manage-resources">Use objects to manageresources</h3><p>Resource Acquisition Is Initialization, RAII</p><p>不要将智能指针用于数组，因为它是delete而不是delete[]</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008104915339.png" /></p><h3id="think-carefully-about-copying-behavior-in-resource-managing-classes">Thinkcarefully about copying behavior in resource-managing classes</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008105632079.png" /></p><h3id="provide-access-to-raw-resources-in-resource-managing-classes">Provideaccess to raw resources in resource-managing classes</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008110918657.png" /></p><h3 id="use-the-same-form-in-corresponding-uses-of-new-and-delete">Usethe same form in corresponding uses of new and delete</h3><p>对于array[]使用delete是undefined behavior</p><p>避免对数组使用typedef，那会使得new和delete的对应关系难以看出。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008112126435.png" /></p><h3id="store-newed-objects-in-smart-pointers-in-standalone-statements">Storenewed objects in smart pointers in standalone statements</h3><p>对于下图的代码</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008112701663.png" /></p><p>它的执行顺序可能是，newWidget、priority()、std::tr1::shared_ptr&lt;Widget&gt;，如果priority抛出异常，那么会存在内存泄漏。所以应改成下面这样。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008112832875.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008112843620.png" /></p><h2 id="designs-and-declarations">Designs and Declarations</h2><p>对于下图这样参数顺序容易错的接口</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008121032408.png" /></p><p>可以写一个简单的类型封装</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008121110518.png" /></p><p>对于有小的范围限制的类型，可以直接用静态成员函数实现。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008121201093.png" /></p><hr /><p>为了不让(a * b = c)这种错误出现，返回类型设为const。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008121010220.png" /></p><h3 id="prefer-pass-by-reference-to-const-to-pass-by-value">Preferpass-by-reference-to-const to pass-by-value</h3><p>避免了不必要的copy，避免了传入派生类发生的slice off。</p><p>built-in、iterator、functionobject不适用该规则，pass-by-value更高效，因为reference实际上就是指针。</p><p>并不是小的object就更适合pass-by-value，因为有的编译器不会将user-definedobject里的double放入寄存器但会将直接的double放入寄存器。而且小的object在维护过程中可能逐渐变大。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221008143750308.png" /></p><h3id="prefer-non-member-non-friend-functions-to-member-functions">Prefernon-member non-friend functions to member functions</h3><p>non-member non-friendfunctions有更好的封装性，因为它不能访问类的私有变量。</p><p>non-member non-friendfunctions有更好的拓展性，client可以写一个新的header，放在同一命名空间下，在需要用到时include进来，而memberfunction对于client来说是不可拓展的。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221009101154915.png" /></p><h3 id="consider-support-for-a-non-throwing-swap">Consider support for anon-throwing swap</h3><h2 id="implementations">Implementations</h2><h2 id="inheritance-and-object-oriented-design">Inheritance andObject-Oriented Design</h2><h2 id="templates-and-generic-programming">Templates and GenericProgramming</h2><h2 id="customizing-new-and-delete">Customizing new and delete</h2><h2 id="miscellany">Miscellany</h2>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>长篇笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Concurrency in Action笔记</title>
    <link href="/posts/3350115786/"/>
    <url>/posts/3350115786/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读《C++ Concurrency in Action》时记录下的笔记</p></blockquote><span id="more"></span><p>std::thread works with any callable type, e.g.. a class instance withoperator().</p><p>注意避免C++'s most vexingparse，也就是类的无参构造时，应像下面这样写。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220930172352334.png" /></p><p>如果没有定义std::thread该如何运行，std::thread的destructor会在调用std::terminate，所以应在其析构前决定它是join还是detach。</p><p>用RAII保证它exception-safe。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221001133936647.png" /></p><h3 id="stdthread的参数传递">std::thread的参数传递</h3><p>默认情况下，传给std::thread的内容会被copy或move到std::thread对象内，在callableobject被调用时才会被以rvalue形式进一步传给函数。所以当函数的参数为非const的reference时，编译器将报错。</p><p>如果想要引用当前的变量，可以使用std::ref。</p><p>如果想要在其他线程执行成员函数，可以用如下方式。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221001120705487.png" /></p><p>如果成员函数有参数，可以跟在后面。</p><p>可以用std::thread::hardware_concurrency()查看支持的线程数，但如果该信息不可用则会返回0。</p><p>注意创建线程时-1因为还有该线程自身。</p><blockquote><p>与迭代器有关的一系列函数</p><p>std::distance 给定两个迭代器之间的元素个数</p><p>std::advance 将给定迭代器移动指定距离</p><p>std::accumulate 两个迭代器之间的元素的和</p></blockquote><h3 id="identifying-threads">Identifying threads</h3><p>每个underlying的thread都有一个独特的编号，可以用std::thread::get_id()得到threadobject的id object，如果该thread object没有underlyingthread，那就会返回一个default-destructed的id object。</p><p>可以使用std::this_thread::get_id()得到当前thread的underlyingthread的id object。</p><p>std::thread::id是total order的</p><h2 id="sharing-data-between-threads">Sharing data between threads</h2><p>通过std::mutex实现。</p><p>std::mutex实际上并不是给数据加锁，而是给代码加锁，所有用同一个std::mutex锁住的代码段不能同时执行。</p><p>但这并不是说，当我们实现一个类时，只需要将会发生race或invariantbreak的代码段加锁就不会出现问题。如果将需要保护的数据作为pointer、reference返回出去，或作为参数传递给函数，使用者并没有意识到这是多线程危险的，所以不会加锁，这就会导致问题。</p><p>Don’t pass pointers and references to protected data outside thescope of the lock, whether by returning them from a function, storingthem in externally visible memory, or passing them as arguments touser-supplied functions.</p><p>此外，当一个object在多个线程间被共享时，也可能出现问题。比如stack，其他线程在进行push、pop而有一线程在根据stack内元素个数进行不同的操作，即使使用了std::mutex，也可能会出现判断完了之后条件不成立的情况。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221001165519600.png" /></p><h3 id="deadlock">Deadlock</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221001193352631.png" /></p><p>上图代码中，如果第一个函数的第一行被一个线程执行，然后第二个函数的第一行被另一个执行，就出现了死锁。</p><p>deadlock造成的原因为不同函数中上锁顺序可能不同。为避免这点，C++提供了一个一次性上多个锁的机制，即std::lock。对于已经上锁的使用std::lock_guard需要在第二个参数传入std::adopt_lock，因为对已经上mutex锁的调用lock是未定义行为。</p><p>此外，可以统一锁的顺序。可以用hierarchy的概念对该顺序进行规定，每个锁在初始化时传入一个hierarchy，hierarchy大的锁必须在hierarchy小的锁前面lock。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221001220135746.png" /></p><p>C++17的std::scoped_lock提供了更简单的实现，它类似于std::lock_guard，但是可以直接用于多个mutex。</p><p>死锁同样还可能在两个或多个thread互相等待彼此join时发生，所以写代码时应该避免这一点。</p><p>std::unique_lock可以用于mutex不立刻上锁的场景，通过第二个参数std::defer_lock，之后用std::lock上锁。但由于它需要额外的开销维护锁是否上了，效率并不是很高。owns_lock可以检测是否上锁。通常情况下，如果没有转移owner_ship的要求以及defer的需要，且在C++17以上，用scope_lock是更好的选择。</p><p>std::unique_lock支持手动解锁、加锁。</p><h3 id="locking-at-an-approporiate-granularity">Locking at anapproporiate granularity</h3><p>Unless the lock is intended to protect access to the file, don't doany time-consuming activities like file I/O whilte holding a lock.</p><h2 id="alternative-facilities-for-protecting-shared-data">Alternativefacilities for protecting shared data</h2><h4 id="protecting-shared-data-during-initialization">Protecting shareddata during initialization</h4><p>C++11以后，static变量的初始化多线程安全。</p><p>可以用std::once_flag和std::call_once来确保初始化只进行一次。这样的做法往往比用std::mutex开销小许多。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221002093727847.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221002093653774.png" /></p><h4 id="protecting-rarely-updated-data-structures">Protecting rarelyupdated data structures</h4><p>C++14提供了std::shared_timed_mutex，C++17提供了std::shared_mutex，std::shared_timed_mutex提供了更多的功能，但是开销会稍有增加。</p><p>The performance is dependent on the number of processors involved andthe relative workloads of the reader and updater threads. It’s thereforeimportant to profile the performance of the code on the target system toensure that there’s a benefit to the additional complexity.</p><p>std::shared_mutex支持共享锁和互斥锁。std::lock_guard、std::unique_lock和std::mutex，提供exclusiveaccess。C++14提供的std::shared_lock用于加共享锁。</p><p>给有共享锁的加互斥锁和给有互斥锁的加共享锁都会阻塞。</p><h4 id="recursive-locking">Recursive locking</h4><p>当一个加锁的成员函数调用另一个加锁的成员函数时，可以用std::recursive_mutex代替std::mutex。但是这往往不是一个好的解决方案，因为第二个函数可能会在invariantbroken的情况下运行。一个更好的解决方案是写一个新的不加锁的成员函数，并仅在加锁的情况下调用该函数。</p><h2 id="synchronizing-concurrent-operations">Synchronizing concurrentoperations</h2><h3 id="waiting-for-an-event-or-other-condition">Waiting for an event orother condition</h3><p>C++提供了std::condition_variable和std::condition_variable_any（moregeneral but less flexibility）.</p><p>condition_variable提供了wait方法，该方法接受一个std::unique_lock和一个函数。如果函数返回false就解开锁并且将当前thread变成blocked或waitingstate，直到这个condition_variable在另一个线程中被notify()。一旦notify，重新上锁并再一次调用函数检测。如果返回为true则保持上锁状态继续执行，否则同上。</p><p>使用notify_one从所有等待的线程中选一个响应，notify_all使得所有线程响应。</p><p>wait的一种简单实现如下。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221002140137979.png" /></p><h3 id="waiting-for-one-off-events-with-futures">Waiting for one-offevents with futures</h3><p>std::future是move-only的，只能进行一次get操作。</p><p>用std::async</p><p>用std::packaged_task给function或callableobject绑定std::future。结合使用它与队列，可以给一个线程分配任务。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221002205038163.png" /></p><p>用std::thread运行std::packaged_task，就可以通过它对应的std::future得到返回值。</p><hr /><p>std::promiseobject可以用get_future方法得到std::future，而std::promiseobject可以通过set_value、set_exception设置值或异常作为std::future的get的返回内容。一旦设置，std::future就为ready。</p><hr /><p>std::future中可以存放值或exception，在get时exception被重新抛出，但C++并没有规定重新抛出的exception是否和原本的一致，所以不同编译器实现可能有不同。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221003093419212.png" /></p><p>如果已经知道要抛出的错误是什么，最好直接用下面的语句，因为它效率更高，更易读。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221003093558214.png" /></p><p>如果std::promise没有set或std::packaged_task没有被call，那么它们析构的时候就会在关联的future中storea std::future_error exception with an error code ofstd::future_errc::broken_promise。</p><p>std::future只能有一个thread等待它的结果，std::shared_future支持多个。</p><hr /><p>std::shared_future是copyable的，可以通过future.share()得到，也可以通过movefuture得到。</p><h3 id="waiting-with-a-time-limit">Waiting with a time limit</h3><h4 id="clock">Clock</h4><p>std::chrono::system_clock：通常而言，这个时钟并不稳定，因为它会有一个自动校准的过程，这甚至可能导致后来的now小于之前的now。</p><p>std::chrono::steady_clock：这个时钟非常稳定。</p><p>std::chrono::high_resolution_clock：这个时钟的period最小，因而可以提供最高的精度。</p><p>some_clock::now()返回类型是some_clock::time_point。</p><p>some_clock::period是时钟周期typedef，单位秒，是std::ratio</p><h4 id="durations">Durations</h4><p>std::chrono::duration第一个模板参数表示用来存储该时间的数据类型，第二个参数为std::ratio，用来指定该单位duration的长度。</p><p>C++ 在std::chrononamespace里提供了nanoseconds、microseconds、milliseconds、seconds、minutes、hours，它们都用足够大的integral类型表示duration。</p><p>C++14引入了std::chrono_literalsnamespace，支持用后缀h、min、ms等表示duration。</p><p>对于整数，上面两种方式是等价的。</p><p>对于浮点数，如果关注范围和精度，应使用std::chorono::duration。</p><p>当不需要截断时，也即大的单位转小的单位，转换是隐式的。但反过来则需要显式转换。C++提供了std::chrono::duration_cast用于时间单位的转换。该转换是截断而不是取整。</p><p>使用wait_for</p><p>去掉单位的整数可以用.count()获得</p><hr /><p>std::future::wait_for方法接受一个duration参数，返回类型为std::future_status，如果是timeout则说明等待时间到了，如果是ready说明future在ready状态，如果是deferred说明future的task在deferred状态。wait_for使用的是steady_clock。</p><h4 id="time-points">Time points</h4><p>std::chrono::time_point第一个模板参数为时钟类型，第二个为单位。</p><p>使用wait_until</p><p>如果只是等待固定的时间，应使用wait_until，因为它不存在虚假唤醒的问题，到达时间后自动唤醒，而wait_for则是隔一段时间唤醒一次检查条件。</p><p>std::condition_variable::wait_until返回类型为std::cv_status。</p><h4 id="functions-that-accept-timeouts">Functions that accepttimeouts</h4><p>std::future、std::condition_variable、std::this_thread::sleep_for、std::this_thread::sleep_until。</p><p>std::timed_mutex、std::recursive_timed_mutex、std::shared_timed_mutex支持try_lock_for和try_lock_until</p><h3 id="using-synchronization-of-operations-to-simplify-code">Usingsynchronization of operations to simplify code</h3><h4 id="functional-programming-with-futures">Functional programming withfutures</h4><p>Functionalprogramming指函数和外部状态无关，只和传入的参数有关，且不会修改外部状态，即只要传入参数一致，得到的结果必然相同。这种范式非常容易改成并发。</p><h4 id="synchronizing-operations-with-message-passing">Synchronizingoperations with message passing</h4><p>CSP（Communicating Sequential Process）：没有shareddata，每个thread独立运行，只基于它受到的message。实现类似于有限状态机。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221003172609737.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20221003172739758.png" /></p><h4id="continuation-style-concurrency-with-the-concurrency-ts">Continuation-styleconcurrency with the Concurrency TS</h4>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>长篇笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Modern C++ 笔记</title>
    <link href="/posts/2764666242/"/>
    <url>/posts/2764666242/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读《Effective Modern C++》时记录下的笔记</p></blockquote><span id="more"></span><h2 id="type-deduction">Type Deduction</h2><h3 id="template-deduction">Template Deduction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(ParamType param)</span></span>; <span class="hljs-comment">// ParamType是与T相关的一系列类型，比如T&amp;</span><br><span class="hljs-built_in">f</span>(expr);<br></code></pre></td></tr></table></figure><p>Case 1: ParamType is a reference or pointer, but not a universalreference</p><ol type="1"><li><p>if expr's type is a reference, ignore the reference part</p></li><li><p>Then pattern-match expr's type against ParamType to determineT.</p></li></ol><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909200540123.png" /></p><p>非常符合常识</p><hr /><p>Case 2: ParamType is a universal reference</p><ul><li>If expr is an lvalue, both T and ParamType are deduced to belvalue</li><li>If expr is an rvalue, the same as case 1.</li></ul><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909221716159.png" /></p><hr /><p>Case 3: ParamType is neither a pointer nor a reference</p><ol type="1"><li>if expr's type is a reference, ignore the reference part.</li><li>If after ignoring expr's reference-ness, expr is const, ignore that,too. If it's volatile, also ignore that.</li></ol><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909222408552.png" /></p><p>A more complecated case:</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909223542600.png" /></p><p>*右边的const表示指针指向的地址不变，即指针的const-ness，在值传递是是可以被丢弃的，而*左边的const表示指针指向的地址的内容不变，这个const-ness需要被保留</p><hr /><p>For Array &amp;&amp; pointer, if by-value, array will be deduced topointer, if reference, array will still be array, which means the lengthinformation is preserved.</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909230636595.png" /></p><p>用这个特点还可以实现模板函数得到数组长度。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909230730022.png" /></p><blockquote><p>constexpr是为了让其编译时即可用，例如</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909230930014.png" /></p></blockquote><p>建议更多使用std::array而不是built in的array</p><hr /><p>Function</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909231344387.png" /></p><hr /><p>总结</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220909231552875.png" /></p><h3 id="auto-deduction">Auto Deduction</h3><p>基本与templatededuction一致，但对于用{}进行初始化的变量会推导成<code>std::initializer_list&lt;T&gt;</code>类型，T是{}内的值的类型，值必须是单一类型。Templatededuction的T无法直接推导为<code>std::initializer_list</code>.</p><blockquote><p>auto x = {1};</p><p>auto x {1};</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910092950764.png" /></p><p>c++14中要确保函数返回值能够推导。此处的auto采用templatededuction的规则而不是auto，即不能将{}推导为std::initializer_list.Thesame is true when auto is used in a parameter type specification in aC++14 lambda.</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910094023080.png" /></p><hr /><p>总结</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910094101035.png" /></p><h3 id="decltype">decltype</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910095405309.png" /></p><p>auto在这里并不是类型推导，而是表明采用C++11的trailing return typesyntax.这种语法的好处是返回值可以用参数列表里的内容进行推导。</p><p>C++11允许单语句的lambda表达式返回类型的推导，C++14则允许所有lambda表达式和函数的推导，也就是说在C++14中上图的-&gt;decltype(c[i])可以被省略。</p><p>但是这样做实际上是存在问题的，因为auto的类型推导会消除reference-ness。</p><p>C++14引入了语法decltype(auto)，表示在类型推导时用decltype的规则。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910101416365.png" /></p><p>同样可以用于变量类型的推导。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910101651842.png" /></p><p>但是上面的函数无法正确处理右值。下面是最终版本。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910102608424.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910102617894.png" /></p><hr /><p>decltype对与name和expression有不同的表现。对于name，它产生的就是name声明的类型。对于lvalue表达式，它产生的是lvaluereference。</p><blockquote><p>对于int x, decltype(x)为int，但decltype((x))为int&amp;</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910103848200.png" /></p><p>注意f2返回了一个局部变量的引用，这是undefinedbehavior，应当避免！</p></blockquote><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910104414665.png" /></p><h3 id="view-deduced-type">View deduced type</h3><h4 id="编译期">编译期</h4><p>利用编译器报错。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910105130444.png" /></p><h4 id="运行期">运行期</h4><p>打印typeid(x).name()</p><p>typeid(x)会产生std::type_info的object，不同编译器的name方法实现不同，GNU和Clang的编译器的信息不是很易读（i表示int，P表示指针，K表示const），可以用c++filt进行解码，Microsoft的易读。</p><p>但是std::type_info::name返回的类型名is treated as if it had beenpassed to a template function as a by-valueparameter.也就是说，它的reference-ness会被忽略，const(以及volatile)会被忽略。所以并不可靠。</p><hr /><p>用库Boost.TypeIndex（非标准库），该库在不同编译器下都能得到正确的类型</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910111849615.png" /></p><blockquote><p>cvr: const、volatile、reference</p></blockquote><h2 id="auto">Auto</h2><p>涉及到vector的size时建议用auto，因为size的返回类型为<code>std::vector::size_type</code>，太长，而直接用unsigned有时候会出问题。</p><p>map的遍历也建议用auto，因为用<code>std::pair&lt;Key, Value&gt;</code>得到它内部的元素时需要注意Key类型往往和map不一致，需要加上const，忽略const会导致奇怪的错误。</p><p>在访问<code>std::vector&lt;bool&gt;</code>的元素时不要使用auto。<code>std::vector&lt;T&gt;</code>的操作符[]在T非bool的时候都返回T&amp;，但bool则返回<code>std::vector&lt;bool&gt;::reference</code>，这是因为<code>std::vector&lt;bool&gt;</code>实现时一个bit一个bool变量的值。</p><p><code>std::vector&lt;bool&gt;::reference</code>是一种proxyclass的技术，为更高效的计算等服务，需要支持隐式转换(bool)</p><p>一些显式的proxyclass有<code>std::shared_ptr</code>、<code>std::unique_ptr</code>。</p><p>Invisible proxy class(e.g.<code>std::vector&lt;bool&gt;::reference</code>)不适合用auto。更准确地说，在使用auto时，需要先将Invisibleproxy class进行类型转换（explicitly typed initializer idiom, e.g.<code>static_cast</code>）</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910143524318.png" /></p><h2 id="modern-c">Modern C++</h2><h3 id="initialize-with-and">Initialize with () and</h3><p>{} can be used in the widest variety of contexts, prevent implicitnarrowing conversions, and immune to C++'s most vexing parse(i.e.constructor with 0 arguments).</p><p>但需要注意auto和{}的冲突。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910151856767.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910151931017.png" /></p><p>对于含std::initializer_list的constructor，{}会优先该constructor（会尝试类型转换，隐式(包括narrowconversion)、显式）。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910152608826.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910152932277.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910153119644.png" /></p><p>空的{}会调用default constructor而不是Std::initializer_listconstructor</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910153316023.png" /></p><hr /><p>模板编写存在的问题</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910154859706.png" /></p><p>到底应该采用上面这种还是下面这种只有调用者知道。这个问题留待std::make_unique、std::make_shared解决。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910154937223.png" /></p><h3 id="use-alias-declaration-instead-of-typedef">Use alias declarationinstead of typedef</h3><p>alias declaration在模板方面更具优势。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910180747349.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910180758997.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910183052334.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910183244711.png" /></p><h3 id="use-scoped-enums-instead-of-unscoped-enums">Use scoped enumsinstead of unscoped enums</h3><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910183503544.png" /></p><p>enum class的优势：</p><ul><li>scoped，不会污染命名空间</li><li>不会隐式转换为整型（想要转换则用cast）</li></ul><p>scoped enum和unscoped enum都可以前向声明，默认underlyingtype为int，可以用:指定underlying type.</p><p>enum的definition也可以指定underlying type。</p><p>unscopedenum在访问(std::get&lt;&gt;)std::tuple的时候较为方便使用。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910191141198.png" /></p><p>即使用模板函数结合scoped enum，</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910191258679.png" /></p><p>最终仍需要这样。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910191410569.png" /></p><p>依然较为麻烦。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910191837714.png" /></p><h3 id="prefer-deleted-functions-to-private-undefined-ones">Preferdeleted functions to private undefined ones</h3><p>private undefined ones may still be used within the class and itsfriend class, and will fail when link. But use delete, it will fail whencompile.</p><p>deletedfunction通常声明为public，这是因为编译器优先检测accessibility再检测deleted，如果声明为private，那么编译器报错会是访问权限不够而不是deleted。</p><p>delete也可以用于防止隐式转换。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910200520073.png" /></p><p>float也被reject是因为C++倾向于将float转double。</p><p>delete还可以用于删除特化的模板函数。（private无法做到这点因为模板特化必须在namespacescope而不是class scope）</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910201337047.png" /></p><h3 id="declare-overriding-functions-override">Declare overridingfunctions override</h3><blockquote><p>函数签名可以包括the function's referencequalifier，&amp;表明当*this为lvalue时，&amp;&amp;表明当*this为rvalue时</p></blockquote><p>override的条件</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910204626088.png" /></p><p>Because little difference of function signatures between base classand derived class may cause you not actually overriding a function, it'snecessary to use override keywords to explicitly tell the compiler youwant to override the base function so that when some difference exists,compiler can send wrong messages correctly.</p><p>override虽然是关键字，但它只在特定位置被识别为关键字，也就是说函数名可以是override。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220910210120925.png" /></p><h3 id="prefer-const_iterators-to-iterators">Prefer const_iterators toiterators</h3><p>C++98使用const_iterator相当不方便，C++11和C++14则很好地支持了这一点。</p><p>C++11的container仅支持non-memberfunction的begin、end，但并不支持non-memberfunction的cbegin、cend。可以实现下图的cbegin、cend。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911074421795.png" /></p><p>std::begin在container为const时返回的类型为const_iterator。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911074012299.png" /></p><h3 id="declare-functions-noexcept-if-they-wont-emit-exceptions">Declarefunctions noexcept if they won't emit exceptions</h3><p>C++98用throw()声明函数可能抛出的所有异常，一旦实现修改，可能对整体代码有较大影响。且执行时需要检查抛出异常是否在throw声明的函数中，一旦不在，需要抛出异常、终止程序，这对性能有一定开销。</p><p>C++11只在意是否会抛出异常，即noexcept关键词。声明noexcept可以在编译时做更多的优化。</p><p>C++11中memory deallocation functions(delete anddelete[])和destructor默认noexcept，除非显式声明（比如noexcept(false)）</p><p>条件noexcept</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911092419767.png" /></p><p>当声明一个函数noexcept时，compiler并不会检查它的具体实现是否调用了non-noexcept的函数，因为一些历史遗留的函数可能是noexcept但并没有这样声明。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911101702435.png" /></p><h3 id="use-constexpr-whenever-possible">Use constexpr wheneverpossible</h3><p>const的object未必在编译时已知，而constexpr的object一定已知。</p><p>即all constexpr objects are const, but not all const objects areconstexpr</p><p>C++11constexpr只能一个语句，也就是return语句。可以用?:实现if-else，用递归实现循环。</p><p>C++14则没有该要求。</p><p>constexpr function只能用和返回literaltype(除void外的内置类型以及constexpr的构造函数的用户自定义类)</p><p>C++11中constexpr的memberfunction是隐式const的，所以不能修改成员变量（constructor除外），且void不是literaltype，所以setters不能设为constexpr，但C++14移除了这两个限制，所以可以。</p><p>constexpr在传入编译时已知的参数时是编译器已知的，否则是运行时已知的。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911112325570.png" /></p><h3 id="make-const-member-functions-thread-safe">Make const memberfunctions thread safe</h3><p>使用mutable关键字的成员变量使得即使是const的memberfunction也可以对其进行修改。</p><p>一般情况下，const的memberfunction是线程安全的，但由于mutable的成员变量可以被const的memberfunction修改，该函数不再线程安全。</p><p>如果只是添加一个互斥锁，</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911114124655.png" /></p><p>看样子能解决问题，但实际上由于std::mutex只能move，不能copy，反而使得Polynomial无法被copy了。</p><p>但没有更好的解决办法。</p><p>当只需要维护一个变量时，std::atomic可能是更高效的选择。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911133749655.png" /></p><h3 id="understand-special-member-function-generation">Understandspecial member function generation</h3><p>Generated special member functions are implicitly public and inline,and they are non-virtual unless it is a destructor derived from avirtual destructor.</p><p>只有用到了copy、move，响应的special member function才会被生成。</p><p>copy constructor和copy assignment operator之间相互独立</p><p>default move constructor、move assignment will try to do memberwisemove. If move operation is disabled for one member, use copy instead forthat member.</p><p>两个copyoperation之间相互独立，声明了一个并不会阻止编译器自动生成另一个。</p><p>两个move operation之间不独立，声明一个会阻止编译器自动生成另一个。</p><p>如果至少显式声明了一个copy operation，编译器将不会生成moveoperations。</p><p>反过来，如果至少显式声明了一个move operation，编译器也不会生成copyoperations.</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911140109104.png" /></p><p>It is better to obey the rule for copy too.</p><p>如果编译器生成的special memoryfunction能满足需求，那么可以显式地用=default。</p><p>即使编译器生成的special memoryfunction满足你的需求，也建议用=default显式声明，因为简单的修改可能对该未声明的函数产生难以察觉的影响（比如加入destructor导致默认的moveoperations失效，最终调用了copy，导致效率降低）</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911144452898.png" /></p><p>模板函数不会影响special memory function的产生。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911144724768.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911144739983.png" /></p><h2 id="smart-pointers">Smart Pointers</h2><p>除非你要用C++98，否则应用std::unique_ptr而不是std::auto_ptr</p><h3id="use-stdunique_ptr-for-exclusive-ownership-resource-management">Usestd::unique_ptr for exclusive-ownership resource management</h3><p>可以将std::unique_ptr的性能开销看作与rawptr相同。（用默认的deleter或stateless function object时）</p><p>move-only</p><p>unique_ptr的第二个模板参数可以指定析构函数</p><p>用函数需要函数指针，但用stateless function object（比如lambdaexpressions with no captures）则unique_ptr不需要额外空间。</p><p>std::unique_ptr有两种形式，<code>std::unique_ptr&lt;T&gt;</code>和<code>std::unique_ptr&lt;T[]&gt;</code>，所以不存在模糊性。</p><p><code>std::unique_ptr&lt;T&gt;</code>没有[]操作符，<code>std::unique_ptr&lt;T[]&gt;</code>没有*和-&gt;操作符</p><p><code>std::unique_ptr</code>可以轻松地转换成<code>std::shared_ptr</code></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911175645811.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911175731305.png" /></p><h3 id="use-stdshared_ptr-for-shared-ownership-resource-management">Usestd::shared_ptr for shared-ownership resource management</h3><p>std::shared_ptr占用的空间是原生指针的两倍，因为它还需要一个指向referencecount的指针。</p><p>referencecount的内存必须动态分配（std::make_shared可以避免动态分配），这样多个std::shared_ptr才能指向同一个。</p><p>Increment and decrement on reference count must be atomic.</p><p>Move不需要改变reference count，因而快于copy。</p><p>std::shared_ptr同样支持自定义deleter，但略有不同，不需要模板的第二个参数。这使得不同deleter属于同一类型，更灵活。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911193243738.png" /></p><p>自定义deleter的大小并不会影响std::shared_ptr的大小。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911194110707.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911194553588.png" /></p><p>使用shared_ptr容易犯以下错误：</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911200732659.png" /></p><p>emplace_back(this)会重复申请control block。</p><p>一种可行的解决方法是将该类T继承自<code>std::enable_shared_from_this&lt;T&gt;</code></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911200857101.png" /></p><p>使用<code>shared_from_this</code>时必须确保该object已有<code>shared_ptr</code>。</p><p>为实现这点，该类往往将ctor声明为private，用工厂函数创建。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911202057147.png" /></p><p>control block甚至还有一个虚函数，用于确保指向的物体被正确析构。</p><p>std::shared_ptr不能用于数组，也不应用于数组。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220911203126722.png" /></p><h3id="use-stdweak_ptr-for-stdshared_ptr-like-pointers-that-can-dangle">Usestd::weak_ptr for std::shared_ptr-like pointers that can dangle</h3><p>std::weak_ptr没有dereference操作。</p><p>std::weak_ptr::expired()用于检测指针是否悬空，但实际使用中往往容易线程不安全。</p><p>std::weak_ptr::lock()用于检测指针是否悬空，不悬空则返回shared_ptr，这就使得之后的使用中不会悬空。</p><p>当不需要参与对象生命周期的管理，而只在意指针是否悬空时，采用。</p><p>可以避免shared_ptr之间的循环引用的问题。</p><p>std::weak_ptr的开销可以看作和shared_ptr一致。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912083212046.png" /></p><h3id="prefer-stdmake_unique-and-stdmake_shared-to-direct-use-of-new">Preferstd::make_unique and std::make_shared to direct use of new</h3><p>std::make_unique在C++14才有，在C++11中可以这样定义。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912083738741.png" /></p><p>std::allocate_shared和std::make_shared类似，但它的第一个参数指定了一个allocator对象用于内存分配。</p><p>用new的指针作为参数初始化智能指针可能会由于异常发生内存泄漏。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912091716561.png" /></p><p>如果先执行newWidget，再执行computePriority()，再构造std::shared_ptr，在执行computePriority的时候抛出异常，那么newWidget分配的内存空间将被泄漏。而使用std::make_shared则不会有该问题（exceptionsafety）。</p><p>用new出来的指针作为参数初始化shared_ptr需要两次内存分配（一次new，一次controlblock），但std::make_shared会一次性分配内存给这两个内容，因而效率更高。</p><hr /><p>make的缺点</p><ul><li>不能指定deleter</li><li>采用parentheses initializer而不是bracedinitializer。如果想要使用bracedinitializer，可以用auto声明{}对象再传入。</li><li>由于controlblock和object的内存空间是一并allocate的，所以必须一起deallocate。所以只有当所有std::shared_ptr和std::weak_ptr被释放之后（referencecount和weak count都为0），它们的空间才会被释放（这也是为什么需要weakcount）。所以对于一些特别大的而且最后一个指针被析构特别迟的object，make并不是很实用，直接new对内存的利用效率会更高（只需要等最后一个shared_ptr被析构就会被释放）。</li><li>对于自己定义了new和delete的类，make并不适用，因为它们往往只分配自己需要的确切空间。</li></ul><blockquote><p>事实上，只要注意一点，new也可以exception safety.</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912133351058.png" /></p><p>但是注意这次传递的是lvalue，也就意味着copy，而copy对于std::shared_ptr意味着atomic的increment，并不高效，应采用下面的方法。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912133844431.png" /></p></blockquote><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912134023376.png" /></p><h3id="when-using-the-pimpl-idiom-define-special-member-functions-in-the-implementation-file">Whenusing the Pimpl Idiom, define special member functions in theimplementation file</h3><h4 id="pimpl-idiom-in-c98">Pimpl Idiom in C++98</h4><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912160236004.png" /></p><p>在上面的实现中，widget.h需要include<code>&lt;string&gt;</code>、<code>&lt;vector&gt;</code>、<code>gadget.h</code>，这意味着编译更加费时而且一旦这些文件有修改都需要重新编译。</p><p>而PimplIdiom将这一系列private且没有getter的成员变量封装到struct中，struct的具体成员组成放到.cpp中，使得includewidget.h的文件不再include<code>&lt;string&gt;</code>、<code>&lt;vector&gt;</code>、<code>gadget.h</code>。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912160252560.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912160728733.png" /></p><h4 id="pimpl-idiom-with-smart-pointer">Pimpl Idiom with smartpointer</h4><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912160932909.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912160950413.png" /></p><p>这样子的实现看样子没有问题且能正确编译，但是一旦使用该类编译器就会报错。这是因为默认的析构函数是inline的，在头文件中，而头文件的该类型是incomplete的，所以应在头文件中声明该析构函数并在.cpp中实现（=default或={}），确保实现时类型已经complete。（此问题只对std::unique_ptr出现，std::shared_ptr不要求类型完整）</p><p>值得注意的是，由于声明了析构函数，编译器将不会产生moveoperations，而move对于std::shared_ptr的效率来说意义较大，所以也应声明并在cpp中实现（如果在.h中实现会报相同的错，因为move需要destroy）</p><p>此外，由于编译器不会为含move-only的成员变量的类生成copyoprations，需要自己实现deep copy。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912162714114.png" /></p><h2 id="rvalue-references-move-semantics-and-perfect-forwarding">RvalueReferences, Move Semantics and Perfect Forwarding</h2><h3 id="stdmove-and-stdforward">std::move and std::forward</h3><p>它们实际上不做任何事（runtime），而只是cast。</p><p>std::move无条件地将它的参数cast成rvalue</p><p>std::forward cast to rvalue only if its argument was initialized withanrvalue.（也就是是让lvalue保持lvalue，rvalue保持rvalue。由于函数的参数始终为lvalue，所以这是必要的）</p><p>don't declare objects const if you want to be able to move from them.这样的做法经常会变成copy。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912191705100.png" /></p><h3id="distinguish-universal-references-from-rvalue-references">Distinguishuniversal references from rvalue references</h3><h4 id="universal-reference">universal reference</h4><p>共两种情况</p><ul><li><p>作为模板参数，必须严格是<code>T&amp;&amp;</code>（<code>const T&amp;&amp;</code>、<code>std::vector&lt;T&gt;&amp;&amp;</code>之类的都不是universalreference）且存在类型推导</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912193527006.png" /></p></li><li><p>auto</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912193555456.png" /></p></li></ul><p>下面的例子由于不存在类型推导所以不是universal reference.</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912194642207.png" /></p><p>下图则属于univeresal reference。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912194838777.png" /></p><p>auto&amp;&amp;通常出现在C++14的lambda表达式的参数列表中。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912200048684.png" /></p><h3id="use-stdmove-on-rvalue-references-stdforward-on-universal-references">Usestd::move on rvalue references, std::forward on universalreferences</h3><p>即使一个物体不支持move，在作为函数的返回值时也可以将它转成rvalue，这并不会影响什么，程序会照常copy它，而当它后来改变成支持move时就能自然而然得到效率提高。</p><p>没有必要将函数内部使用且返回的局部变量cast成rvalue，因为C++一直有一个机制returnvalueoptimization（RVO），即当函数的返回值是它内部的局部变量时，将要返回的局部变量直接构造在分配好的用于返回的内存空间，这样就避免了copy。</p><p>而一旦使用std::move，就会不满足RVO的条件，那么函数存放返回值的地方就不会存着该局部变量，需要真正执行一次move。</p><p>当函数有不同的执行路径，可能返回不同的局部变量时，RVO可能不会被实现。但这种情况依然不需要使用std::move。因为当编译器知道自己不能实现时，会自行将返回值转成右值，即std::move。</p><p>perfect-forward不会为了确认参数类型而构造临时object（比如literal的字符串传给universalreference，再forward，这个literal在传给universalreference的时候不需要被构造，而是直接forward(literal)）</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220912212334979.png" /></p><h3 id="avoid-overloading-on-universal-references">Avoid overloading onuniversal references</h3><p>universalreference能匹配绝大多数的参数，如果重载了int，但调用时用short，short会被universalreference匹配上而不是int，这往往会造成不想要的结果。</p><p>Compiler产生的copy是constT&amp;，一旦传参数时传的不是const，universalreference的函数就会因为准确匹配而代替copy操作。</p><p>当涉及到继承时，copy和move也不会像想象中那样运作。</p><blockquote><p>Person实现了universal reference</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220913230211061.png" /></p><p>Person(rhs)和Person(std::move(rhs))都会匹配上universalreference（rhs是SpecialPerson而不是Person，这就导致没法直接匹配上）。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220913230419704.png" /></p><h3id="familiarize-yourself-with-alternatives-to-overloading-on-universal-references">Familiarizeyourself with alternatives to overloading on universal references</h3><h4 id="use-tag-dispatch">Use tag dispatch</h4><p>通过引入一个新的参数来解决问题，只要该参数在我们想调用重载函数时不会和universalreference的参数匹配上就可以了。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220914172028904.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220914172044434.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220914172233280.png" /></p><p>一些编译器会优化掉这些运行时并不起作用的tag。</p><hr /><p>但这还只解决了部分问题，仍存在两个问题。</p><ul><li><p>编译器生成的copy是const T&amp;，想调用copy时依然可能被universalreference抢占。</p></li><li><p>子类调用它的copy、move依然会出现匹配上universalreference的问题。</p></li></ul><p>第一个问题可以用以下方法解决。（std::decay用于去reference-ness和const-ness和volatile-ness）</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915092310444.png" /></p><p>第二个问题的解决需要用到<code>std::is_base_of&lt;T1, T2&gt;</code>，当T1是T2基类时为true。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915092632548.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915092714028.png" /></p><p>再将int问题一并解决，最终解决方案如下</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915092959859.png" /></p><h4 id="trade-off">Trade-off</h4><p>perfect-forward不会为了确认参数类型而构造临时object（比如literal的字符串传给universalreference，再forward，这个literal在传给universalreference的时候不需要被构造，而是直接forward(literal)）。</p><p>一些参数无法被forward。</p><p>编译器的报错可能难以读懂。可以用static_assert辅助。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915094656794.png" /></p><p>但是由于std::forward在static_assert的上方，static_assert的信息往往在很长的std::forward报错的下方。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915094759775.png" /></p><h3 id="understand-reference-collapsing">Understand referencecollapsing</h3><p>模板实例化的时候会发生referencecollapsing，将reference-to-reference变成reference.</p><p>If either reference is an lvalue reference, the result is an lvaluereference. Otherwise (i.e., if both are rvalue references) the result isan rvalue reference.</p><p>由于该机制，forward可以如下图简单实现。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915101121245.png" /></p><p>auto同样会发生reference collapsing。</p><p>所以universal reference的本质就是typededuction区分lvalue和rvalue、reference collapsing发生。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915101912509.png" /></p><h3id="assume-that-move-operations-are-not-present-not-cheap-and-not-used">Assumethat move operations are not present, not cheap and not used</h3><p>move operations并不总像我们想象中那样快。</p><p>对于大多数标准容器，它们内部有指针，指向heap上分配的空间，这部分的move是很快的，只需要指针的赋值。</p><p>但对于特殊的容器，比如std::array，它的数据是放在object内部的，所以move时需要将整个object内的数据move，并不很快。</p><p>std::string的很多种实现里都有一种small stringoptimization（SSO）的机制，即将长度小于等于15的字符串直接放在object内部而不是动态分配heap。而短字符串是很多应用场景下的字符串用法，所以它的move也并没有想象中那么快。</p><p>由于C++98的代码遗留问题，为了保证exceptionsafety，标准库中的一些move只有当noexcept的时候才会被编译器使用</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915105423152.png" /></p><h3id="familiarize-yourself-with-perfect-forwarding-failure-cases">Familiarizeyourself with perfect forwarding failure cases</h3><p>对于这样一个函数</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915163112608.png" /></p><p>如果下面两种形式都能正确被编译执行，那就是成功forward。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915163232780.png" /></p><ul><li>braced initializers<ul><li>compiler不会直接将{}类型推导为std::initializer_list</li><li>可以引入一个auto变量（std::initializer_list）</li></ul></li><li>declaration-only integral const static data members<ul><li>这种变量实际上不会被分配内存，是编译期的常量，所以没法生成reference。</li><li>可以通过definition解决。</li></ul></li><li>template and overloaded function names<ul><li>对于有重载或模板类的函数，无法正确推导出具体是哪个。</li><li><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915170337452.png" /></li><li><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915170402584.png" /></li></ul></li><li>bitfields<ul><li><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915163943933.png" /></li><li>bitfield实现了按位的任意拆分访问，因为无法生成对任意位的reference，所以是不允许对非const的bitfield进行的。</li><li>通过copy解决</li><li><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915164726436.png" /></li></ul></li></ul><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220915162856697.png" /></p><h2 id="lambda-expressions">Lambda Expressions</h2><p>lambda表达式会被编译成closure class，运行时会生成closure。</p><h3 id="avoid-default-capture-modes">Avoid default capture modes</h3><ul><li><p>当使用default by-reference [&amp;]capture时，往往容易忽略捕捉到的变量的生命周期，导致dangling。比如将lambda表达式存入vector中，而该lambda中含有局部变量的reference，一旦离开这个scope就会导致lambda里面捕捉的referencedangling。</p></li><li><p>静态变量是不需要捕获也不能显式捕获的，静态变量相当于引用，可以直接在lambda表达式中使用。当使用defaultby-value [=] capture时，容易误以为是值捕获。</p></li><li><p>当想要捕获成员变量（divisor）时</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916150853258.png" /></p><p>它的实际效果其实如下图</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916150941863.png" /></p><p>并不是我们想要的值捕获</p></li></ul><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916151047008.png" /></p><h3 id="use-init-capture-to-move-objects-into-closures">Use init captureto move objects into closures</h3><p>C++14引入了init capture（generalized lambdacapture）机制，类似于函数的初始化，等号左边的作用域和右边的作用域不同。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916161647661.png" /></p><p>C++11可以用std::bind模拟。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916161802715.png" /></p><p>std::bind会将左值以copy的方式，右值以move的方式传递。</p><p>声明为const是因为默认情况下lambda表达式的函数为const。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916221116091.png" /></p><h3 id="use-delctype-on-auto-parameters-to-stdforward-them">Use delctypeon auto&amp;&amp; parameters to std::forward them</h3><p>C++14有一个新特性——genericlambdas，即参数列表中的参数类型可以用auto。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916222340494.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916222354988.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916222550752.png" /></p><h3 id="prefer-lambdas-to-stdbind">Prefer lambdas to std::bind</h3><ul><li><p>如果使用std::bind，对于有重载的函数，由于编译器不能推断是哪个，会编译错误。为解决该错误需要static_cast函数的类型。</p></li><li><p>使用std::bind对某些表达式需要较复杂的处理。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916230834674.png" /></p><p>上面的lambda表达式不能直接改成下面的。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916230857538.png" /></p><p>而应该这样。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916231019315.png" /></p><p>不过C++11由于模板参数不能省略，则更麻烦一点。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916231121757.png" /></p></li><li><p>由于用std::bind实现可能更复杂，这也导致它更难以被inline实现。</p></li></ul><p>还有例子可以体现复杂性。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916231740442.png" /></p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220916231752174.png" /></p><p>构造std::bind时std::bind始终复制它的参数，而调用构造好的bindobject时传递的参数为reference。</p><p>在C++14中，没有理由继续使用std::bind。</p><p>但在C++11中，由于lambda表达式不支持auto，可以用std::bind调用模板函数来实现；由于lambda表达式不支持movecapture，可以用std::bind结合lambda表达式实现。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220917100630054.png" /></p><h2 id="the-concurrency-api">The Concurrency API</h2><h3 id="prefer-task-based-programming-to-thread-based">Prefer task-basedprogramming to thread-based</h3><p>std::async是task-based的，它可以减轻管理线程的负担，而且可以得到执行的任务的返回值。而std::thread则无法得到返回值，并且如果throw了exception，那么将导致程序终止。</p><p>除非对线程很了解并且需要自定义线程的管理方式来极大化运行效率、涉及底层API的调用或者需要设置线程的优先级，否则最好使用std::async。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220917131000217.png" /></p><h3 id="specify-stdlaunchasync-if-asnchronicity-is-essential">Specifystd::launch::async if asnchronicity is essential</h3><p>std::async可以用std::launch指定policy。std::launch::async使得它只能在其他线程上运行，std::launch::deferred使得它只有在它返回的future的get或wait方法被调用时才会被执行，也就是同步在该线程上执行。std::async的默认值实际上就是std::launch::async|std::launch::deferred。</p><p>默认的std::async不能很好地和thread_localvariable一同使用，因为无法控制该task在哪个线程中使用。</p><p>deferred的线程不会被wait_for阻塞，而且由于它只有在它返回的future的get或wait方法被调用时才会被执行，下面的代码并不能正常工作（当fut为deferred的时候）。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220921221852361.png" /></p><p>这种问题并不容易被发现，只有当线程使用较多，程序倾向于分配deferred的时候才容易发生。</p><p>为了判断fut是否是deferred，可以用wait_for函数，因为如果是deferred则它的返回值是std::future_status::deferred。由于不需要等待，所以wait_for(0s)。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220921222435507.png" /></p><p>可以直接使用默认的std::async的场合</p><ul><li>fut的get或wait一定会被调用 或者 该任务允许不被执行</li><li>使用wait_for或wait_until的地方应对deferred作检查</li><li>不在意用的是那个thread的thread_local变量</li></ul><p>当需要异步时，可以直接指定。下面提供了一个方便的函数。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220921225007282.png" /></p><p>C++14中可以直接用auto指定返回类型。</p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220921225243340.png" /></p><h3 id="make-stdthreads-unjoinable-on-all-paths">Make std::threadsunjoinable on all paths</h3><p>std::thread object: C++线程的实例</p><p>an underlying thread: 计算机中真正的线程</p><p>std::threadobject有两个状态，joinable和unjoinable。joinable指underlyingthread能够或者正在运行，被阻塞或等待调度。unjoinable包括default-constructed、bemoved from、have been joined、have beendetached（即没有underlying的thread就是unjoinable）。</p><p>joinable的thread的析构发生时，程序会终止。</p><p>因而使得所有thread在out of scope的时候都unjoinable是很重要的。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220921234105788.png" /></p><p>注意std::thread最后声明，因为std::thread一旦被初始化随时可能运行，要确保其他变量已经初始化好了。对于unjoinable的对象调用join、detach是未定义行为，应避免。</p><p>由于std::thread object从joinable变成unjoinable只能通过functioncall比如join、detach、moveoperation，而在析构发生时它们不会被调用，所以不会存在多线程的datarace现象导致析构时的判断过时。</p><p>析构时join对性能有一定影响，可能会造成不必要的等待（以及hungprogram）。析构时detach会造成预料之外的数据修改。</p><p>要想更好地实现，需要与underlying thread进行通信。</p><p>由于上面的ThreadRAII实现了析构函数，编译器将不会生成moveoprations。但理应支持。</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220921235811499.png" /></p><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220921235842236.png" /></p><h3 id="be-aware-of-varying-thread-handle-destructor-behavior">Be awareof varying thread handle destructor behavior</h3><p>线程的返回值既不能存在被调用的线程（callee）中（因为执行完就销毁了），也不能以future的形式存放在调用线程的线程（caller）中（因为future可以用来move创建std::shared_future，std::shared_future又可以被多次copy），而是放在动态申请的空间SharedState中。</p><ul><li>The destructor for the last future referring to a shared state for anon-deferred task launched via std::async blocks until the taskcompletes</li><li>The destructor for all other futures simply destroys the futureobject.</li></ul><hr /><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220923144741075.png" /></p><h2 id="something-else-to-learn">Something else to learn</h2><p>The Curiously Recurring Template Pattern(CRTP)</p><p>std::multiset</p><p>std::enable_if、SFINAE</p><p>std::launch::async当真的没有线程可以分配时会发生什么</p><p>C++14支持单引号作为数字分隔符</p><p>std::promise</p>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>长篇笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep Learning</title>
    <link href="/posts/3302720027/"/>
    <url>/posts/3302720027/</url>
    
    <content type="html"><![CDATA[<blockquote><p>看B站台湾大学教授李宏毅的深度学习课程的笔记</p></blockquote><span id="more"></span><h1 id="deep-learning">Deep Learning</h1><h2 id="基本概念">基本概念</h2><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220404171605945.png" alt="image-20220404171605945" style="zoom:50%;" /></p><p>在监督学习中，数据集一开始可以粗略分为<strong>训练集</strong>和<strong>测试集</strong>。训练集是用于训练模型的数据集，往往已经打好了标签。测试集是模型处于应用阶段时真正处理的数据，所以对于模型训练是未知的。</p><p>用数据训练模型时，为减少过拟合的发生，使模型在测试集上也能表现出类似训练集上的性能，往往将训练集划分出一部分作为<strong>开发集</strong>（Dev），这部分开发集不参与模型训练，而只是用于检验训练出来的模型是否能够较好地应用于解决问题。</p><h2 id="线性模型">线性模型</h2><p><strong>model</strong>: <span class="math inline">\(\hat y=\omega*x +b\)</span></p><p><strong>Training Loss</strong>(Error): <spanclass="math inline">\(loss = (\hat y - y)^2=(\omega * x -y)^2\)</span></p><p><strong>Mean Square Error</strong>(MSE): <spanclass="math inline">\(cost = \frac{1}{N}\sum^N_{n=1}(\haty_n-y_n)^2\)</span></p><h3 id="穷举法">穷举法</h3><p>穷举<spanclass="math inline">\(\omega\)</span>的值，取cost最小的<spanclass="math inline">\(\omega\)</span>作为训练结果</p><p>MSE随着数据集规模的增大先减小后增大，转折点之前为<strong>欠拟合</strong>，转折点之后为<strong>过拟合</strong>。</p><h3 id="梯度下降算法">梯度下降算法</h3><ul><li>利用函数的导数不断逼近极小值的方法。</li><li>只能求解局部最小值，不保证是全局最小值，是一种贪心算法</li><li>实际应用中往往没有很多局部最小值，更多的是鞍点</li><li>要对数据集所有数据进行处理，效率较低</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220404144348885.png" alt="image-20220404144348885" style="zoom:50%;" /></p><p><span class="math inline">\(\omega = \omega - \alpha\frac{\partialcost}{\partial\omega}\)</span>，其中<spanclass="math inline">\(\alpha\)</span>为学习率。</p><p>不断迭代<spanclass="math inline">\(\omega\)</span>直到它收敛（cost收敛）。</p><p>如果发现cost没有收敛到一定的值而是发散，则本次训练失败，很可能是由学习率太大引起。</p><p>为了观察训练数据的趋势，将迭代过程中得到的cost值记为<spanclass="math inline">\(C_0, C_1,C_2,...\)</span>，对其作一定的平滑处理，<spanclass="math inline">\(C_0&#39;=C_0, C_i&#39;=\beta C_i +(1-\beta)C_{i-1}&#39;\)</span></p><h3id="随机梯度下降stochastic-gradient-descent">随机梯度下降（StochasticGradient Descent）</h3><p>不取cost，而是通过随机取一个样本的loss引入一个随机的噪声，这样能够克服鞍点，且运算效率较高。</p><p>对于<span class="math inline">\(\hat y_n=x_n\cdot\omega\)</span>，有下图</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220404165316798.png" alt="image-20220404165316798" style="zoom:80%;" /></p><h3 id="批量梯度下降mini-batch">批量梯度下降（mini-batch）</h3><p>将样本均分为若干组，每组并行用梯度下降算法，组间使用随机梯度下降算法，效率较高又能较稳定地收敛。</p><h2 id="计算图computational-graph">计算图（Computational Graph）</h2><p>当参数较多时，样本之间的关系往往呈现非常复杂的结构。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220404192214389.png" alt="image-20220404192214389" style="zoom:50%;" /></p><p>这时候往往用矩阵表示相邻层级间的函数关系。</p><p>如果只是简单地用一个变换矩阵和一个bias从上一层级得到下一层级，则最后得到的层级一定可以从第一层级直接变换得到。<span class="math display">\[\hat y=W_2(W_1\cdot X+b_1)+b_2=W_2W_1X+W_2b_1+b_2=WX+b\tag 1\]</span> 那么多层级就变得没有了意义。</p><p>所以需要引入一个非线性的函数<spanclass="math inline">\(\sigma\)</span>，<span class="math inline">\(\haty_1 = W_1\cdot X + b_1 + \sigma\)</span>。</p><p>对于（1）式，可以绘制出它的计算图如下。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220404193012558.png" alt="image-20220404193012558" style="zoom:50%;" /></p><p>更准确地，应绘制成下图。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220404193155353.png" alt="image-20220404193155353" style="zoom: 33%;" /></p><h3 id="计算图的梯度运算">计算图的梯度运算</h3><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220404193445856.png" alt="image-20220404193445856" style="zoom: 33%;" /></p><p>前馈时得到<span class="math inline">\(\frac {\partial z}{\partialx}\)</span>和<span class="math inline">\(\frac{\partial z}{\partial\omega}\)</span>，后馈时根据计算好的<span class="math inline">\(\frac{\partial z}{\partial x}\)</span>和<spanclass="math inline">\(\frac{\partial z}{\partial\omega}\)</span>，利用链式法则得到<spanclass="math inline">\(\frac{\partial L}{\partial x}\)</span>和<spanclass="math inline">\(\frac{\partial L}{\partial\omega}\)</span>，这就是梯度运算时需要用到的梯度。</p><h2 id="pytorch">PyTorch</h2><ul><li>torch中基本的数据类型为Tensor，在运用tensor类进行计算时往往会构建计算图，它包含data和grad，它们也都是Tensor类型的</li><li>记一个Tensor类的变量为tensor，则有<ul><li><code>tensor = torch.Tensor([预估计值])</code></li><li><code>tensor.data</code>返回的也是一个Tensor类的值，但不会构建运算图，<code>tensor.Item()</code>返回python标准数据类型</li><li>默认情况下tensor不含梯度，但可以通过<code>tensor.requires_grad = True</code>使其包含梯度</li><li>tensor与python标准类型的数据的运算返回结果依然为Tensor类</li><li><code>tensor.zero_()</code>实现清零，训练时梯度使用一次后往往要清零，因为要重新计算。</li><li>调用一个含Tensor类的方法相当于完成了一次前馈计算，通过<code>tensor.backward()</code>完成后馈计算，更新我们需要的梯度</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>长篇笔记</tag>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>python</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学深度学习</title>
    <link href="/posts/3008052840/"/>
    <url>/posts/3008052840/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读《动手学深度学习》时的笔记</p></blockquote><span id="more"></span><h2 id="预备知识">预备知识</h2><p><code>tensor.shape</code> 沿每个轴的长度</p><p><code>tensor.numel()</code> 元素个数</p><p><code>tensor.reshape(a,b)</code> 用-1来自动计算剩下的维度</p><p><span class="citation"data-cites="是矩阵乘法">@是矩阵乘法</span>，*是矩阵元素相乘</p><p>广播机制：行向量与列向量相加时行向量复制行，列向量复制列。</p><p>X[:] = X + Y和X += Y不会分配新内存</p><p><code>X.numpy()</code> 将tensor转ndarray</p><p><code>torch.tensor(X)</code> 将ndarray转tensor</p><p><code>a.item()</code> 大小为1的张量转标量</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220718115137012.png" /></p><h3 id="范数">范数</h3><p>用于表征向量的大小。</p><p><span class="math inline">\(L_2\)</span>范数<spanclass="math inline">\(||\vec x||_2=\sqrt{\sum_{i=1}^nx_i^2}\)</span></p><p><span class="math inline">\(L_1\)</span>范数<spanclass="math inline">\(||\vec x||_1=\sum_{i=1}^n|x_i|\)</span></p><p><span class="math inline">\(L_p\)</span>范数<spanclass="math inline">\(||\vecx||_p=(\sum_{i=1}^n|x_i|^p)^{1/p}\)</span></p><h2 id="线性神经网络">线性神经网络</h2><h3 id="线性回归">线性回归</h3><p><strong>解析解</strong> <span class="math display">\[\vec w = (X^TX)^{-1}X^T\vec y\]</span></p><p><strong>小批量随机梯度下降</strong>(minibatch stochastic gradientdescent)</p><p>随机抽样一固定样本数量的小批量<spanclass="math inline">\(\Beta\)</span> <span class="math display">\[(\vec w,b)\leftarrow(\vecw,b)-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{(\vecw,b)}l^{(i)}(\vec w,b)\]</span> 也即 <span class="math display">\[\vec w\leftarrow\vecw-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{\vec w}l^{(i)}\vec w\\b\leftarrow b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{b}l^{(i)}b\]</span></p><h3 id="softmax回归">softmax回归</h3><p>解决分类问题，one-hot编码</p><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220721084841671.png" /><span class="math display">\[\vec o=\matrix W\vec x + \vec b\]</span></p><p>为了使输出的概率维持在0~1之间，需要对输出做校准（calibration），即通过softmax函数。<span class="math display">\[\hat {\vec y} = softmax(\vec o),其中\hat {y_j} = \frac {exp(o_j)}{\sum_kexp(o_k)}\]</span> 损失函数为 <span class="math display">\[\begin{align}l(\vec y, \hat{\vec y}) =&amp; -\sum_{j=1}^qy_jln\hat{y_j},q为独热编码向量的长度\\=&amp; ln\sum_{k=1}^q exp(o_k)-\sum_{j=1}^qy_jo_j\end{align}\]</span> 导数为 <span class="math display">\[\part_{o_j}l(\vec y, \hat {\vecy})=\frac{exp(o_j)}{\sum_{k=1}^qexp(o_k)}-y_j=softmax(\vec o)_j - y_j\]</span></p><hr /><p>为加速计算，往往对小批量数据采用矢量化的操作。如果用<spanclass="math inline">\(\matrixX\)</span>表示批量的样本，一行为一个样本的所有特征，则 <spanclass="math display">\[\begin{align}\matrix O=&amp;\matrix X \matrix W + \vec b\\\hat {\matrix Y}=&amp;softmax(\matrix O)\end{align}\]</span> 其中，<span class="math inline">\(\hat {\matrixY}\)</span>的一行对应一个样本的预测结果。</p><hr /><p>实际使用中，由于<spanclass="math inline">\(exp(o_j)\)</span>容易发生上溢，往往要进行规范化的操作。<span class="math display">\[\begin{align}\hat{y_j} =&amp; \frac{exp(o_j-max(o_k))exp(max(o_k))}{\sum_kexp(o_k-max(o_k))exp(max(o_k))}\\=&amp;\frac{exp(o_j-max(o_k))}{\sum_kexp(o_k-max(o_k))}\end{align}\]</span>如果用该计算结果计算交叉熵，由于精度限制，会出现下溢。所以计算交叉熵不能直接使用该计算结果，而应使用下式。<span class="math display">\[\begin{align}log(\hat{y_j})=&amp;log(\frac{exp(o_j-max(o_k))}{\sum_kexp(o_k-max(o_k))})\\=&amp;o_j-max(o_k)-log(\sum_k exp(o_k - max(o_k)))\end{align}\]</span></p><h2 id="多层感知机multilayer-perceptron-mlp">多层感知机（MultilayerPerceptron, MLP）</h2><p>多层感知机是最简单的深度网络。</p><p>直接地在线性神经网络中添加层并不能使我们的模型表达更复杂的结构，它依然会退化为线性模型。所以，在仿射变换之后，还需要对每个隐藏单元应用非线性的激活函数<spanclass="math inline">\(\sigma\)</span>。激活函数的输出被称为活性值（activations）。<span class="math display">\[\begin{align}\matrix H=&amp;\sigma(\matrix X \matrix W^{(1)} + \vec b^{(1)})\\\matrix O=&amp;\matrix H\matrix W^{(2)}+\vec b^{(2)}\end{align}\]</span></p><p>通常，为了更高效的内存在硬件中的分配和寻址，层的宽度选择2的若干次幂。</p><h3 id="常见的激活函数">常见的激活函数</h3><p>修正线性单元（Rectified linear unit，ReLU） <spanclass="math display">\[ReLU(x)=max(x, 0)\]</span> 它有一些变体如参数化ReLU（pReLU），<spanclass="math inline">\(pReLU(x)=max(0,x)+\alpha min(0, x)\)</span></p><hr /><p>sigmoid函数（也叫挤压函数） <span class="math display">\[sigmoid(x)=\frac{1}{1+exp(-x)}\]</span> <imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220726174254431.png" /></p><p>导数为<spanclass="math inline">\(sigmoid(x)(1-sigmoid(x))\)</span></p><hr /><p>tanh函数（双曲正切） <span class="math display">\[tanh(x)=\frac{1-exp(-2x)}{1+exp(-2x)}\]</span> <imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220726174228256.png" /></p><p>导数为<span class="math inline">\(1-tanh^2(x)\)</span></p><h3 id="模型选择欠拟合和过拟合">模型选择、欠拟合和过拟合</h3><p>用于对抗过拟合的技术称为正则化（regularization）</p><p>容易引起过拟合的原因：</p><ul><li>可调整参数数量过多</li><li>参数的取值范围较大</li><li>训练样本数量较少</li></ul><h4 id="数据集处理">数据集处理</h4><p><strong>K折交叉验证</strong></p><p>当训练数据稀缺时，将原始训练数据分成K个不重叠的子集，然后执行K次模型训练和验证，每次在K-1个子集上进行训练，并在剩余一个子集上进行验证，最后通过对K次实验的结果取平均来估计训练和验证误差。</p><h4 id="正则化技术">正则化技术</h4><p><strong>范数与权重衰减</strong></p><p>权重衰减（weightdecay）是最广泛使用的正则化技术之一，通常也被称为<spanclass="math inline">\(L_2\)</span>正则化，这项技术通过函数与零的距离来衡量函数的复杂度。</p><p>为保证权重向量比较小，常用方法是将范数作为惩罚项加入到损失函数中。</p><p><spanclass="math inline">\(L_1\)</span>正则化线性回归通常被称为套索回归（lassoregression），会导致模型将权重集中在一小部分特征上，而将其他权重清除为零，称为特征选择。</p><p><spanclass="math inline">\(L_2\)</span>正则化线性模型构成经典的岭回归（ridgeregression）算法，它对权重向量的大分量施加了巨大的惩罚，使得模型偏向在大量特征上均匀分布权重的模型。</p><p>对于一个样本，有 <span class="math display">\[L_2=L(\vec w, b)+\frac{\lambda}{2}||w||^2\]</span> <spanclass="math inline">\(L_2\)</span>正则化回归的小批量随机梯度下降更新如下<span class="math display">\[\vec w\leftarrow(1-\eta\lambda)\vecw-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\vec x^{(i)}(\vec w^T\vecx^{(i)}+b-y^{(i)})\]</span></p><p><strong>暂退法</strong></p><p>向每一层添加无偏的噪声。</p><p>每个中间活性值h以暂退概率p由随机变量h'替换，即 <spanclass="math display">\[h&#39;=\begin{cases}0&amp;,概率为p\\\frac{h}{1-p}&amp;,其他情况\end{cases}\]</span> 通常在测试时不会使用暂退法。</p>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>长篇笔记</tag>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>python</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES101笔记</title>
    <link href="/posts/2887251847/"/>
    <url>/posts/2887251847/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学">计算机图形学</h1><h2 id="变换transformation">变换（Transformation）</h2><p><strong>MVP</strong></p><ul><li>Model transformation （placing objects）</li><li>View transformation（placing camera）</li><li>Projection transformation</li></ul><h3 id="二维变换">二维变换</h3><h4 id="线性变换">线性变换</h4><h5 id="定义">定义</h5><p>对于变换后的x‘、y’，如果满足以下关系 <span class="math display">\[x&#39;=ax+bx\\y&#39;=cx+dy\]</span></p><p>则称这种变换为线性变换。线性变换可以用矩阵方式表示为 <spanclass="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\end{matrix}\right]=M \times\left[\begin{matrix}x\\y\end{matrix}\right]\]</span> 其中M称为变换矩阵，有 <span class="math display">\[M=\left[\begin{matrix}a &amp; b\\c &amp; d\end{matrix}\right]\]</span></p><h5 id="常见变换矩阵">常见变换矩阵</h5><h6 id="缩放矩阵scale-matrix">缩放矩阵（Scale Matrix）</h6><p><span class="math display">\[S(s_x,s_y)=\left[\begin{matrix}s_x &amp; 0\\0 &amp; s_y\end{matrix}\right]\]</span></p><h6 id="对称矩阵refletion-matrix">对称矩阵（Refletion Matrix）</h6><p><span class="math display">\[关于y轴对称\left[\begin{matrix}-1 &amp; 0\\0 &amp; 1\end{matrix}\right]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \关于x轴对称\left[\begin{matrix}1 &amp; 0\\0 &amp; -1\end{matrix}\right]\]</span></p><h6 id="错切矩阵shear-matrix">错切矩阵（Shear Matrix）</h6><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220111105034614.png" /><span class="math display">\[\left[\begin{matrix}1 &amp; \frac a b\\0 &amp; 1\end{matrix}\right]\]</span></p><h6 id="旋转矩阵rotation-matrix">旋转矩阵（Rotation Matrix）</h6><p><span class="math display">\[R_\theta=\left[\begin{matrix}cos\theta &amp; -sin\theta\\sin\theta &amp; cos\theta\end{matrix}\right]\]</span></p><p><span class="math inline">\(R_\theta\)</span>是正交矩阵。</p><ul><li><p>由三角函数性质可知<spanclass="math inline">\(R_{-\theta}=R_\theta^T\)</span></p></li><li><p>由定义知<span class="math inline">\(R_{-\theta}=R_\theta^{-1}\)</span></p></li></ul><h4 id="仿射变换affine-map">仿射变换（Affine Map）</h4><p>当引入平移（Translation）时，图形的变换不再是简单的线性变换。对于以下关系<span class="math display">\[x&#39;=ax+by+t_x\\y&#39;=cx+dy+t_y\]</span> 不能简单地用矩阵乘法表示，而需要引入加法。 <spanclass="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\end{matrix}\right]=\left[\begin{matrix}a &amp; b\\c &amp; d\end{matrix}\right]\times\left[\begin{matrix}x\\y\end{matrix}\right]+\left[\begin{matrix}t_x\\t_y\end{matrix}\right]\]</span> 称以上变换为仿射变换。</p><h4 id="齐次坐标">齐次坐标</h4><blockquote><p>为消除平移的特例，引入齐次坐标的概念。</p></blockquote><p>令2D point <span class="math inline">\(= (x,y,1)^T\)</span>，2Dvector<span class="math inline">\(=(x,y,0)\)</span></p><p>此时，矩阵的平移可以表示为 <span class="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\\w&#39;\end{matrix}\right]=\left[\begin{matrix}1 &amp; 0 &amp; t_x\\0 &amp; 1 &amp; t_y\\0 &amp; 0 &amp; 1\end{matrix}\right]\times\left[\begin{matrix}x\\y\\1\end{matrix}\right]=\left[\begin{matrix}x + t_x\\y + t_y\\1\end{matrix}\right]\]</span> 对于point + point会出现的第三位非0、1的数，我们做以下规定<span class="math display">\[\left[\begin{matrix}x\\y\\w\end{matrix}\right]\ is\ the\ 2D\ point\left[\begin{matrix}x/w\\y/w\\1\end{matrix}\right],w\neq0\]</span> 由此，可以发现两个点的和其实是它们的中点。</p><p>可以将仿射变换用齐次坐标写作下面的形式： <spanclass="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\\1\end{matrix}\right]=\left[\begin{matrix}a &amp; b &amp; t_x\\c &amp; d &amp; t_y\\0 &amp; 0 &amp; 1\end{matrix}\right]\times\left[\begin{matrix}x\\y\\1\end{matrix}\right]\]</span></p><h4 id="复合变换composite-transforms">复合变换（CompositeTransforms）</h4><p><span class="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\\1\end{matrix}\right]=A_nA_{n-1}A_{n-2}...A_1\left[\begin{matrix}x\\y\\1\end{matrix}\right]\]</span></p><p>观察仿射变换公式可以发现，进行仿射变换时先进行线性变换后进行平移，所以<span class="math display">\[T_{(t_x,t_y)}\times\left[\begin{matrix}a &amp; b &amp; 0\\c &amp; d &amp; 0\\0 &amp; 0 &amp; 1\end{matrix}\right]=\left[\begin{matrix}a &amp; b &amp; t_x\\c &amp; d &amp; t_y\\0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></p><h3 id="三维变换">三维变换</h3><h4 id="线性变换-1">线性变换</h4><h5 id="缩放矩阵">缩放矩阵</h5><p><span class="math display">\[S(s_x,s_y,s_z)=\left[\begin{matrix}s_x &amp; 0 &amp; 0 &amp; 0\\0 &amp; s_y &amp; 0 &amp; 0\\0 &amp; 0 &amp; s_z &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></p><h5 id="平移矩阵">平移矩阵</h5><p><span class="math display">\[T(t_x,t_y,t_z)=\left[\begin{matrix}1 &amp; 0 &amp; 0 &amp; t_x\\0 &amp; 1 &amp; 0 &amp; t_y\\0 &amp; 0 &amp; 1 &amp; t_z\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></p><h5 id="旋转矩阵">旋转矩阵</h5><p><span class="math display">\[R_x(\alpha)=\left[\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\\0 &amp; cos\alpha &amp; -sin\alpha &amp; 0\\0 &amp; sin\alpha &amp; cos\alpha &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\\R_y(\alpha)=\left[\begin{matrix}cos\alpha &amp; 0 &amp; sin\alpha &amp; 0\\0 &amp; 1 &amp; 0 &amp; 0\\-sin\alpha &amp; 0 &amp; cos\alpha &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\\R_z(\alpha)=\left[\begin{matrix}cos\alpha &amp; -sin\alpha &amp; 0 &amp; 0\\sin\alpha &amp; cos\alpha &amp; 0 &amp; 0\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></p><p>绕一通过原点的轴<span class="math inline">\(\vecn\)</span>转过，有如下矩阵 <span class="math display">\[R(n, \alpha)=cos(\alpha) + (1-cos(\alpha))\vec n\vec n^T + sin(\alpha)\left[\begin{matrix}0 &amp; -n_z &amp; n_y\\n_z &amp; 0 &amp; -n_x\\-n_y &amp; n_x &amp; 0\end{matrix}\right]\]</span> 其中，<strong>n</strong> <span class="math inline">\(= [n_x,n_y, n_z]^T\)</span></p><h4 id="仿射变换">仿射变换</h4><p>对二维变换直接增加一个维度，基本性质保持不变。 <spanclass="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\\z&#39;\\1\end{matrix}\right]=\left[\begin{matrix}a &amp; b &amp; c &amp; t_x\\d &amp; e &amp; f &amp; t_y\\g &amp; h &amp; i &amp; t_z\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\times\left[\begin{matrix}x\\y\\z\\1\end{matrix}\right]\]</span></p><h4 id="观测变换viewing-transformation">观测变换（ViewingTransformation）</h4><h5 id="视图变换viewcamera-transformation">视图变换（View/CameraTransformation）</h5><p>假设有这样一个相机</p><ul><li>位置Posion <span class="math inline">\(\vec e\)</span></li><li>Look-at / gaze direction <span class="math inline">\(\hatg\)</span></li><li>Up direction <span class="math inline">\(\hat t\)</span></li></ul><p>现将相机移动到原点，使其面向-Z方向，向上为Y方向（约定俗成的相机）。</p><p><span class="math inline">\(M_{view} = R_{view}T_{view}\)</span><span class="math display">\[T_{view}=\left[\begin{matrix}1 &amp; 0 &amp; 0 &amp; -x_e\\0 &amp; 1 &amp; 0 &amp; -y_e\\0 &amp; 0 &amp; 1 &amp; -z_e\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span> 直接考虑旋转<span class="math inline">\(\hat g\)</span>到-Z和<span class="math inline">\(\hatt\)</span>到Y并不方便，由于旋转矩阵是正交矩阵，不妨考虑它的逆。</p><p>由 <span class="math display">\[\hat t = R_{view}^{-1} \times\left[\begin{matrix}0\\1\\0\\0\end{matrix}\right],-\hat g = R_{view}^{-1} \times\left[\begin{matrix}0\\0\\1\\0\end{matrix}\right]\]</span> 可以得到 <span class="math display">\[R_{view}^{-1}=\left[\begin{matrix}x_{\hat g \times \hat t} &amp; x_{\hat t} &amp; x_{-\hat g} &amp; 0\\y_{\hat g \times \hat t} &amp; y_{\hat t} &amp; y_{-\hat g} &amp; 0\\z_{\hat g \times \hat t} &amp; z_{\hat t} &amp; z_{-\hat g} &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span> 由此 <span class="math display">\[R_{view}=\left[\begin{matrix}x_{\hat g \times \hat t} &amp; y_{\hat g \times \hat t} &amp; z_{\hat g\times \hat t} &amp; 0\\x_{\hat t} &amp; y_{\hat t} &amp; z_{\hat t} &amp; 0\\x_{-\hat g} &amp; y_{-\hat g} &amp; z_{-\hat g} &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span>至此，就得到了视图转换的矩阵。再将对模型进行同样的转换，即完成了视图转换。由于视图转换也涉及到模型的转换，因此也被称为模型视图转换（ModelViewTransformation）。</p><h5 id="投影变换projection-transformation">投影变换（ProjectionTransformation）</h5><h6 id="正交投影orthographic-projection">正交投影（OrthographicProjection）</h6><p>我们将一个中心在原点的边长为2的且各边分别与x、y、z、轴平行的正方体成为标准立方体（canonicalcube）。</p><p>进行正交投影时，定义一个长方体<span class="math inline">\([l,r]\times [b,t]\times[f,n]\)</span>：（注意由于摄像机朝着-Z，远处的值更小）</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220111151358713.png" alt="image-20220111151358713" style="zoom:50%;" /></p><p>对它进行变换使之成为标准立方体，变换的矩阵为： <spanclass="math display">\[M_{ortho}=\left[\begin{matrix}\frac 2 {r-l} &amp; 0 &amp; 0 &amp; 0\\0 &amp; \frac 2 {t-b} &amp; 0 &amp; 0\\0 &amp; 0 &amp; \frac 2 {n - f} &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\left[\begin{matrix}1 &amp; 0 &amp; 0 &amp; -\frac {r+l} 2\\0 &amp; 1 &amp; 0 &amp; -\frac {t+b} 2\\0 &amp; 0 &amp; 1 &amp; -\frac {n+f} 2\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></p><blockquote><p>OpenGL采用左手系是为了让远处的值更大</p></blockquote><h6 id="透视投影perspective-projection">透视投影（PerspectiveProjection）</h6><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220112121004069.png" alt="image-20220112121004069" style="zoom:50%;" /></p><p>先对透视投影进行处理使其转变为正交投影，再进行正交投影。</p><p>如图所示，为将透视投影转变为正交投影，将透视的光线形成的立体图进行挤压，变成一个长方体。记变换前的点坐标为<spanclass="math inline">\([x,y,z]^T\)</span>，变换后的点坐标为<spanclass="math inline">\([x&#39;,y&#39;,z&#39;]^T\)</span>。 <spanclass="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\\z&#39;\\1\end{matrix}\right]=M_{persp-&gt;ortho}\left[\begin{matrix}x\\y\\z\\1\end{matrix}\right]\]</span></p><ul><li>推导过程</li></ul><p>从侧面观察可以得到如下关系。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220112122248910.png" alt="image-20220112122248910" style="zoom:50%;" /></p><p>由相似关系易得，<span class="math inline">\(x&#39;=\frac n zx\)</span>，<span class="math inline">\(y&#39;=\frac n zy\)</span>。</p><p>易知，对于近平面n上的任一点，变换后的点位置不变。对于远平面上的任一点，变换后的z'=z。</p><p>需要注意的是，对于夹在两平面之间的点，它的<spanclass="math inline">\(z&#39;\neq z\)</span>。 <spanclass="math display">\[\left[\begin{matrix}x&#39;\\y&#39;\\z&#39;\\1\end{matrix}\right]&lt;=&gt;\left[\begin{matrix}\frac n z x\\\frac n z y\\unknown\\1\end{matrix}\right]&lt;=&gt;\left[\begin{matrix}nx\\ny\\unknown\\z\end{matrix}\right]\]</span></p><p><span class="math display">\[\left[\begin{matrix}nx\\ny\\unknown\\z\end{matrix}\right]=M_{persp-&gt;ortho}\left[\begin{matrix}x\\y\\z\\1\end{matrix}\right]\]</span></p><p>由此可得 <span class="math display">\[M_{persp-&gt;ortho}=\left[\begin{matrix}n &amp; 0 &amp; 0 &amp; 0\\0 &amp; n &amp; 0 &amp; 0\\? &amp; ? &amp; ? &amp; ?\\0 &amp; 0 &amp; 1 &amp; 0\end{matrix}\right]\]</span> 而由近平面上点位置变化关系，可得 <span class="math display">\[M_{persp-&gt;ortho}\left[\begin{matrix}x\\y\\n\\1\end{matrix}\right]=\left[\begin{matrix}nx\\ny\\n^2\\n\end{matrix}\right]\]</span> 所以<spanclass="math inline">\(M_{persp-&gt;ortho}\)</span>的第三行为（0 0 A B）,且有 <span class="math display">\[An + B = n^2\tag 1\]</span> 由远平面上中心点的位置变化关系可得 <spanclass="math display">\[M_{persp-&gt;ortho}\left[\begin{matrix}0\\0\\f\\1\end{matrix}\right]=\left[\begin{matrix}0\\0\\f^2\\f\end{matrix}\right]\]</span> 于是有 <span class="math display">\[Af + B=f^2\tag 2\]</span> 联立（1）式、（2）式可得 <span class="math display">\[A=n+f\\B=-nf\]</span> 所以</p><ul><li>结论</li></ul><p><span class="math display">\[M_{persp-&gt;ortho}=\left[\begin{matrix}n &amp; 0 &amp; 0 &amp; 0\\0 &amp; n &amp; 0 &amp; 0\\0 &amp; 0 &amp; n+f &amp; -nf\\0 &amp; 0 &amp; 1 &amp; 0\end{matrix}\right]\]</span></p><p><span class="math display">\[M_{persp}=M_{ortho}M_{persp-&gt;ortho}\]</span></p><blockquote><p>带入两平面中点的坐标<span class="math inline">\([0, 0, \frac {n+f} 2, 1]\)</span>可以发现经变换后该点的z'更接近远平面。</p></blockquote><h5 id="视口变换viewport-transformation">视口变换（ViewportTransformation）</h5><p>对于压缩成标准立方体之前的投影面，定义如下量</p><ul><li>Aspect ratio = width / height</li><li>vertical field-of-view（fovY）</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220112151908323.png" alt="image-20220112151908323" style="zoom:50%;" /></p><p>有 <span class="math display">\[tan\frac {fovY}2 = \frac t {|n|}\\aspect = \frac r t\]</span> 通过视口变换将标准立方体变换到屏幕上。</p><p>定义屏幕如下</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220112152516378.png" alt="image-20220112152516378" style="zoom:50%;" /></p><ul><li><p>屏幕坐标从（0, 0）到（width -1, height - 1）</p></li><li><p>像素点的中心为（x + 0.5, y + 0.5）</p></li><li><p>屏幕覆盖范围为（0, 0）到（width, height）</p></li></ul><p>则视口变换矩阵为 <span class="math display">\[M_{viewport}=\left[\begin{matrix}\frac {width}2 &amp; 0 &amp; 0 &amp; \frac {width}2\\0 &amp; \frac{height}2 &amp; 0 &amp; \frac {height}2\\0 &amp; 0 &amp; 1 &amp; 0\\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></p><h3 id="坐标变换">坐标变换</h3><h4 id="切线空间世界空间">切线空间=&gt;世界空间</h4><p><span class="math display">\[\left[\begin {matrix}x&#39;\\y&#39;\\z&#39;\end {matrix}\right]_{3\times1}=\left[\begin {matrix}T_x &amp; B_x &amp; N_x\\T_y &amp; B_y &amp; N_y\\T_z &amp; B_z &amp; N_z\end {matrix}\right]\times\left[\begin {matrix}x\\y\\z\end {matrix}\right]_{3\times1}\]</span></p><ul><li>其中<span class="math inline">\(M_{TBN}=\left[\begin {matrix}T_x &amp; B_x &amp; N_x\\T_y &amp; B_y &amp; N_y\\T_z &amp; B_z &amp; N_z\end {matrix}\right]\)</span>被称为TBN矩阵，N为法向量</li><li><span class="math inline">\(T=\left[\begin {matrix}N_xN_y/\sqrt{(N_x^2+N_z^2)}\\\sqrt{N_x^2+N_z^2}\\N_zN_y/\sqrt{N_x^2+N_z^2}\end {matrix}\right]\)</span></li><li><span class="math inline">\(B=N\times T\)</span></li></ul><h2 id="光栅化rasterize">光栅化（Rasterize）</h2><p>光栅化：将图形绘制在屏幕上。</p><ul><li>对图形进行采样（Sampling），像素中心点在图形内部的绘上颜色。<ul><li>对所有像素进行遍历</li><li>生成Bounding Box，对Box内的像素点进行遍历。</li><li>找到最底下的顶点后一层一层沿着边扫描上去。</li></ul></li><li>基于三角形的良好性质</li><li>采样频率过低会导致走样（Aliasing），产生锯齿（Jaggies）</li></ul><h3 id="反走样antialiasing">反走样（Antialiasing）</h3><p>对图形先进行模糊处理，再采样。</p><h4 id="模糊处理">模糊处理</h4><p><span class="math display">\[时域f(x)（Spatial\ domain)\begin{matrix}傅里叶变换\\----&gt;\\&lt;----\\傅里叶逆变换\end{matrix}频域F(x)（Frequency\ domain）\]</span></p><p>时域</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220113100646330.png" alt="image-20220113100646330" style="zoom: 33%;" /></p><p>转换为频域</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220113100836907.png" alt="image-20220113100836907" style="zoom:33%;" /></p><blockquote><p>频域图中心表示低频，周围表示高频，亮度表示信息的量</p><p>十字线是由于做变换时图形四方延拓导致的</p></blockquote><h5 id="滤波">滤波</h5><ul><li>过滤掉特定的频率信息。</li><li>高通滤波（High-pass filter）：只留下边界信息。</li><li>低通滤波（Low-pass filter）：抹去边界信息，起到模糊的效果。</li><li>卷积（Convolution）：用一个滤波盒，滤波盒与图像对应部分进行点乘，计算结果写回该部分中心，即取了一个区域的加权平均，能够起到模糊的作用。</li><li>定理：<strong>时域的卷积等于频域的乘积</strong>，时域上的乘积意味着频域上的卷积。</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220113102039971.png" alt="image-20220113102039971" style="zoom: 50%;" /></p><ul><li>滤波盒时域与频域的对应关系：<ul><li>滤波盒越大，留下的频率的范围越小</li><li><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220113102421608.png" alt="image-20220113102421608" style="zoom:50%;" /></li><li><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220113102505824.png" alt="image-20220113102505824" style="zoom:50%;" /></li></ul></li></ul><blockquote><p>走样在频域下的解释：</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220113103933151.png" alt="image-20220113103933151" style="zoom: 67%;" /></p><p>采样间隔太长会导致fs太小，频域的波形图发生混叠。</p><p>由此，当我们将高频信号去掉时，就不会发生混叠，那么就能够达到反走样的目的。这也就是为什么先模糊后采样可以达到反走样的效果。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220113104419361.png" alt="image-20220113104419361" style="zoom:50%;" /></p></blockquote><p>实际的操作中，用一个像素大小作为滤波盒，作卷积操作。</p><p>对于一个像素，三角形可能覆盖部分，根据覆盖的面积进行求平均。</p><p>一种近似方法：MSAA（Multiple Sample Antialiasing）。</p><ul><li>将一个像素划分成多个小的像素，判断小像素是否在三角形内，取平均值</li></ul><h4 id="其它的抗锯齿方案">其它的抗锯齿方案：</h4><ul><li>FXAA（Fast Approximate AA）<ul><li>先得到一个有锯齿的图，再通过图像匹配找到边界并替换成没有锯齿的边界。</li></ul></li><li>TAA（Temporal AA）<ul><li>根据上一帧的信息。</li></ul></li></ul><h4 id="超分辨率">超分辨率</h4><p>DLSS（Deep Learning Super Sampling）</p><h3id="可见性与遮挡visibilityocclusion">可见性与遮挡（Visibility/Occlusion）</h3><blockquote><p>（油）画家算法（Painter's Algorithm）</p><p>先画远的事物，再画近的事物。</p><p>但这种算法无法解决循环遮挡等问题。</p></blockquote><h4 id="深度缓存z-buffer">深度缓存（Z-Buffer）</h4><ul><li>为了简单起见，在这里假定z都为正数，则z越小说明越近，越大说明与越远。</li><li>维护一个光栅化图形信息和一个深度缓存信息。</li><li>对于每一个要绘制的三角形，比较三角形上的每一个像素的深度与当前已绘制的图上该像素点的深度，如果较小，则覆盖绘制并更新深度记录。</li></ul><h2 id="着色shading">着色（Shading）</h2><h3id="一种简单的着色模型冯氏反射blinn-phong-reflectance-model">一种简单的着色模型：冯氏反射（Blinn-PhongReflectance Model）</h3><ul><li>Viewer direction <span class="math inline">\(\hat v\)</span></li><li>Surface normal, <span class="math inline">\(\hat n\)</span></li><li>Light direction, <span class="math inline">\(\hat l\)</span></li><li>Surface parameters（color, shininess（非亮度））</li><li><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220114195034047.png" alt="image-20220114195034047" style="zoom:50%;" /></li><li>漫反射（Diffuse Reflection）<ul><li>光线被均匀地散射到各个方向。</li><li>散射光的强度<span class="math inline">\(L_d=k_d(I/r^2)max(0, \hat n\cdot \hat l)\)</span>, <spanclass="math inline">\(k_d\)</span>为散射系数，用vector3时可以表示颜色</li></ul></li><li>高光（Specular Highlights）<ul><li>当观察方向<span class="math inline">\(\hatv\)</span>与镜面反射光线方向<span class="math inline">\(\hatR\)</span>比较接近时会出现高光，此时<span class="math inline">\(\hatv\)</span>和<span class="math inline">\(\hat l\)</span>的半程向量<spanclass="math inline">\(\hat h=besector(\hat v, \hat l)=\frac {\hat v+\hat l}{||\hat v + \hat l||}\)</span>与法线<spanclass="math inline">\(\hat n\)</span>非常接近。</li><li><span class="math inline">\(L_s=k_s(I/r^2)max(0, cos\alpha)^p\\\ \ \\ \ =k_s(I/r^2)max(0, \hat n \cdot \hat h)^p\)</span></li><li>此处忽略了<span class="math inline">\(\hat l\)</span>和<spanclass="math inline">\(\hatn\)</span>的夹角的影响，指数p是为了使角度分布更小更集中。</li></ul></li><li>环境光照（Ambient Lighting）<ul><li>大胆假设物体各个部分收到的环境光照相同。</li><li><span class="math inline">\(L_a=k_aI_a\)</span></li><li>给物体增加一个常数光照，使它不会完全处于黑色。</li></ul></li><li><span class="math inline">\(L=L_d+L_s+L_a\)</span></li></ul><h3 id="着色频率shading-frequency">着色频率（Shading Frequency）</h3><ul><li><p>平面着色（Flat shading）</p></li><li><p>顶点着色（Gouraud shading）</p><ul><li>顶点的法向量：对与顶点相关的面的法向量求平均（或按面积加权平均）</li><li>用插值法构建顶点之间平滑过渡的法线</li></ul></li><li><p>像素着色（Phong shading）</p></li></ul><h3 id="插值interpolation">插值（Interpolation）</h3><h4 id="重心坐标barycentric-coordinates">重心坐标（BarycentricCoordinates）</h4><ul><li>对于与A、B、C共面的任一点（x, y），若满足<spanclass="math inline">\((x, y) = \alpha A + \beta B + \gammaC\)</span>,<span class="math inline">\((\alpha + \beta + \gamma =1)\)</span> ,则称<span class="math inline">\((\alpha , \beta ,\gamma)\)</span>为点（x, y）的重心坐标。其中<spanclass="math inline">\(\alpha + \beta + \gamma =1\)</span>是为了确保在同一平面。</li><li><span class="math inline">\(\alpha、\beta、\gamma\)</span>满足<spanclass="math inline">\(\alpha = \frac {S_A} {S_A + S_B + S_C}，\beta =\frac {S_B} {S_A + S_B + S_C}，\gamma = \frac {S_C} {S_A + S_B +S_C}\)</span></li><li><spanclass="math inline">\(\alpha、\beta、\gamma\)</span>可以通过下式算得</li></ul><p><span class="math display">\[\alpha=\frac {-(x-x_B)(y_C-y_B) + (y-y_B)(x_C-x_B)} {-(x_A-x_B)(y_C-y_B)+ (y_A - y_B)(x_C-x_B)}\\\beta = \frac {-(x-x_C)(y_A-y_C) + (y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}\\\gamma = 1 - \alpha - \beta\]</span></p><h4 id="插值的应用">插值的应用</h4><ul><li>与A、B、C共面的任一点的属性<span class="math inline">\(V = \alphaV_A + \beta V_B + \gamma V_C\)</span></li><li>对于三维坐标下的物体，应先进行插值再进行投影变换，因为插值在投影变换下不具有不变性。</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220217133115318.png" alt="image-20220217133115318" style="zoom:50%;" /></p><ul><li><p>透视矫正插值</p><p>​<img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220217133142577.png" alt="image-20220217133142577" style="zoom:50%;" /></p><ul><li><span class="math inline">\(Z_t=\frac {1} {\frac {s}{Z_2}+\frac{(1-s)} {Z_1}}\)</span>，对于重心坐标有<spanclass="math inline">\(Z_t=\frac {1} {\frac {\alpha} {\Z_A} + \frac{\beta} {Z_B}+\frac {\gamma} {Z_C}}\)</span></li><li>对于任意属性I,<span class="math inline">\(I_t=(\frac{I_1}{Z_1}+s(\frac {I_2} {Z_2}-\frac {I_1} {Z_1}))/\frac {1}{Z_t}\)</span>，对于重心坐标有<spanclass="math inline">\(I_t=(\alpha\frac{I_A}{Z_A}+\beta\frac{I_B}{Z_B}+\gamma\frac{I_C}{Z_C})/\frac{1}{Z_t}\)</span></li><li>详细推导过程见<a href="透视矫正插值.jpeg">透视矫正插值</a></li></ul></li></ul><h4 id="双线性插值bilinear-interpolation">双线性插值（BilinearInterpolation）</h4><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220213074232375.png" alt="image-20220213074232375" style="zoom: 33%;" /></p><ul><li>Linear interpolation（1D）:<span class="math inline">\(lerp(x, v_0,v_1) = v_0 + x(v_1-v_0)\)</span></li><li>实际运用时<spanclass="math inline">\(lerp(x,v_0,v_1)=(1-x)v_0+xv_1\)</span>效果更好</li></ul><p><span class="math inline">\(u_0=lerp(s,u_{00},u_{10})\)</span></p><p><span class="math inline">\(u_1=lerp(s,u_{01},u_{11})\)</span></p><p><span class="math inline">\(f(x, y) = lerp(t,u_0,u_1)\)</span></p><h3 id="纹理texture">纹理（Texture）</h3><ul><li><p>纹理元素（纹素, texel）：A pixel on texture</p></li><li><p>找到物体上一像素点（x, y, z）与纹素（u, v）的映射关系</p><ul><li>当纹理过小时<ul><li>为了应用到整个物体，纹理会被拉大，出现锯齿。可以用双线性插值去锯齿，双三次（Bicubic）线性插值的视觉效果更好，但开销更大，具体操作为取像素点附近16进行插值</li></ul></li><li>当纹理过大时<ul><li>因物体的采样频率过低，会出现走样的情况。屏幕上越小的物体的一个像素点对应的纹理的范围越大。因此需要一种能够快速得到范围内的纹理的平均的方法（RangeQuery）——Mipmap。</li></ul></li></ul></li></ul><h4 id="mipmap">Mipmap</h4><ul><li>快速、近似、正方形的范围查询。</li><li>由一张图生成一系列图。</li><li>原始图为Level0，分辨率每缩小一倍就是下一个level，直到图片变为1*1，存储开销是原本的<spanclass="math inline">\(\frac 4 3\)</span></li><li>在计算机视觉中Mipmap被称为image pyramid</li></ul><p>为计算应采用的level D，需要得到屏幕上一像素点（x,y）对应的纹理上的范围。范围可以近似为以相邻像素点对应的纹素的距离的较长边作为边长形成的正方形。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220213105858831.png" alt="image-20220213105858831" style="zoom: 50%;" /></p><p><span class="math inline">\(\delta u = \frac {du} {dx} \delta x,\delta x = 1\therefore \delta u = \frac {du} {dx},同理\delta v = \frac{dv} {dy}\)</span></p><p><span class="math inline">\(L = max(\sqrt {(\frac {du} {dx})^2+(\frac{dv} {dx})^2}, \sqrt {(\frac {du} {dy})^2 + (\frac {dv}{dy})^2})\)</span></p><p>要得到L*L范围纹理的平均，level 0 每个纹素都是它自身的平均, level 1每个纹素都是原图2 * 2纹素的平均，因此L * L范围的平均应在<spanclass="math inline">\(level\ D = log_2L\)</span> 中寻找。</p><p>但这种方法得到的纹理存在着不连续的问题，为此，我们引入Trilinearinterpolation。</p><p>对于（x, y），在Mipmap Level D 中进行插值，在Mipmap LevelD+1中进行插值，这两个插值的结果再次进行插值，就可以得到非整数的连续的level。</p><h4 id="各向异性过滤anisotropic-filtering">各向异性过滤（AnisotropicFiltering）</h4><h4 id="ripmap">Ripmap</h4><p>Mipmap由于采用正方形各向同性的特点，难以较好地处理对应纹理上细长（axis-alignedrectangular）或倾斜（diagonalfootprint）的情况，可能会出现Overblur的现象。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220213113410974.png" alt="image-20220213113410974" style="zoom:50%;" /></p><p>引入矩形可以较好地解决对应的细长纹理，但不能解决倾斜的纹理。该方法称为Ripmap。存储开销为原本的四倍。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220213113706200.png" alt="image-20220213113706200" style="zoom:50%;" /></p><h5 id="ewa-filtering">EWA filtering</h5><p>用椭圆加权平均（Elliptically WeightedAverage）进行过滤，能够较好地解决对应纹理呈对角线形的情况，但开销较大。</p><h4 id="纹理的其它应用">纹理的其它应用</h4><h5 id="存储环境光">存储环境光</h5><ul><li>Spherical Environment Map<ul><li>可以将环境光信息储存在球体上，通过球体展开还原环境光，但是球的两极展开会存在较大失真，显得偏大</li></ul></li><li>Cube Map<ul><li>将环境光信息储存在立方体上，失真较小，但需要知道方向。</li></ul></li></ul><h5 id="伪造物体表明凹凸情况">伪造物体表明凹凸情况</h5><ul><li>凹凸贴图（Bump Mapping）<ul><li>通过纹理定义高度差，实现扰动（perturb）表面法线的效果，从而产生凹凸感。</li><li>普通平面的法线在切线空间中为（0, 0,1），而经过扰动的纹理的法线在切线空间中为<spanclass="math inline">\((-\frac {dp} {du}, -\frac {dp} {dv},1).normalized()\)</span></li><li><span class="math inline">\(\frac{dp}{du}=c_1[height(u+1)-height(u)],\frac{dp}{dv}=c_2[height(v+1)-height(v)]\)</span></li><li>切线空间中扰动后的法线左乘TBN矩阵转化为世界空间中的法线</li><li>通过该方法实现的凹凸在图形边缘以及凹凸形成的阴影有瑕疵</li></ul></li><li>法线贴图（Normal Mapping）:与凹凸贴图比较相近</li><li>位移贴图（Displacement Mapping）<ul><li>同样通过纹理定义高度差，但移动了顶点。</li></ul></li></ul><h5 id="补充">补充</h5><ul><li>纹理也可以是三维的，通过噪声函数的一系列处理计算出纹理。</li></ul><h2 id="几何geometry">几何（Geometry）</h2><h3 id="表达几何的方式">表达几何的方式</h3><h4 id="隐式几何implicit-geometry">隐式几何（Implicit Geometry）</h4><ul><li>给定点需要满足的关系的几何体，如<spanclass="math inline">\(x^2+y^2+z^2=1\)</span>。</li><li>标准形式为<span class="math inline">\(f(x,y,z) = 0\)</span></li><li>优点：易于判断点是否在几何体内部，若<spanclass="math inline">\(f(x_1,y_1,z_1)\)</span> &lt; 0，则<spanclass="math inline">\((x_1,y_1,z_1)\)</span>在几何体内部，若等于0则在几何体表面，若大于0则在几何体外部。</li><li>缺点：不够直观</li></ul><h5 id="constructive-solid-geometry">Constructive Solid Geometry</h5><p>通过对简单集合体的布尔运算（交并差）形成复杂集合体。</p><h5 id="signed-distance-functions距离场">Signed DistanceFunctions（距离场）</h5><ul><li><p>距离函数：描述任何一个点到这个几何体表面的最小距离（外正内负）。</p></li><li><p>可以通过找函数值为0的点由函数复原几何体。</p></li><li><p>已知两个几何体的距离函数，对它们进行blend操作，可以得到融合的中间过程的几何图形对应的距离函数，从而还原融合过程的几何图形。</p></li><li><p>Level Set Methods（水平集）表述的距离函数</p><ul><li>通过双线性插值还原<span class="math inline">\(f(x) =0\)</span>的函数，从而得到几何体的表面</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220213223643583.png" alt="image-20220213223643583" style="zoom: 67%;" /></p><h4 id="显式几何explicit-geometry">显式几何（Explicit Geometry）</h4><ul><li>所有点都直接给出或通过映射关系给出。</li><li><span class="math inline">\(f:R^2\rightarrow R^3;(u, v)\rightarrow(x, y, z)\)</span></li><li>优点：直观</li><li>缺点：不宜判断点和几何体的位置关系</li></ul><h5 id="point-cloud点云">Point Cloud（点云）</h5><ul><li>直接给出一系列点</li></ul><h5 id="polygon-mesh">Polygon Mesh</h5><ul><li>often triangles or quads</li></ul><h5 id="the-wavefront-object-file-.obj-format">The Wavefront Object file（.obj） Format</h5><p><imgsrc="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214111230745.png" /></p><p>按照顶点（v）、纹理坐标（vt）、法线（vn）、平面（f）的顺序进行描述，会存在冗余。其中f的格式为第几个v/第几个纹理坐标（vt）/第几个法线（vn）。</p><h5 id="曲线curve">曲线（Curve）</h5><h6 id="贝塞尔曲线bezier-curve">贝塞尔曲线（Bezier Curve）</h6><ul><li>几何定义：给定0~n个点，，对相邻两个点取插值t（<spanclass="math inline">\(0 \le t \le1\)</span>），连接形成的相邻的点，对新生成的点重复操作，直到只生成一个点，这个点即为贝塞尔曲线上的一点。遍历t形成的曲线即贝塞尔曲线。</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214133608595.png" alt="image-20220214133608595" style="zoom: 33%;" /></p><ul><li><p>代数定义：</p><ul><li>对于二次贝塞尔曲线（两轮插值）：</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214133954352.png" alt="image-20220214133954352" style="zoom:33%;" /></p><ul><li>扩展到n轮插值（Bezier curve order n）：</li></ul><p><spanclass="math inline">\(b(t)=b^n(t)=b_0^n(t)=\sum_{j=0}^nb_jB_j^n(t)\)</span>，其中<spanclass="math inline">\(B_i^n(t)=(^n_i)t^i(1-t)^{n-i}\)</span>，为伯恩施坦多项式</p></li><li><p>贝塞尔曲线性质</p><ul><li>对于三次贝塞尔曲线（Cubic Bezier）<ul><li><span class="math inline">\(b(0) = b_0;b(1)=b_3\)</span></li><li><spanclass="math inline">\(b&#39;(0)=3(b_1-b_0);b&#39;(1)=3(b_3-b_2)\)</span></li></ul></li><li>仿射变换不变性：仿射变换前后曲线和控制点（derivative）都对应，可以通过变换控制点得到变换后的曲线。</li><li>投影变换下没有不变性</li><li>曲线在控制点形成的凸包内（Convexhull，控制点形成的最大的凸多边形）</li></ul></li><li><p>逐段的贝塞尔曲线（Piecewise Bezier Curve）</p><ul><li>当n较大时曲线较难控制，且动一个点会影响整条曲线。</li><li>将曲线分段，通常每段曲线都由四个控制点控制。</li><li>曲线连续<ul><li><spanclass="math inline">\(C^0\)</span>连续（continuity）即两端曲线相接，<spanclass="math inline">\(C^1\)</span>连续在相接处的一阶导数相等</li><li><spanclass="math inline">\(C^1\)</span>连续条件：a段曲线与b段曲线满足：<spanclass="math inline">\(a_n=b_0=\frac {1} {2}(a_{n-1}+b_1)\)</span></li></ul></li></ul></li><li><p>样条（spline）</p><ul><li>由一系列控制点控制的连续曲线</li><li>贝塞尔曲线属于spline中的一种曲线</li><li>B-spline（basis spline）<ul><li>基函数由伯恩施坦多项式扩展为其他多项式</li><li>相比贝塞尔曲线需要更多的信息</li><li>满足贝塞尔曲线的所有重要性质</li><li>更多详见https://www.bilibili.com/video/av66548502?from=search&amp;seid=65256805876131485</li></ul></li></ul></li></ul><h5 id="曲面surface">曲面（Surface）</h5><h6 id="贝塞尔曲面">贝塞尔曲面</h6><ul><li>取多条贝塞尔曲线上的点u作为控制点构建贝塞尔曲线，贝塞尔曲线上取点u，遍历（u,v）即可得到曲面，<spanclass="math inline">\(u，v\in[0, 1]\)</span>。</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214155259275.png" alt="image-20220214155259275" style="zoom: 33%;" /></p><h6 id="曲面处理">曲面处理</h6><ul><li>Mesh subdivision、Mesh simplification、Mesh regularization</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214155617928.png" alt="image-20220214155617928" style="zoom:50%;" /></p><h6 id="mesh-subdivision">Mesh Subdivision</h6><ul><li>Loop Subdivision（只试用Triangle Mesh）<ol type="1"><li>细分规则：将一个三角形各边中点相连拆分成四个，这些中点作为新的顶点。</li><li>新顶点更新规则：对新的顶点E，E受原本的顶点的影响，应是它们的加权平均。<spanclass="math inline">\(E=\frac {3} {8}*(A+B)+\frac {1}{8}*(C+D)\)</span><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214200603608.png" alt="image-20220214200603608" style="zoom: 33%;" /></li><li>原顶点更新规则：对于原有的顶点，它的位置与该顶点本身以及顶点周围的原来的顶点有关，所以新的顶点<spanclass="math inline">\(E=(1-n*u)*original\_position+u*neighbor\_position\_sum\)</span>，其中n是该顶点的度，<spanclass="math inline">\(u= (n==3\ ?\ \frac {3} {16} : \frac {3}{8n})\)</span></li></ol></li><li>Catmull-Clark Subdivision（General Mesh）<ul><li>奇异点（Extraordinary vertex）：degree != 4</li><li>细分的步骤<ol type="1"><li>给每个面添加顶点</li><li>给每条边添加中点</li><li>连接面的新增的顶点与边的中点</li></ol></li><li>第一次细分的结果：非四边形面消失，奇异点增加，非四边形面等量转化为奇异点个数</li><li>之后的细分不会再增加奇异点个数</li><li>顶点更新规则Catmull-Clark Vertex Update Rules（Quad Mesh）<ul><li>面上的中点（Face point）<span class="math inline">\(f=\frac {v_1 +v_2+v_3+v_4}{4}\)</span><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214203327120.png" alt="image-20220214203327120" style="zoom:33%;" /></li><li>边的中点（Edge point） <span class="math inline">\(e=\frac{v_1+v_2+f_1+f_2}{4}\)</span><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214203600907.png" alt="image-20220214203600907" style="zoom:33%;" /></li><li>原顶点（Vertex point）<span class="math inline">\(v =\frac{f_1+f_2+f_3+f_4+2(m_1+m_2+m_3+m_4)+4p}{16}\)</span>,p为原定点更新前<img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214204403412.png" alt="image-20220214204403412" style="zoom:33%;" /></li></ul></li></ul></li></ul><h6 id="mesh-simplification">Mesh Simplification</h6><ul><li>边坍缩（Edge collapsing）<ul><li>二次误差度量（Quadric Error Metrics）<ul><li>找一个新的顶点，使其到原本各个面距离的平方和最小</li><li><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220214205120397.png" alt="image-20220214205120397" style="zoom: 33%;" /></li><li>将坍缩各边算出的二次度量误差进行排序，坍缩最小的并更新受影响而变化的二次度量误差值（用优先队列实现）</li></ul></li></ul></li></ul><h3 id="阴影">阴影</h3><h4 id="点光源的阴影shadow-mapping">点光源的阴影（Shadow Mapping）</h4><ol type="1"><li>将虚拟相机放在点光源处，记录看到的各个像素点的深度z，这一系列深度构成shadowmap。</li><li>从真实的相机位置出发，观察各个物体，检测观测点到光源的深度z'，与观测点投影变换到光源视角处的像素点的深度z，若z'&gt; z，则光线无法照射到，应形成阴影</li></ol><ul><li>这种方法形成的阴影为硬阴影，分界线十分鲜明。</li><li>点光源形成的为硬阴影，有体积的光源才能形成软阴影（如太阳光的本影、半影）</li><li>造成shadow mapping效果较脏的原因有：浮点数比较相等不精确，shadowmap的分辨率太低。</li></ul><h2 id="光线追踪ray-tracing">光线追踪（Ray Tracing）</h2><ul><li>使用光线追踪的原因：光栅化难以很好地处理全局效果（软阴影、光线多次反弹）</li><li>光线沿直线传播、光线间不发生碰撞、光路具有可逆性（pathreversal-reciprocity）</li></ul><h3 id="pinhole-camera-model">Pinhole camera Model</h3><ol type="1"><li>从相机出发向投影面的每个像素投射一条eye ray。</li><li>每条eyeray碰到的最近的点与光源进行连线，如果之间没有阻挡，则可以计算出光源在此点反射回相机的光线强度。</li></ol><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220215082729122.png" alt="image-20220215082729122" style="zoom:50%;" /></p><h3 id="recursivewhitted-styleray-tracing">Recursive（Whitted-Style）RayTracing</h3><ul><li>对eyeray经过反射、折射后的光线进行同样操作，像素点最终的着色结果为各光线之和，反射、折射的光线有能量衰减。</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220215083238522.png" alt="image-20220215083238522" style="zoom:50%;" /></p><h3 id="光线与物体表面的交点">光线与物体表面的交点</h3><ul><li>光线传播方向上的点<span class="math inline">\(\vec {r(t)}=\vec o +t\vec d\)</span>，<span class="math inline">\(\veco\)</span>为光线起点（origin），<span class="math inline">\(\vecd\)</span>为光线传播方向（normalized）,<span class="math inline">\(0\let \lt d\)</span></li></ul><h4 id="光线与隐式表面的交点">光线与隐式表面的交点</h4><ul><li>对于隐式曲面上的点<span class="math inline">\(\vecp\)</span>，有<span class="math inline">\(f(\vec p) =0\)</span>，所以有<span class="math inline">\(f(\vec o + t\vecd)=0\)</span></li></ul><h4 id="光线与显式表面的交点">光线与显式表面的交点</h4><h5 id="triangle-mesh">Triangle Mesh</h5><p>一种较为简单但是计算量很大的思路是光线与每一个三角形求交点。</p><ul><li><p>经过p‘的平面方程为<span class="math inline">\((\vec p -\vecp&#39;)\cdot \vec N =0\)</span>，先计算与平面的交点再判断是否在三角形内。</p></li><li><p>直接利用重心坐标。<span class="math inline">\(\vec o +t\vecd=(1-b_1-b_2)\vec P_0 + b_1\vec P_1 +b_2\vec P_2\)</span>，（<spanclass="math inline">\(b_1,b_2,b_1+b_2\in(0,1)且t\ge0\)</span>）三维的点刚好可以解出三个未知量。<spanclass="math inline">\(\tag {Moller Trumbore Algorithm}\)</span></p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220222114821749.png" alt="image-20220222114821749" style="zoom:50%;" /></p></li></ul><p>为加速计算，引入包围盒（Bounding Volume）</p><ul><li><p>当光线与包围盒没有交点时，不可能与三角形有交点。</p></li><li><p>包围盒通常是轴对齐的（Axis-Aligned BoundingBox，AABB），轴对齐的包围盒可以有效降低解光线与包围盒的交点时的维度。</p></li><li><p>任意一条光线所在直线与包围盒的两个对面都有交点<spanclass="math inline">\(t_{min},t_{max}\)</span>。</p></li><li><p>光线进入包围盒的时刻应是光线进入所有对平面之间，光线离开包围盒应是光线离开任一对平面之间。</p></li><li><p><spanclass="math inline">\(t_{enter}=max\{t_{min}\},t_{exit}=min\{t_{max}\}\)</span></p></li><li><p>当且仅当<span class="math inline">\(t_{enter}&lt;t_{exit}\&amp;\&amp; t_{exit}\ge 0\)</span>时光线与AABB盒有交点。</p></li></ul><h5 id="uniform-spatial-partitionsgrids">Uniform SpatialPartitions（Grids）</h5><ol type="1"><li>找到包围盒，将其细分为小格子（grid），在每一个与物体相交的格子中存储物体的信息。</li><li>发射光线，对于与光线相交的格子，若各自内有物体，就对光线和该物体检测相交。</li></ol><ul><li>为保证效率，拆成的格子个数=27*objs</li></ul><p>当场景内的物体分布不均匀时，该方法的效率并不高。</p><h5 id="spatial-partitions">Spatial Partitions</h5><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220215120339918.png" alt="image-20220215120339918" style="zoom: 33%;" /></p><h6 id="oct-tree">Oct-Tree</h6><ul><li>对于每一块区域沿着各个轴方向各切一刀，在三维情况下就是八等分，分割出的区域递归分割，当区域购小或含的物体够少则停止递归。</li><li>缺点：当维度变高时，分割出的区域数增大很快</li></ul><h6 id="bsp-tree">BSP-Tree</h6><ul><li>对每一块区域一次切一刀，尽可能使一个物体不出现在多个区域内</li><li>优点：分割出的区域数与维度无关</li><li>缺点：计算复杂</li></ul><h6 id="kd-tree">KD-Tree</h6><ul><li>对每一块区域沿轴方向切一刀，方向在轴方向之间轮换，能够较好地保证空间切割得较均匀</li><li>分割方向与轴对齐计算量小</li><li>缺点：一个物体可能存在于多个包围盒内，且判断包围盒与物体相交是一件相当困难的事情。</li></ul><p>KD-Tree的建立</p><ul><li>将区域作为一个节点，判断是否要再分割，分割成的区域作为它的孩子节点</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220215125415525.png" alt="image-20220215125415525" style="zoom:50%;" /></p><ul><li>对于每个内部节点，记录分割的轴方向、分割的点以及它的孩子节点</li><li>对于叶子节点，记录区域内的所有的物体</li></ul><p>Traversing a KD-Tree</p><ul><li>检测光线与节点的空间是否有交点（包围盒交点检测的充要条件），如果有，递归检测与两个孩子是否有交点，直到节点为叶子节点。检测光线与叶子节点内所有物体的交点。</li></ul><h5 id="object-partitions-bounding-volume-hierarchybvh">ObjectPartitions &amp; Bounding Volume Hierarchy（BVH）</h5><ul><li>解决了KD-Tree存在的显著问题，得到了广泛应用</li><li>不再对空间进行划分，而是将物体进行划分，对划分完成的物体求包围盒，这样子物体只会出现在一个包围盒内，虽然包围盒之间会存在部分相交</li><li>划分物体时：<ul><li>总是选择对最长的轴进行划分</li><li>划分时以中间的物体（中位数）为分界线划分开，使空间尽可能均匀（运用快速选择算法，时间复杂度为O（n））</li></ul></li><li>BVH Traversal</li></ul><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220215131314587.png" alt="image-20220215131314587" style="zoom:50%;" /></p><h3 id="辐射度量学basic-radiometry">辐射度量学（Basic radiometry）</h3><ul><li><p>Radiant energy <span class="math inline">\(Q[ J = Joule]\)</span></p></li><li><p>Radiant flux <span class="math inline">\(\phi =\frac {dQ}{dt}[W=Watt][lm=lumen]\)</span> 单位时间辐射的能量（Power）</p></li><li><p>Radiant Intensity:<span class="math inline">\(I(\omega)=\frac{d\phi} {d\omega}[\frac {W} {sr}][\frac {lm}{sr}=cd=candela]\)</span>光源单位时间向单位立体角（solidangle）辐射的能量</p></li><li><p>Irradiance:<span class="math inline">\(E(x)=\frac{d\phi(x)}{dA}[\frac {W}{m^2}][\frac{lm}{m^2}=lux]\)</span>物体表面单位面积在单位时间内接收到的能量，<spanclass="math inline">\(\phi\)</span>应与面法向量进行点乘</p></li><li><p>Radiance: <span class="math inline">\(L(p,\omega)=\frac{d^2\phi(p,\omega)}{d\omega dAcos\theta}[\frac{W}{sr\cdotm^2}][\frac {cd}{m^2}=\frac{lm}{sr\cdot m^2}=nit]\)</span>物体表面单位投影面积单位时间内发射、或接收的单位立体角的光的能量</p><blockquote><p>立体角：角度在三维空间中的表示。立体角的大小可用球体进行衡量。<spanclass="math inline">\(\Omega=\frac {A} {r^2}\)</span>sr[steradians]，球有4<span class="math inline">\(\pi\)</span> sr</p><p>孤立点光源（Isotropic Point Source）的<spanclass="math inline">\(I=\frac {\phi} {4\pi}\)</span></p></blockquote></li><li><p>Incident Radiance <span class="math inline">\(L(p,\omega)=\frac{dE(p)}{d\omega cos\theta}\)</span>到达物体表面的单位立体角的Irradiance</p></li><li><p>Exiting Radiance <span class="math inline">\(L(p,\omega)=\frac{dI(p,\omega)}{dAcos\theta}\)</span>物体表面发射单位投影面积发射出的Intensity</p></li><li><p>Irradiance &amp;&amp; Radiance</p><ul><li><span class="math inline">\(E(p)=\int_{H^2}L_i(p,\omega)cos\thetad\omega\)</span>，<spanclass="math inline">\(H^2\)</span>代表半球（Hemisphere）</li></ul></li></ul><h4id="双向反射分布函数bidirectional-reflectance-distribution-functionbrdf">双向反射分布函数BidirectionalReflectance Distribution Function（BRDF）</h4><p>光线在一个点上的反射（散射……）过程就是Radiance转化为点的Irradiance，Irradiance再将能量发射出去作为Radiance的过程。</p><p>为描述光线由Irradiance转化为Radiance的过程，定义BRDF <spanclass="math inline">\(f_r(\omega_i\rightarrow\omega_r)=\frac{dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)cos\theta_id\omega_i}[\frac{1}{sr}]\)</span>用于表征朝各立体角发出的光的能量的比例，则有<span class="math display">\[L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\rightarrow\omega_r)L_i(p,\omega_i)cos\theta_id\omega_i\tag {The ReflectionEquation}\]</span> 推广上式到会发光物体同样适用，有 <span class="math display">\[L_r(p,\omega_r)=L_e(p,\omega_o)+\int_{H^2}f_r(p,\omega_i\rightarrow\omega_r)L_i(p,\omega_i)(n\cdot \omega_i)d\omega_i\tag {The RenderingEquation}\]</span> 上式中的<spanclass="math inline">\(\omega_i\)</span>方向都由点指向平面外。</p><p>经数学方法可化作 <span class="math display">\[L=E+KL\]</span> 即 <span class="math display">\[L=(I-k)^{-1}E\]</span> 展开可得 <span class="math display">\[L=(I+K+K^2+K^3+...)E\]</span></p><p><span class="math display">\[L=E+KE+K^2E+K^3E+...\tag{全局光照}\]</span></p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220218214231011.png" alt="image-20220218214231011" style="zoom: 33%;" /></p><h4 id="蒙特卡洛积分monte-carlo-integration">蒙特卡洛积分（Monte CarloIntegration）</h4><p><spanclass="math inline">\(F_N=\frac{1}{N}\sum^N_{i=1}\frac{f(X_i)}{p(X_i)}\)</span>，推导过程如下：<span class="math display">\[由E[f(x)]=\int f(x)p(x)dx，\\得E[\frac{1}{N}\sum^N_{i=1}\frac{f(X_i)}{p(X_i)}]=\frac{1}{N}E[\sum^N_{i=1}\frac{f(X_i)}{p(X_i)}]=\frac{1}{N}N\int\frac{f(x)}{p(x)}p(x)dx=\int f(x)dx=F_N\]</span></p><h4 id="路径追踪path-tracing">路径追踪（Path Tracing）</h4><p>路径追踪的过程，其实就是解渲染方程的过程。</p><h5 id="一种简单的处理策略">一种简单的处理策略</h5><p>取<spanclass="math inline">\(p(\omega_i)=\frac{1}{2\pi}\)</span>，对半球内的各个方向均匀采样。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219151539492.png" alt="image-20220219151539492" style="zoom: 50%;" /></p><p>但是由于各个点都要考虑来自各个方向的光线，多次弹射的光线会直接爆炸增长，不具有实用意义。</p><h5 id="解决光线数量爆炸增长的策略">解决光线数量爆炸增长的策略</h5><p>由于1的指数次依然是1，每个点需要考虑的光线只随机取一个方向。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219152037164.png" alt="image-20220219152037164" style="zoom:50%;" /></p><p>但这样采样存在非常大的噪声，为减小噪声，必须多次采样。</p><p>对通过一个像素范围内的多条光线均作路径追踪然后取平均值。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219152327527.png" alt="image-20220219152327527" style="zoom:33%;" /></p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219152224645.png" alt="image-20220219152224645" style="zoom:50%;" /></p><p>但shade函数仍有可能无限递归，需要对光线弹射进行一定限制。</p><h5 id="限制光线弹射">限制光线弹射</h5><blockquote><p>俄罗斯轮盘赌（Russian Roulette，RR）：左轮手枪的轮盘内装有部分子弹，转动左轮手枪的轮盘并开枪，若没子弹则没事。</p></blockquote><p>利用俄罗斯轮盘赌的思想，让光线有一定概率不再反弹。</p><p>着色结果为<spanclass="math inline">\(L_o\)</span>，指定概率P，让函数以概率P返回值<spanclass="math inline">\(L_o/p\)</span>，以概率（1-P）直接返回0。可以求得返回值的期望<spanclass="math inline">\(E=P\cdot (L_o/P)+(1-P)\cdot0=L_o\)</span></p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219153533705.png" alt="image-20220219153533705" style="zoom:50%;" /></p><h5 id="提高效率对较小光源精确采样">提高效率，对较小光源精确采样</h5><p>当光源非常小时，对于半球积分实际上是非常低效的，需要进行非常多次的采样才能取得好的效果。</p><p>可以将积分区域由半球转为光源所在面。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219154642400.png" alt="image-20220219154642400" style="zoom: 33%;" /><span class="math display">\[L_o(x,\omega_o)=\int_{\Omega+}L_i(x,\omega_i)f_r(x,\omega_i,\omega_o)cos\thetad\omega_i\\=\int_AL_i(x,\omega_i)f_r(x,\omega_i,\omega_o)\frac{cos\thetacos\theta&#39;}{||x&#39;-x||^2}dA\]</span> 用蒙特卡洛积分法求解时，<spanclass="math inline">\(p(x)=\frac{1}{A}\)</span>。</p><p>除了对光源的采样外，还需要对其它环境光进行采样，由于已经对最明显的光源进行精确采样，对其它环境光的采样不用再像采取这种方法之前一样高频，从而提升了效率。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219160125149.png" alt="image-20220219160125149" style="zoom: 50%;" /></p><h5 id="更多">更多</h5><ul><li>蒙特卡洛积分的重点采样（importance sampling）</li><li>结合半球和光线采样（multiple imp. sampling，MIS）</li><li>pixel reconstruction filter（相较于像素内各点直接取平均）</li><li>radiance到color的转化（gamma correction, curves, color space）</li></ul><h3 id="其它的现代光线追踪技术">其它的现代光线追踪技术</h3><ul><li>Photon mapping</li><li>Metropolis light transpot</li><li>VCM/UPBP</li></ul><h2 id="材质materials">材质（Materials）</h2><p>物体的不同材质表现为它与光的不同作用，实际上就是渲染方程中的BRDF。</p><ul><li>漫反射（diffuse）</li></ul><p>漫反射各方向反射的radiance都相等，所以有 <spanclass="math display">\[L_o(\omega_o)=f_rL_i\int_{H^2}cos\theta_id\omega_i=\pi f_rL_i\\\therefore f_r=\frac{\rho}{\pi}\]</span> <spanclass="math inline">\(\rho\)</span>为反照率（albedo，可多维、可含颜色信息），表征光线能量损失。</p><ul><li>Glossy material（金属类）</li><li>Ideal reflective / refractive material</li></ul><p>此处的BRDF更准确地应描述为BSDF（散射）（BRDF+BTDF（折射）=BSDF），但通常不要紧。</p><h3 id="反射与折射">反射与折射</h3><h4 id="反射">反射</h4><p>给定入射光的入射方向角<spanclass="math inline">\(\omega_i\)</span>和法线<spanclass="math inline">\(\vec n\)</span>，可以解得出射光出射方向角<spanclass="math inline">\(\omega_o=-\omega_i+2(\omega_i\cdot \vec n)\vecn\)</span>。</p><p>给定入射光的方位角<spanclass="math inline">\(\phi_i\)</span>，可得出射光方位角<spanclass="math inline">\(\phi_o=(\phi_i + \pi)\ mod\ 2\pi\)</span>。</p><h4 id="折射">折射</h4><ul><li>Snell's Law: <spanclass="math inline">\(n_isin\theta_i=n_tsin\theta_t\)</span></li></ul><h4 id="菲涅尔项fresnel-term">菲涅尔项（Fresnel Term）</h4><p>当视角与物体表面法线呈不同角度时，反射和折射的光线的比例不同。</p><p>对于绝缘体而言，当光线与物体表面接近垂直时反射的光线很少，当光线与物体表面接近平行时反射的光线很多。</p><p>对导体而言，反射的光线占大部分且随光线与物体表面角度变化不明显。</p><p>菲涅尔项的表达式非常复杂，通常可以用下式近似。 <spanclass="math display">\[R(\theta)=R_0+(1-R_0)(1-cos\theta)^5,\\其中R_0=(\frac{n_1-n_2}{n_1+n_2})^2\]</span></p><h3 id="微表面材质microfacet-material">微表面材质（MicrofacetMaterial）</h3><p>对于微观上凹凸不平的材质，从远处宏观上看看到的是粗糙的平面。</p><p><strong>远处看到的是材质，近处看到的是几何。</strong></p><h4 id="microfacet-brdf">Microfacet BRDF</h4><p>微表面法线完全集中于同一个方向时，表现为mirror。</p><p>微表面的法线较集中于同一个方向时，表现为glossy。</p><p>微表面的法线发散到各个方向时，表现为diffuse。</p><ul><li>BRDF在微表面下的表达式</li></ul><p><spanclass="math inline">\(f(i,o)=\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)}\)</span>，其中F为菲涅尔项，G为shadowing-maskingterm，D为distribution of normals</p><p>微表面的自遮挡、自投影（在入射光线的入射角非常大时较多，grazingangle）</p><p>D=使入射光线沿出射方向的half vector <span class="math inline">\(\vech\)</span>的占比，即微表面上半程向量与法向量相同的比例</p><p><spanclass="math inline">\(D(h)=\frac{e^{-\frac{tan^2\theta_h}{\alpha^2}}}{\pi\alpha^2cos^4\theta_h}\)</span></p><h4id="各向同性isotropic与各向异性anisotropic">各向同性（isotropic）与各向异性（anisotropic）</h4><p>当<span class="math inline">\(f_r(\theta_i,\phi_i;\theta_r,\phi_r)\nef_r(\theta_i,\theta_r,\phi_r-\phi_i)\)</span>时，称该种材质为各项异性。</p><p>一种各向异性的材质——<img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220219211046136.png" alt="image-20220219211046136" style="zoom:33%;" /></p><p>各向异性的材质会呈现一些奇怪的现象，如单向打磨的电梯门光线扭曲、圆周擦洗的锅底呈辐射状。</p><h4 id="brdf的性质">BRDF的性质</h4><ul><li>非负性</li><li>线性可加性</li><li>可逆性 <span class="math inline">\(f_r(\omega_r\rightarrow\omega_i)=f_r(\omega_i\rightarrow \omega_r)\)</span></li><li>能量守恒 <spanclass="math inline">\(\int_{H^2}f_r(\omega_i\rightarrow\omega_r)cos\theta_id\omega_i\le1\)</span></li></ul><h4 id="测量brdf">测量BRDF</h4><ul><li><p>物理上推导得到的菲涅尔项与实际仍存在较大出入，因而近似得到的方程也不可靠，因此直接测量BRDF并记录可以得到更真实的效果。</p></li><li><p>对于各向异性的材质，BRDF有四个参数（维度），对于各向同性的材质，BRDF有三个参数并且由可逆性可以减少一半数据量。</p></li><li><p>MERL BRDF Database存储了大量材质的测量数据。</p></li><li><p>存储BRDF数据也是一个研究重点。</p></li></ul><h2 id="advanced-technology">Advanced Technology</h2><h3 id="advanced-light-transport">Advanced Light Transport</h3><h4id="双向路径追踪bidirectional-path-tracing-bdpt">双向路径追踪（BidirectionalPath Tracing， BDPT）</h4><p>思想：从光源和摄像机各生成一系列半路径，将半路径合成为一条路径。</p><p>无偏估计</p><p>适用：从光源出发的光线传播路径较为复杂时。</p><p>缺点：难实现、渲染慢。</p><h4 id="metropolis-light-transportmlt">Metropolis LightTransport（MLT）</h4><p>思想：若给定一个路径，可以通过马尔可夫链（Markov Chain MonteCarlo，MCMC）在周围产生一系列相似的路径。蒙特卡洛积分的p的函数与待积分的函数越接近，采样效率越高，而通过马尔科夫链可以生成与待积分函数非常一致的函数。</p><p>无偏估计</p><p>适用：光路复杂、焦散（caustics）（先经过specular、再经过diffuse，再经过speculr，SDS）</p><p>缺点：</p><ul><li>无法估计渲染的速度</li><li>是一种局部的方法，得出的结果可能整体上很脏，前后帧图像收敛可能不一致导致动画抖动厉害</li></ul><h4 id="光子映射photon-mapping">光子映射（Photon Mapping）</h4><p>有偏估计但一致</p><p>适用：特别适合用于解决Specular-Diffuse-Specular（SDS）路径和产生caustics</p><p>有许多种实现方法，下面是一种。</p><ol type="1"><li>photontracing：从光源出来的光线不断做反射、折射直到遇到diffuse表面。</li><li>photoncollection：从摄像机发射光线不断做反射、折射直到遇到diffuse表面</li><li>calculation local densityestimation：对任一个着色点，找到最近的N个的光子，计算占的面积，得到光子的密度</li></ol><p>N取越大图的效果越好。但因为<span class="math inline">\(\frac{\DeltaN}{\Delta A} \ne\frac{dN}{dA}\)</span>，所以光子映射是有偏估计，最后得出的结果是糊的。<spanclass="math inline">\(\Delta A\)</span>越小，这两者就会越接近，当<spanclass="math inline">\(\DeltaA\)</span>无穷接近0时，结果会是无偏的。只需要增大发射出的光子数，就可以使<spanclass="math inline">\(\Delta A\)</span>变小，当<spanclass="math inline">\(\DeltaA\)</span>足够小时，图片就不会糊。这也是为什么是找最近的N个光子而不是找固定面积内的光子的数量，因为固定面积内光子的数量是有偏的且<spanclass="math inline">\(\frac{\Delta N}{\Delta A}\)</span>不会收敛于<spanclass="math inline">\(\frac{dN}{dA}\)</span>。</p><h4 id="vertex-connection-and-merging">Vertex Connection andMerging</h4><p>思想：结合双向路径追踪和光子映射。对于BDPT形成的不能相连但能够合并（处于非常接近的一个面内）的子路径端点，用光子映射合并这些端点。</p><h4 id="实时辐射度instant-radiosityir">实时辐射度（InstantRadiosity，IR）</h4><p>思想：从光源形成一系列路径，将路径的端点作为虚拟点光源（Virtual PointLight，VPL），再用虚拟点光源渲染场景。（many-light rendering）</p><p>优点：快速并且在漫反射场景中有较好效果</p><p>缺点：无法处理glossy材质，且当虚拟点光源间太过靠近（如在角落）会出现一些异常的亮点。</p><h3 id="advanced-appearance-modeling">Advanced Appearance Modeling</h3><h4 id="非表面模型non-surface-models">非表面模型（Non-surfacemodels）</h4><h5 id="participating-media-散射参与介质">Participating media散射（参与）介质</h5><ul><li>云、雾</li><li>Phase Function描述了光线如何散射</li><li>从相机触发，随机弹向一个方向，沿直线前进随机一段距离形成一个着色点，着色点与光源连接进行着色。</li></ul><h5 id="hairfurfiber">Hair/fur/fiber</h5><h6 id="hair">Hair</h6><ul><li>Marschner Model</li></ul><p>将头发丝视作圆柱（cuticle和cortex组成），光线与头发丝有三种互动——在表面直接反射（R），从头发一侧进入另一侧穿出（TT），从头发一侧进入在内部经反射再穿出（TRT），其中进入头发的光线会被cortex部分吸收。</p><h6 id="fur">Fur</h6><p>头发模型并不能直接用于毛发模型。</p><p>毛发由cuticle、cortex和medulla（髓质）组成（头发其实也由他们组成，但在头发中髓质非常小，可以忽略）。</p><p>由此有一种双层圆柱模型（double cylindermodel），cortex在外，medulla在内，cortex吸收部分光线，medulla负责散射。光线与头发的交互有五种——TT、R、TRT、TTS、TRTS（S为散射）。</p><h5 id="颗粒材质granular-material">颗粒材质（Granular Material）</h5><h5 id="translucent-material">Translucent Material</h5><p>Translucent：形容光线从一个点进入物体，在内部经过一系列反射、折射从其他地方出去而形成的半透明的感觉，实际上并不是半透明。</p><p>玉石（Jade）、人的皮肤等。</p><p>这种光线传播被称为Subsurface Scattering。</p><p>对于这种传播，需将BRDF推广到BSSRDF。</p><p><spanclass="math inline">\(L_(x_o,\omega_o)=\int_A\int_{H^2}S(x_i,\omega_i,x_o,\omega_o)L_i(x_i,\omega_i)cos\theta_id\omega_idA\)</span></p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220220152548486.png" alt="image-20220220152548486" style="zoom: 50%;" /></p><p>为模拟这种光线传播，人们提出来DipoleApproximation，即在物体表面虚拟一个光源，与原本的真实光源共同作用。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220220152810150.png" alt="image-20220220152810150" style="zoom: 50%;" /></p><p>这种模型渲染的大理石、人脸效果相比BRDF很好。</p><p>布料的渲染：BRDF、participating media</p><h4 id="表面模型surface-models">表面模型（Surface models）</h4><p>对Distribution of normals进行处理可以得到更真实的结果。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220220153435763.png" alt="image-20220220153435763" style="zoom:50%;" /></p><h4 id="程序化生成procedural-appearance">程序化生成（Proceduralappearance）</h4><h2 id="相机">相机</h2><h3 id="fov">FOV</h3><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220220170538961.png" alt="image-20220220170538961" style="zoom:50%;" /></p><p><span class="math inline">\(FOV=2arctan(\frac{h}{2f})\)</span></p><p>人们描述FOV时往往假定胶片为35mm格式（36*24mm），给出焦距f。事实上胶片未必为35mm格式，所以实际焦距应等比例缩放。</p><h3 id="曝光exposure">曝光（Exposure）</h3><p>Exposure H = T * E， T为曝光时间，E为irradiance。</p><p>曝光时间由快门（shutter）决定，irradiance由光圈（aperture）和焦距（focallength）决定。</p><h4 id="光圈aperture">光圈（Aperture）</h4><p>f数（f-stop）:表征光圈的大小，定义为<spanclass="math inline">\(\frac{f}{d}\)</span>，d为光圈直径，f为焦距，f数越小表面光圈越大。通常写作FN或F/N，N为f-number。</p><h4 id="快门shutter">快门（Shutter）</h4><p>快门速度会影响曝光的时间，往往以曝光时间表征，单位通常为ms。</p><p>机械快门打开有一个过程，这会导致不同点采样实际上不同时，对于高速运动的物体会出现扭曲。</p><p>长时间开启会有运动模糊（motionblur），运动模糊可以体现快，也可以抗锯齿。</p><ul><li>f数和快门时间在摄影中往往相互制约，f数变为原来两倍时，光圈大小变为原来二分之一，曝光面积变为原来的四分之一，为保证曝光的量不变，曝光时间应变为原来的四倍。</li></ul><h4 id="感光度iso-gain">感光度（ISO gain）</h4><p>硬件或数学方法直接放大传感器得到的值。</p><p>这是一个线性的值，实际上就是直接对传感器得到结果做一个乘法，当它过大时会出现明显的噪点。</p><h3 id="薄透镜近似thin-lens-approximation">薄透镜近似（Thin LensApproximation）</h3><ul><li>薄凸透镜的性质<ul><li>所有平行于光轴入射透镜的光线折射后必经过焦点</li><li>所有经过焦点入射的光线经薄凸透镜折射后必平行光轴出射</li><li>经过凸透镜中心的光线折射前后方向不变</li></ul></li></ul><p>由上述性质可以在几何上推出<spanclass="math inline">\(\frac{1}{f}=\frac{1}{z_i}+\frac{1}{z_o}\tag{TheThin Lens Equation}\)</span></p><h4 id="circle-of-confusioncoc">Circle of Confusion（CoC）</h4><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220220183931335.png" alt="image-20220220183931335" style="zoom: 33%;" /></p><p>对于非焦平面上的点，它的光线会在传感器的平面上投出一个弥散圆，这就是图片变糊的原因，也就是景深出现的原因。</p><p>由几何关系可得<spanclass="math inline">\(\frac{C}{A}=\frac{d&#39;}{z_i}=\frac{|z_s-z_i|}{z_i}\)</span>。</p><p>由此可以得到光圈（A）越大，弥散圆越大，图片上不在焦平面上的图像越糊。</p><h4 id="ray-tracing-for-defocus-blurthin-lens">Ray Tracing for DefocusBlur（Thin Lens）</h4><p>设定好透镜的焦距、像距，从传感器出发向透镜发射一系列光线，折射的光线用透镜公式得出。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220220185347747.png" alt="image-20220220185347747" style="zoom: 50%;" /></p><h3 id="景深depth-of-field">景深（depth of field）</h3><p>场景中使对应CoC很小（小于或与像素差不多大小）的深度范围。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220220185933827.png" alt="image-20220220185933827" style="zoom: 50%;" /></p><h2 id="光场light-field-lumigraph">光场（Light Field / Lumigraph）</h2><h2 id="光场的引入">光场的引入</h2><ul><li>全光函数（The Plenoptic Function） <spanclass="math inline">\(P(\theta,\phi,\lambda,t,V_x,V_y,V_z)\)</span>可以用于表述在任何时间任何时刻任何角度看到的任意波长的光强度。</li></ul><p>为了描述一个物体，只需要从它外部任何一个角度观察它，记录观察到的每一个点。如果有一个平面能提供相同的信息，则能让我们视觉上得到相同的观察结果。由此，可以引入一个包围盒，包围盒上记录了各个观察方向观察到的各点的样子（plenopticsurface）。</p><p><img src="C:\Users\Zg\AppData\Roaming\Typora\typora-user-images\image-20220221101459812.png" alt="image-20220221101459812" style="zoom: 40%;" /><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220221101732985.png" alt="image-20220221101732985" style="zoom: 40%;" /></p><p>光场记录了任何一个位置往任何一个方向去的光的强度。</p><p>光的描述可以采用点的位置加上方向，同样可以用两个点的位置进行。为了更好地描述光场，我们在我们关心的物体两侧引入两个平面。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220221102606985.png" alt="image-20220221102606985" style="zoom:50%;" /></p><p>两个平面上的点s,u就可以表述光线。若点s的坐标为（s,t），点u的坐标为（u,v），光就可以用s,t,u,v进行描述。</p><h3 id="光场的应用">光场的应用</h3><ul><li>光照照相机</li></ul><p>运用光场的原理，可以做到先拍照，后进行动态变焦的操作。</p><h2 id="色彩color">色彩（Color）</h2><ul><li>谱功率密度（Spectral Power Distribution，SPD）<ul><li>描述一束光中各波长光线的相对强度。</li><li>具有线性可加性。</li></ul></li><li>颜色的生物学原理</li></ul><p>人眼内有视锥细胞，它们负责识别光的颜色。视锥细胞有三种S、M、L，不同人眼中的比例不一样。</p><p>三种不同的细胞对不同波长的光的响应不同，有不同的响应曲线，响应函数分别记作<spanclass="math inline">\(r_S(\lambda),r_M(\lambda),r_L(\lambda)\)</span>。</p><p>人们看到的颜色实际上是它们的响应与光的SPD积分的结果，即 <spanclass="math display">\[S=\int r_S(\lambda)s(\lambda)d\lambda\\M=\int r_M(\lambda)s(\lambda)d\lambda\\L=\int r_L(\lambda)s(\lambda)d\lambda\]</span> 人在接收到（S, M, L）后会产生颜色的感觉。</p><ul><li>同色异谱现象（Metamerism）</li></ul><p>不同的SPD可能对应同一种颜色。因此匹配一种颜色时只需要任意调节SPD，直到想要的颜色出现。</p><h3 id="颜色空间color-space">颜色空间（Color Space）</h3><h4 id="srgb-color-space">（s）RGB Color Space</h4><p>用R、G、B三种颜色去调节得到各种波长对应的颜色。</p><p>人们在实验中发现有些颜色并不能通过直接混合得到，而可以通过目标颜色上加颜色（R）得到我们能直接配出的颜色。这种在目标颜色上加颜色的比例记作负数。实验结果如下：</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220221105906914.png" alt="image-20220221105906914" style="zoom:50%;" /></p><p>同样地可以计算得到RGB分量 <span class="math display">\[R=\int_\lambda s(\lambda)\overline r(\lambda)d\lambda\\G=\int_\lambda s(\lambda)\overline g(\lambda)d\lambda\\B=\int_\lambda s(\lambda)\overline b(\lambda)d\lambda\]</span></p><ul><li>RGB系统并不能定义所有颜色。</li></ul><h4 id="xyz-color-space">XYZ Color Space</h4><p>直接定义各个颜色匹配函数如下图：</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220221110422581.png" alt="image-20220221110422581" style="zoom:33%;" /></p><p>其中Y分量代表颜色的亮度（luminance）。</p><p>颜色匹配函数满足以下性质：</p><ul><li>匹配函数都严格非负。</li><li>覆盖了所有可以观察到的颜色。</li></ul><p>为了将该色域可视化，对各分量作归一化处理，定义归一化后的变量为<strong>色度（Chromaticity）</strong>。<span class="math display">\[x= \frac{X}{X+Y+Z}\\y= \frac{Y}{X+Y+Z}\\z= \frac{Z}{X+Y+Z}\]</span> 因为x+y+z=1，所以只需要记录两个参数（通常是x, y）。</p><p>实际上，该图仍然受三个参数X、Y、Z控制，为了改变x、y，人们往往固定Y，改变X和Z，因为Y控制的只是亮度。所以最终可视化的色域图实际上是一固定亮度下的图。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220221111251223.png" alt="image-20220221111251223" style="zoom:50%;" /></p><p>色域图边缘的颜色最纯净，最中心的白色最不纯净。</p><h4 id="hsv-color-spacehue-saturation-valuebrightnesslightness">HSVColor Space（Hue-Saturation-Value/Brightness/Lightness）</h4><p>色调-饱和度-亮度</p><p>大量运用于取色器。</p><h4 id="lab-color-space">LAB Color Space</h4><p>L是亮度，a、b是两对互补色，其中a为红绿互补色对，b为黄蓝互补色对。</p><p><img src="https://raw.githubusercontent.com/JHex-git/images/master/image/2023/02/22/image-20220221112217688.png" alt="image-20220221112217688" style="zoom:50%;" /></p><h4 id="减色系统">减色系统</h4><p>CMYK（Cyan、Megenta、Yellow and blacK）</p><h4 id="色域gamut">色域（Gamut）</h4><p>一个颜色空间所有可能显示的颜色。</p>]]></content>
    
    
    <categories>
      
      <category>长篇笔记</category>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>长篇笔记</tag>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
